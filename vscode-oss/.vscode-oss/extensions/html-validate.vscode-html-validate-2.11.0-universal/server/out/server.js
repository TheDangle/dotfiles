"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is = __commonJS({
  "node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports2.thenable = thenable;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports2.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType2;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType22 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType22;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports2.Message = Message = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports2.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache2 = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache2;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable || (exports2.Disposable = Disposable = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event || (exports2.Event = Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports2.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports2.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports2.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports2.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports2.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column: while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4;
                    offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports2.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports2.TraceValues = TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports2.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports2.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports2.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports2.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports2.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports2.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports2.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports2.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports2.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports2.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version2 = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace2 = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed2() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type2;
        let requestHandler;
        if (element) {
          type2 = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type2 !== void 0 && type2.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type2.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type2 !== void 0 && type2.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type2 !== void 0 && type2.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type2 = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type2 = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type2 !== void 0) {
                  if (type2.numberOfParams !== 0 && type2.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type2.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type2 !== void 0) {
                    if (type2.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type2.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type2.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type2 !== void 0 && type2.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace2) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace2 === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace2 === Trace.Verbose || trace2 === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace2 === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace2 === Trace.Verbose || trace2 === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace2 === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace2 === Trace.Verbose || trace2 === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace2 === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace2 === Trace.Verbose || trace2 === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace2 === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace2 === Trace.Verbose || trace2 === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace2 === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace2 === Trace.Verbose || trace2 === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type2, message) {
        if (!tracer || trace2 === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type: type2,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed2()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type2, params) {
        let result;
        const numberOfParams = type2.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type2.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection2 = {
        sendNotification: (type2, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type2)) {
            method = type2;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type2.method;
            messageParams = computeMessageParams(type2, params);
          }
          const notificationMessage = {
            jsonrpc: version2,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error) => {
            logger.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type2, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type2)) {
            starNotificationHandler = type2;
          } else if (handler) {
            if (Is.string(type2)) {
              method = type2;
              notificationHandlers.set(type2, { type: void 0, handler });
            } else {
              method = type2.method;
              notificationHandlers.set(type2.method, { type: type2, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection2.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type2, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type2)) {
            method = type2;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type2.method;
            messageParams = computeMessageParams(type2, params);
            const numberOfParams = type2.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection2, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version2,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve, reject) => {
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error) {
              logger.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type2, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type2)) {
            method = void 0;
            starRequestHandler = type2;
          } else if (Is.string(type2)) {
            method = null;
            if (handler !== void 0) {
              method = type2;
              requestHandlers.set(type2, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type2.method;
              requestHandlers.set(type2.method, { type: type2, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace2 = _value;
          traceFormat = _traceFormat;
          if (trace2 === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed2() && !isDisposed()) {
            await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection2.onNotification(LogTraceNotification.type, (params) => {
        if (trace2 === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace2 === Trace.Verbose || trace2 === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection2.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection2;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.AbstractMessageBuffer = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports2, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports2, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports2, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports2, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require("util");
    var api_1 = require_api();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream2) {
        this.stream = stream2;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream2) {
        this.stream = stream2;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream2) => new ReadableStreamWrapper(stream2),
        asWritableStream: (stream2) => new WritableStreamWrapper(stream2)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.PortMessageWriter = exports2.PortMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path5 = require("path");
    var os = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var api_1 = require_api();
    __exportStar(require_api(), exports2);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this.onData = new api_1.Emitter();
        port.on("close", () => this.fireClose);
        port.on("error", (error) => this.fireError(error));
        port.on("message", (message) => {
          this.onData.fire(message);
        });
      }
      listen(callback) {
        return this.onData.event(callback);
      }
    };
    exports2.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on("close", () => this.fireClose());
        port.on("error", (error) => this.fireError(error));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path5.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path5.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
    (function(factory2) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory2(require, exports2);
        if (v !== void 0) module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory2);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = exports3.EOL = exports3.WorkspaceFolder = exports3.InlineCompletionContext = exports3.SelectedCompletionInfo = exports3.InlineCompletionTriggerKind = exports3.InlineCompletionList = exports3.InlineCompletionItem = exports3.StringValue = exports3.InlayHint = exports3.InlayHintLabelPart = exports3.InlayHintKind = exports3.InlineValueContext = exports3.InlineValueEvaluatableExpression = exports3.InlineValueVariableLookup = exports3.InlineValueText = exports3.SemanticTokens = exports3.SemanticTokenModifiers = exports3.SemanticTokenTypes = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionTriggerKind = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.WorkspaceSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.CompletionItemLabelDetails = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = exports3.URI = exports3.DocumentUri = void 0;
      var DocumentUri;
      (function(DocumentUri2) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri || (exports3.DocumentUri = DocumentUri = {}));
      var URI2;
      (function(URI3) {
        function is(value) {
          return typeof value === "string";
        }
        URI3.is = is;
      })(URI2 || (exports3.URI = URI2 = {}));
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
        }
        integer2.is = is;
      })(integer || (exports3.integer = integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger || (exports3.uinteger = uinteger = {}));
      var Position;
      (function(Position2) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position2.is = is;
      })(Position || (exports3.Position = Position = {}));
      var Range;
      (function(Range2) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
          } else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range2.is = is;
      })(Range || (exports3.Range = Range = {}));
      var Location;
      (function(Location2) {
        function create(uri, range2) {
          return { uri, range: range2 };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location || (exports3.Location = Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink || (exports3.LocationLink = LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red3, green2, blue2, alpha) {
          return {
            red: red3,
            green: green2,
            blue: blue2,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color || (exports3.Color = Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range2, color) {
          return {
            range: range2,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation || (exports3.ColorInformation = ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation || (exports3.ColorPresentation = ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind || (exports3.FoldingRangeKind = FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange || (exports3.FoldingRange = FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation || (exports3.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity2;
      (function(DiagnosticSeverity3) {
        DiagnosticSeverity3.Error = 1;
        DiagnosticSeverity3.Warning = 2;
        DiagnosticSeverity3.Information = 3;
        DiagnosticSeverity3.Hint = 4;
      })(DiagnosticSeverity2 || (exports3.DiagnosticSeverity = DiagnosticSeverity2 = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag || (exports3.DiagnosticTag = DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription || (exports3.CodeDescription = CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range2, message, severity, code, source, relatedInformation) {
          var result = { range: range2, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic || (exports3.Diagnostic = Diagnostic = {}));
      var Command2;
      (function(Command3) {
        function create(title2, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title: title2, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command3.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command3.is = is;
      })(Command2 || (exports3.Command = Command2 = {}));
      var TextEdit;
      (function(TextEdit2) {
        function replace(range2, newText) {
          return { range: range2, newText };
        }
        TextEdit2.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit2.insert = insert;
        function del(range2) {
          return { range: range2, newText: "" };
        }
        TextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
        }
        TextEdit2.is = is;
      })(TextEdit || (exports3.TextEdit = TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description2) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description2 !== void 0) {
            result.description = description2;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation || (exports3.ChangeAnnotation = ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier || (exports3.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range2, newText, annotation) {
          return { range: range2, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range2, annotation) {
          return { range: range2, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit || (exports3.AnnotatedTextEdit = AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit || (exports3.TextDocumentEdit = TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile || (exports3.CreateFile = CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile || (exports3.RenameFile = RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile || (exports3.DeleteFile = DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit || (exports3.WorkspaceEdit = WorkspaceEdit = {}));
      var TextEditChangeImpl = (
        /** @class */
        (function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range2, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.replace(range2, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range2, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range2, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range2, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.del(range2);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range2, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range2, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        })()
      );
      var ChangeAnnotations = (
        /** @class */
        (function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        })()
      );
      var WorkspaceChange = (
        /** @class */
        (function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            /**
             * Returns the underlying {@link WorkspaceEdit} literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        })()
      );
      exports3.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier || (exports3.TextDocumentIdentifier = TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version2) {
          return { uri, version: version2 };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier || (exports3.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version2) {
          return { uri, version: version2 };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier || (exports3.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version2, text) {
          return { uri, languageId, version: version2, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem || (exports3.TextDocumentItem = TextDocumentItem = {}));
      var MarkupKind;
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind || (exports3.MarkupKind = MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent || (exports3.MarkupContent = MarkupContent = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind || (exports3.CompletionItemKind = CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat || (exports3.InsertTextFormat = InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag || (exports3.CompletionItemTag = CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit || (exports3.InsertReplaceEdit = InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode || (exports3.InsertTextMode = InsertTextMode = {}));
      var CompletionItemLabelDetails;
      (function(CompletionItemLabelDetails2) {
        function is(value) {
          var candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails || (exports3.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem || (exports3.CompletionItem = CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList || (exports3.CompletionList = CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString || (exports3.MarkedString = MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
        }
        Hover2.is = is;
      })(Hover || (exports3.Hover = Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation || (exports3.ParameterInformation = ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation || (exports3.SignatureInformation = SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind || (exports3.DocumentHighlightKind = DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range2, kind) {
          var result = { range: range2 };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight || (exports3.DocumentHighlight = DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind || (exports3.SymbolKind = SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag || (exports3.SymbolTag = SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range2, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range: range2 }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation || (exports3.SymbolInformation = SymbolInformation = {}));
      var WorkspaceSymbol;
      (function(WorkspaceSymbol2) {
        function create(name, kind, uri, range2) {
          return range2 !== void 0 ? { name, kind, location: { uri, range: range2 } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol2.create = create;
      })(WorkspaceSymbol || (exports3.WorkspaceSymbol = WorkspaceSymbol = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range2, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range: range2,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol || (exports3.DocumentSymbol = DocumentSymbol = {}));
      var CodeActionKind2;
      (function(CodeActionKind3) {
        CodeActionKind3.Empty = "";
        CodeActionKind3.QuickFix = "quickfix";
        CodeActionKind3.Refactor = "refactor";
        CodeActionKind3.RefactorExtract = "refactor.extract";
        CodeActionKind3.RefactorInline = "refactor.inline";
        CodeActionKind3.RefactorRewrite = "refactor.rewrite";
        CodeActionKind3.Source = "source";
        CodeActionKind3.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind3.SourceFixAll = "source.fixAll";
      })(CodeActionKind2 || (exports3.CodeActionKind = CodeActionKind2 = {}));
      var CodeActionTriggerKind;
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind || (exports3.CodeActionTriggerKind = CodeActionTriggerKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext || (exports3.CodeActionContext = CodeActionContext = {}));
      var CodeAction2;
      (function(CodeAction3) {
        function create(title2, kindOrCommandOrEdit, kind) {
          var result = { title: title2 };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command2.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction3.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command2.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction3.is = is;
      })(CodeAction2 || (exports3.CodeAction = CodeAction2 = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range2, data) {
          var result = { range: range2 };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command2.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens || (exports3.CodeLens = CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions || (exports3.FormattingOptions = FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range2, target, data) {
          return { range: range2, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink || (exports3.DocumentLink = DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range2, parent2) {
          return { range: range2, parent: parent2 };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange || (exports3.SelectionRange = SelectionRange = {}));
      var SemanticTokenTypes;
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes || (exports3.SemanticTokenTypes = SemanticTokenTypes = {}));
      var SemanticTokenModifiers;
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers || (exports3.SemanticTokenModifiers = SemanticTokenModifiers = {}));
      var SemanticTokens;
      (function(SemanticTokens2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens || (exports3.SemanticTokens = SemanticTokens = {}));
      var InlineValueText;
      (function(InlineValueText2) {
        function create(range2, text) {
          return { range: range2, text };
        }
        InlineValueText2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText || (exports3.InlineValueText = InlineValueText = {}));
      var InlineValueVariableLookup;
      (function(InlineValueVariableLookup2) {
        function create(range2, variableName, caseSensitiveLookup) {
          return { range: range2, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup || (exports3.InlineValueVariableLookup = InlineValueVariableLookup = {}));
      var InlineValueEvaluatableExpression;
      (function(InlineValueEvaluatableExpression2) {
        function create(range2, expression) {
          return { range: range2, expression };
        }
        InlineValueEvaluatableExpression2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression || (exports3.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
      var InlineValueContext;
      (function(InlineValueContext2) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext || (exports3.InlineValueContext = InlineValueContext = {}));
      var InlayHintKind;
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind || (exports3.InlayHintKind = InlayHintKind = {}));
      var InlayHintLabelPart;
      (function(InlayHintLabelPart2) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command2.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart || (exports3.InlayHintLabelPart = InlayHintLabelPart = {}));
      var InlayHint;
      (function(InlayHint2) {
        function create(position, label, kind) {
          var result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint || (exports3.InlayHint = InlayHint = {}));
      var StringValue;
      (function(StringValue2) {
        function createSnippet(value) {
          return { kind: "snippet", value };
        }
        StringValue2.createSnippet = createSnippet;
      })(StringValue || (exports3.StringValue = StringValue = {}));
      var InlineCompletionItem;
      (function(InlineCompletionItem2) {
        function create(insertText, filterText, range2, command) {
          return { insertText, filterText, range: range2, command };
        }
        InlineCompletionItem2.create = create;
      })(InlineCompletionItem || (exports3.InlineCompletionItem = InlineCompletionItem = {}));
      var InlineCompletionList;
      (function(InlineCompletionList2) {
        function create(items) {
          return { items };
        }
        InlineCompletionList2.create = create;
      })(InlineCompletionList || (exports3.InlineCompletionList = InlineCompletionList = {}));
      var InlineCompletionTriggerKind;
      (function(InlineCompletionTriggerKind2) {
        InlineCompletionTriggerKind2.Invoked = 0;
        InlineCompletionTriggerKind2.Automatic = 1;
      })(InlineCompletionTriggerKind || (exports3.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
      var SelectedCompletionInfo;
      (function(SelectedCompletionInfo2) {
        function create(range2, text) {
          return { range: range2, text };
        }
        SelectedCompletionInfo2.create = create;
      })(SelectedCompletionInfo || (exports3.SelectedCompletionInfo = SelectedCompletionInfo = {}));
      var InlineCompletionContext;
      (function(InlineCompletionContext2) {
        function create(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext2.create = create;
      })(InlineCompletionContext || (exports3.InlineCompletionContext = InlineCompletionContext = {}));
      var WorkspaceFolder;
      (function(WorkspaceFolder2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && URI2.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder2.is = is;
      })(WorkspaceFolder || (exports3.WorkspaceFolder = WorkspaceFolder = {}));
      exports3.EOL = ["\n", "\r\n", "\r"];
      var TextDocument2;
      (function(TextDocument3) {
        function create(uri, languageId, version2, content) {
          return new FullTextDocument2(uri, languageId, version2, content);
        }
        TextDocument3.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument3.is = is;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort2(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument3.applyEdits = applyEdits;
        function mergeSort2(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort2(left, compare);
          mergeSort2(right, compare);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument2 || (exports3.TextDocument = TextDocument2 = {}));
      var FullTextDocument2 = (
        /** @class */
        (function() {
          function FullTextDocument3(uri, languageId, version2, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version2;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument3.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument3.prototype.getText = function(range2) {
            if (range2) {
              var start = this.offsetAt(range2.start);
              var end = this.offsetAt(range2.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument3.prototype.update = function(event, version2) {
            this._content = event.text;
            this._version = version2;
            this._lineOffsets = void 0;
          };
          FullTextDocument3.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument3.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument3.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument3;
        })()
      );
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is2.numberRange = numberRange;
        function integer2(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (exports2.MessageDirection = MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest || (exports2.ImplementationRequest = ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest || (exports2.TypeDefinitionRequest = TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest || (exports2.ConfigurationRequest = ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest || (exports2.DocumentColorRequest = DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest || (exports2.ColorPresentationRequest = ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest || (exports2.FoldingRangeRequest = FoldingRangeRequest = {}));
    var FoldingRangeRefreshRequest;
    (function(FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (exports2.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest || (exports2.DeclarationRequest = DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest || (exports2.SelectionRangeRequest = SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress || (exports2.WorkDoneProgress = WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat || (exports2.TokenFormat = TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest || (exports2.SemanticTokensRequest = SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest || (exports2.ShowDocumentRequest = ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind || (exports2.FileOperationPatternKind = FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest || (exports2.WillCreateFilesRequest = WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification || (exports2.DidCreateFilesNotification = DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest || (exports2.WillRenameFilesRequest = WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification || (exports2.DidRenameFilesNotification = DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel || (exports2.UniquenessLevel = UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind || (exports2.MonikerKind = MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (exports2.MonikerRequest = MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest || (exports2.InlineValueRequest = InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest || (exports2.InlayHintRequest = InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest || (exports2.InlayHintResolveRequest = InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind || (exports2.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary || (exports2.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (exports2.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version2, cells) {
        return { uri, notebookType, version: version2, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument || (exports2.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange || (exports2.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionRequest = void 0;
    var messages_1 = require_messages2();
    var InlineCompletionRequest;
    (function(InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (exports2.InlineCompletionRequest = InlineCompletionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangesFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
    exports2.InlineCompletionRequest = exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    Object.defineProperty(exports2, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRefreshRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
    Object.defineProperty(exports2, "InlineCompletionRequest", { enumerable: true, get: function() {
      return protocol_inlineCompletion_1.InlineCompletionRequest;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter || (exports2.TextDocumentFilter = TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter || (exports2.NotebookDocumentFilter = NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector || (exports2.DocumentSelector = DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest || (exports2.RegistrationRequest = RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest || (exports2.UnregistrationRequest = UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind || (exports2.ResourceOperationKind = ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind || (exports2.FailureHandlingKind = FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind || (exports2.PositionEncodingKind = PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions || (exports2.StaticRegistrationOptions = StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest || (exports2.InitializeRequest = InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes || (exports2.InitializeErrorCodes = InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification || (exports2.InitializedNotification = InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest || (exports2.ShutdownRequest = ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification || (exports2.ExitNotification = ExitNotification = {}));
    var DidChangeConfigurationNotification2;
    (function(DidChangeConfigurationNotification3) {
      DidChangeConfigurationNotification3.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification3.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification3.method);
    })(DidChangeConfigurationNotification2 || (exports2.DidChangeConfigurationNotification = DidChangeConfigurationNotification2 = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
      MessageType2.Debug = 5;
    })(MessageType || (exports2.MessageType = MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification || (exports2.ShowMessageNotification = ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest || (exports2.ShowMessageRequest = ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification || (exports2.LogMessageNotification = LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification || (exports2.TelemetryEventNotification = TelemetryEventNotification = {}));
    var TextDocumentSyncKind2;
    (function(TextDocumentSyncKind3) {
      TextDocumentSyncKind3.None = 0;
      TextDocumentSyncKind3.Full = 1;
      TextDocumentSyncKind3.Incremental = 2;
    })(TextDocumentSyncKind2 || (exports2.TextDocumentSyncKind = TextDocumentSyncKind2 = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason || (exports2.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType || (exports2.FileChangeType = FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern || (exports2.RelativePattern = RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind || (exports2.WatchKind = WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind || (exports2.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest || (exports2.CompletionRequest = CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest || (exports2.CompletionResolveRequest = CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest || (exports2.HoverRequest = HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest || (exports2.SignatureHelpRequest = SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest || (exports2.DefinitionRequest = DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest || (exports2.ReferencesRequest = ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest || (exports2.DocumentHighlightRequest = DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest || (exports2.DocumentSymbolRequest = DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest || (exports2.CodeActionRequest = CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest || (exports2.CodeActionResolveRequest = CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest || (exports2.CodeLensRequest = CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest || (exports2.CodeLensResolveRequest = CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest || (exports2.DocumentLinkRequest = DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest || (exports2.DocumentFormattingRequest = DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
    var DocumentRangesFormattingRequest;
    (function(DocumentRangesFormattingRequest2) {
      DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
      DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
    })(DocumentRangesFormattingRequest || (exports2.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest || (exports2.RenameRequest = RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest || (exports2.PrepareRenameRequest = PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest || (exports2.ExecuteCommandRequest = ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar(require_main2(), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes || (exports2.LSPErrorCodes = LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports2);
    __exportStar(require_api2(), exports2);
    function createProtocolConnection(input, output, logger, options) {
      return (0, node_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class _V4UUID extends ValueUUID {
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return _V4UUID._oneOf(_V4UUID._chars);
      }
      constructor() {
        super([
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          "4",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._oneOf(_V4UUID._timeHighBits),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex()
        ].join(""));
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports2.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports2.isUUID = isUUID;
    function parse3(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports2.parse = parse3;
    function generateUuid() {
      return v4().asHex();
    }
    exports2.generateUuid = generateUuid;
  }
});

// node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class _WorkDoneProgressReporterImpl {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        _WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title2, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title: title2,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        _WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection2, token) {
        super(connection2, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection2, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection2, token);
    }
    exports2.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          if (capabilities?.window?.workDoneProgress === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = (0, uuid_1.generateUuid)();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports2.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection2, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection2, token);
    }
    exports2.attachPartialResult = attachPartialResult;
  }
});

// node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            if (Array.isArray(result)) {
              return Array.isArray(arg) ? result : result[0];
            } else {
              return Array.isArray(arg) ? [] : null;
            }
          });
        }
      };
    };
    exports2.ConfigurationFeature = ConfigurationFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        fillServerCapabilities(capabilities) {
          super.fillServerCapabilities(capabilities);
          const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
          this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._notificationIsAutoRegistered && !this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type2 = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              return this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type2 = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              return this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            }
          };
        }
      };
    };
    exports2.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
            },
            on: (handler) => {
              const type2 = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              return this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            },
            onDelta: (handler) => {
              const type2 = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              return this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            },
            onRange: (handler) => {
              const type2 = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              return this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            }
          };
        }
      };
    };
    exports2.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensDiff = class {
      constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
      }
      computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
            originalEndIndex++;
            modifiedEndIndex++;
          }
          const deleteCount = originalEndIndex - startIndex + 1;
          const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
          if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
            return [
              { start: startIndex, deleteCount: deleteCount - 1 }
            ];
          } else {
            return [
              { start: startIndex, deleteCount, data: newData }
            ];
          }
        } else if (startIndex < modifiedLength) {
          return [
            { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
          ];
        } else if (startIndex < originalLength) {
          return [
            { start: startIndex, deleteCount: originalLength - startIndex }
          ];
        } else {
          return [];
        }
      }
    };
    exports2.SemanticTokensDiff = SemanticTokensDiff;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          return {
            resultId: this.id,
            edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
          };
        } else {
          return this.build();
        }
      }
    };
    exports2.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports2.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports2.FileOperationsFeature = FileOperationsFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TypeHierarchyFeature = (Base) => {
      return class extends Base {
        get typeHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onSupertypes: (handler) => {
              const type2 = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
              return this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            },
            onSubtypes: (handler) => {
              const type2 = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
              return this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            }
          };
        }
      };
    };
    exports2.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineValueFeature = (Base) => {
      return class extends Base {
        get inlineValue() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineValueFeature = InlineValueFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/foldingRange.js
var require_foldingRange = __commonJS({
  "node_modules/vscode-languageserver/lib/common/foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FoldingRangeFeature = (Base) => {
      return class extends Base {
        get foldingRange() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
            },
            on: (handler) => {
              const type2 = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
              return this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            }
          };
        }
      };
    };
    exports2.FoldingRangeFeature = FoldingRangeFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlayHintFeature = (Base) => {
      return class extends Base {
        get inlayHint() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            },
            resolve: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                return handler(params, cancel);
              });
            }
          };
        }
      };
    };
    exports2.InlayHintFeature = InlayHintFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var DiagnosticFeature = (Base) => {
      return class extends Base {
        get diagnostics() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
              });
            },
            onWorkspace: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
              });
            }
          };
        }
      };
    };
    exports2.DiagnosticFeature = DiagnosticFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/textDocuments.js
var require_textDocuments = __commonJS({
  "node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TextDocuments2 = class {
      /**
       * Create a new text document manager.
       */
      constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened.
       */
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened or the content changes.
       */
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * will be saved.
       */
      get onWillSave() {
        return this._onWillSave.event;
      }
      /**
       * Sets a handler that will be called if a participant wants to provide
       * edits during a text document save.
       */
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been saved.
       */
      get onDidSave() {
        return this._onDidSave.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been closed.
       */
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Returns the document for the given URI. Returns undefined if
       * the document is not managed by this instance.
       *
       * @param uri The text document's URI to retrieve.
       * @return the text document or `undefined`.
       */
      get(uri) {
        return this._syncedDocuments.get(uri);
      }
      /**
       * Returns all text documents managed by this instance.
       *
       * @return all text documents.
       */
      all() {
        return Array.from(this._syncedDocuments.values());
      }
      /**
       * Returns the URIs of all text documents managed by this instance.
       *
       * @return the URI's of all text documents.
       */
      keys() {
        return Array.from(this._syncedDocuments.keys());
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the text documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
       * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
       *
       * Use the corresponding events on the TextDocuments instance instead.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        connection2.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection2.onDidOpenTextDocument((event) => {
          const td2 = event.textDocument;
          const document = this._configuration.create(td2.uri, td2.languageId, td2.version, td2.text);
          this._syncedDocuments.set(td2.uri, document);
          const toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection2.onDidChangeTextDocument((event) => {
          const td2 = event.textDocument;
          const changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          const { version: version2 } = td2;
          if (version2 === null || version2 === void 0) {
            throw new Error(`Received document change event for ${td2.uri} without valid version identifier`);
          }
          let syncedDocument = this._syncedDocuments.get(td2.uri);
          if (syncedDocument !== void 0) {
            syncedDocument = this._configuration.update(syncedDocument, changes, version2);
            this._syncedDocuments.set(td2.uri, syncedDocument);
            this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onDidCloseTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._syncedDocuments.delete(event.textDocument.uri);
            this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocumentWaitUntil((event, token) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
          } else {
            return [];
          }
        }));
        disposables.push(connection2.onDidSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
    };
    exports2.TextDocuments = TextDocuments2;
  }
});

// node_modules/vscode-languageserver/lib/common/notebook.js
var require_notebook = __commonJS({
  "node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var textDocuments_1 = require_textDocuments();
    var NotebookSyncFeature = (Base) => {
      return class extends Base {
        get synchronization() {
          return {
            onDidOpenNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidChangeNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidSaveNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidCloseNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            }
          };
        }
      };
    };
    exports2.NotebookSyncFeature = NotebookSyncFeature;
    var CellTextDocumentConnection = class _CellTextDocumentConnection {
      onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.openHandler = void 0;
        });
      }
      openTextDocument(params) {
        this.openHandler && this.openHandler(params);
      }
      onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.changeHandler = handler;
        });
      }
      changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
      }
      onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.closeHandler = void 0;
        });
      }
      closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
      }
      onWillSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onWillSaveTextDocumentWaitUntil() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onDidSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
    };
    CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
    } });
    var NotebookDocuments = class {
      constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
          this._cellTextDocuments = configurationOrTextDocuments;
        } else {
          this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = /* @__PURE__ */ new Map();
        this.notebookCellMap = /* @__PURE__ */ new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
      }
      get cellTextDocuments() {
        return this._cellTextDocuments;
      }
      getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
      }
      getNotebookDocument(uri) {
        return this.notebookDocuments.get(uri);
      }
      getNotebookCell(uri) {
        const value = this.notebookCellMap.get(uri);
        return value && value[0];
      }
      findNotebookDocumentForCell(cell) {
        const key = typeof cell === "string" ? cell : cell.document;
        const value = this.notebookCellMap.get(key);
        return value && value[1];
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidChange() {
        return this._onDidChange.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the notebook documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
       *  and `onDidCloseNotebookDocument`.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection2.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
          this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
          }
          this.updateCellMap(params.notebookDocument);
          this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          notebookDocument.version = params.notebookDocument.version;
          const oldMetadata = notebookDocument.metadata;
          let metadataChanged = false;
          const change = params.change;
          if (change.metadata !== void 0) {
            metadataChanged = true;
            notebookDocument.metadata = change.metadata;
          }
          const opened = [];
          const closed = [];
          const data = [];
          const text = [];
          if (change.cells !== void 0) {
            const changedCells = change.cells;
            if (changedCells.structure !== void 0) {
              const array = changedCells.structure.array;
              notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
              if (changedCells.structure.didOpen !== void 0) {
                for (const open of changedCells.structure.didOpen) {
                  cellTextDocumentConnection.openTextDocument({ textDocument: open });
                  opened.push(open.uri);
                }
              }
              if (changedCells.structure.didClose) {
                for (const close of changedCells.structure.didClose) {
                  cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                  closed.push(close.uri);
                }
              }
            }
            if (changedCells.data !== void 0) {
              const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
              for (let i = 0; i <= notebookDocument.cells.length; i++) {
                const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                if (change2 !== void 0) {
                  const old = notebookDocument.cells.splice(i, 1, change2);
                  data.push({ old: old[0], new: change2 });
                  cellUpdates.delete(change2.document);
                  if (cellUpdates.size === 0) {
                    break;
                  }
                }
              }
            }
            if (changedCells.textContent !== void 0) {
              for (const cellTextDocument of changedCells.textContent) {
                cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                text.push(cellTextDocument.document.uri);
              }
            }
          }
          this.updateCellMap(notebookDocument);
          const changeEvent = { notebookDocument };
          if (metadataChanged) {
            changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
          }
          const added = [];
          for (const open of opened) {
            added.push(this.getNotebookCell(open));
          }
          const removed = [];
          for (const close of closed) {
            removed.push(this.getNotebookCell(close));
          }
          const textContent = [];
          for (const change2 of text) {
            textContent.push(this.getNotebookCell(change2));
          }
          if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
            changeEvent.cells = { added, removed, changed: { data, textContent } };
          }
          if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
            this._onDidChange.fire(changeEvent);
          }
        }));
        disposables.push(connection2.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidClose.fire(notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
          }
          this.notebookDocuments.delete(params.notebookDocument.uri);
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.delete(cell.document);
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
      updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
          this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
      }
    };
    exports2.NotebookDocuments = NotebookDocuments;
  }
});

// node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type2 = vscode_languageserver_protocol_1.MonikerRequest.type;
              return this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            }
          };
        }
      };
    };
    exports2.MonikerFeature = MonikerFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolder_1 = require_workspaceFolder();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var foldingRange_1 = require_foldingRange();
    var inlayHint_1 = require_inlayHint();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var moniker_1 = require_moniker();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Add a message to the tracker.
       *
       * @param message The message to add.
       */
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      /**
       * Send all tracked messages to the connection's window.
       *
       * @param connection The connection established between client and server.
       */
      sendErrors(connection2) {
        Object.keys(this._messages).forEach((message) => {
          connection2.window.showErrorMessage(message);
        });
      }
    };
    exports2.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection2) {
        this._rawConnection = connection2;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      debug(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
      }
      send(type2, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type: type2, message }).catch(() => {
            (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
          });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration || (exports2.BulkRegistration = BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type2, registerOptions) {
        const method = Is.string(type2) ? type2 : type2.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration || (exports2.BulkUnregistration = BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type2, registerOptions) {
        const method = Is.string(type2) ? type2 : type2.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type2, registerOptions) {
        const method = Is.string(type2) ? type2 : type2.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method).catch(() => {
              this.connection.console.info(`Un-registering capability with id ${id} failed.`);
            });
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        }).catch(() => {
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
          this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
    var _NotebooksImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._NotebooksImpl = _NotebooksImpl;
    var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineNotebooksFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineNotebooksFeatures = combineNotebooksFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
      };
      return result;
    }
    exports2.combineFeatures = combineFeatures;
    function createConnection2(connectionFactory, watchDog, factories) {
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection2 = connectionFactory(logger);
      logger.rawAttach(connection2);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is.thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection2.listen(),
        sendRequest: (type2, ...params) => connection2.sendRequest(Is.string(type2) ? type2 : type2.method, ...params),
        onRequest: (type2, handler) => connection2.onRequest(type2, handler),
        sendNotification: (type2, param) => {
          const method = Is.string(type2) ? type2 : type2.method;
          return connection2.sendNotification(method, param);
        },
        onNotification: (type2, handler) => connection2.onNotification(type2, handler),
        onProgress: connection2.onProgress,
        sendProgress: connection2.sendProgress,
        onInitialize: (handler) => {
          initializeHandler = handler;
          return {
            dispose: () => {
              initializeHandler = void 0;
            }
          };
        },
        onInitialized: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
          shutdownHandler = handler;
          return {
            dispose: () => {
              shutdownHandler = void 0;
            }
          };
        },
        onExit: (handler) => {
          exitHandler = handler;
          return {
            dispose: () => {
              exitHandler = void 0;
            }
          };
        },
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        get notebooks() {
          return notebooks;
        },
        onDidChangeConfiguration: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection2.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onCompletion: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCompletionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDeclaration: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onTypeDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onImplementation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onReferences: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentHighlight: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeActionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeLensResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onPrepareRename: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentLinkResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onColorPresentation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onFoldingRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onSelectionRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onExecuteCommand: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        dispose: () => connection2.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection2.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection2.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports2.createConnection = createConnection2;
  }
});

// node_modules/vscode-languageserver/lib/node/files.js
var require_files = __commonJS({
  "node_modules/vscode-languageserver/lib/node/files.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveModulePath = exports2.FileSystem = exports2.resolveGlobalYarnPath = exports2.resolveGlobalNodePath = exports2.resolve = exports2.uriToFilePath = void 0;
    var url = require("url");
    var path5 = require("path");
    var fs4 = require("fs");
    var child_process_1 = require("child_process");
    function uriToFilePath(uri) {
      let parsed = url.parse(uri);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        if (first.length === 0 && second.length > 1 && second[1] === ":") {
          segments.shift();
        }
      }
      return path5.normalize(segments.join("/"));
    }
    exports2.uriToFilePath = uriToFilePath;
    function isWindows() {
      return process.platform === "win32";
    }
    function resolve(moduleName, nodePath, cwd, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve2, reject) => {
        let env = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env).forEach((key) => newEnv[key] = env[key]);
        if (nodePath && fs4.existsSync(nodePath)) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path5.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ELECTRON_RUN_AS_NODE"] = "1";
        try {
          let cp = (0, child_process_1.fork)("", [], {
            cwd,
            env: newEnv,
            execArgv: ["-e", app]
          });
          if (cp.pid === void 0) {
            reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
            return;
          }
          cp.on("error", (error) => {
            reject(error);
          });
          cp.on("message", (message2) => {
            if (message2.c === "r") {
              cp.send({ c: "e" });
              if (message2.s) {
                resolve2(message2.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message = {
            c: "rs",
            a: moduleName
          };
          cp.send(message);
        } catch (error) {
          reject(error);
        }
      });
    }
    exports2.resolve = resolve;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = "npm";
      const env = /* @__PURE__ */ Object.create(null);
      Object.keys(process.env).forEach((key) => env[key] = process.env[key]);
      env["NO_UPDATE_NOTIFIER"] = "true";
      const options = {
        encoding: "utf8",
        env
      };
      if (isWindows()) {
        npmCommand = "npm.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let stdout = (0, child_process_1.spawnSync)(npmCommand, ["config", "get", "prefix"], options).stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'npm config get prefix' didn't return a value.`);
          }
          return void 0;
        }
        let prefix = stdout.trim();
        if (tracer) {
          tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
          if (isWindows()) {
            return path5.join(prefix, "node_modules");
          } else {
            return path5.join(prefix, "lib", "node_modules");
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = "yarn";
      let options = {
        encoding: "utf8"
      };
      if (isWindows()) {
        yarnCommand = "yarn.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let results = (0, child_process_1.spawnSync)(yarnCommand, ["global", "dir", "--json"], options);
        let stdout = results.stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'yarn global dir' didn't return a value.`);
            if (results.stderr) {
              tracer(results.stderr);
            }
          }
          return void 0;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
          try {
            let yarn = JSON.parse(line);
            if (yarn.type === "log") {
              return path5.join(yarn.data, "node_modules");
            }
          } catch (e) {
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs4.existsSync(__filename.toUpperCase()) || !fs4.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent2, child) {
        if (isCaseSensitive()) {
          return path5.normalize(child).indexOf(path5.normalize(parent2)) === 0;
        } else {
          return path5.normalize(child).toLowerCase().indexOf(path5.normalize(parent2).toLowerCase()) === 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem || (exports2.FileSystem = FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path5.isAbsolute(nodePath)) {
          nodePath = path5.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
          if (FileSystem.isParent(nodePath, value)) {
            return value;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports2.resolveModulePath = resolveModulePath;
  }
});

// node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js
var require_inlineCompletion_proposed = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineCompletionFeature = (Base) => {
      return class extends Base {
        get inlineCompletion() {
          return {
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineCompletionFeature = InlineCompletionFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
      return semanticTokens_1.SemanticTokensBuilder;
    } });
    var ic = require_inlineCompletion_proposed();
    __exportStar(require_main3(), exports2);
    var textDocuments_1 = require_textDocuments();
    Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
      return textDocuments_1.TextDocuments;
    } });
    var notebook_1 = require_notebook();
    Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
      return notebook_1.NotebookDocuments;
    } });
    __exportStar(require_server(), exports2);
    var ProposedFeatures2;
    (function(ProposedFeatures3) {
      ProposedFeatures3.all = {
        __brand: "features",
        languages: ic.InlineCompletionFeature
      };
    })(ProposedFeatures2 || (exports2.ProposedFeatures = ProposedFeatures2 = {}));
  }
});

// node_modules/vscode-languageserver/lib/node/main.js
var require_main4 = __commonJS({
  "node_modules/vscode-languageserver/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.Files = void 0;
    var node_util_1 = require("node:util");
    var Is = require_is();
    var server_1 = require_server();
    var fm = require_files();
    var node_1 = require_node2();
    __exportStar(require_node2(), exports2);
    __exportStar(require_api3(), exports2);
    var Files2;
    (function(Files3) {
      Files3.uriToFilePath = fm.uriToFilePath;
      Files3.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files3.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files3.resolve = fm.resolve;
      Files3.resolveModulePath = fm.resolveModulePath;
    })(Files2 || (exports2.Files = Files2 = {}));
    var _protocolConnection;
    function endProtocolConnection() {
      if (_protocolConnection === void 0) {
        return;
      }
      try {
        _protocolConnection.end();
      } catch (_err) {
      }
    }
    var _shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value) {
        try {
          let processId = parseInt(value);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                endProtocolConnection();
                process.exit(_shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    var watchDog = {
      initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              process.exit(_shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value) {
        _shutdownReceived = value;
      },
      exit: (code) => {
        endProtocolConnection();
        process.exit(code);
      }
    };
    function createConnection2(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        input = arg1;
        output = arg2;
        options = arg3;
      }
      return _createConnection(input, output, options, factories);
    }
    exports2.createConnection = createConnection2;
    function _createConnection(input, output, options, factories) {
      let stdio = false;
      if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
          let arg = argv[i];
          if (arg === "--node-ipc") {
            input = new node_1.IPCMessageReader(process);
            output = new node_1.IPCMessageWriter(process);
            break;
          } else if (arg === "--stdio") {
            stdio = true;
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port = parseInt(argv[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port) {
          let transport = (0, node_1.createServerSocketTransport)(port);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = (0, node_1.createServerPipeTransport)(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
      }
      const connectionFactory = (logger) => {
        const result = (0, node_1.createProtocolConnection)(input, output, logger, options);
        if (stdio) {
          patchConsole(logger);
        }
        return result;
      };
      return (0, server_1.createConnection)(connectionFactory, watchDog, factories);
    }
    function patchConsole(logger) {
      function serialize(args) {
        return args.map((arg) => typeof arg === "string" ? arg : (0, node_util_1.inspect)(arg)).join(" ");
      }
      const counters = /* @__PURE__ */ new Map();
      console.assert = function assert(assertion, ...args) {
        if (assertion) {
          return;
        }
        if (args.length === 0) {
          logger.error("Assertion failed");
        } else {
          const [message, ...rest] = args;
          logger.error(`Assertion failed: ${message} ${serialize(rest)}`);
        }
      };
      console.count = function count(label = "default") {
        const message = String(label);
        let counter2 = counters.get(message) ?? 0;
        counter2 += 1;
        counters.set(message, counter2);
        logger.log(`${message}: ${message}`);
      };
      console.countReset = function countReset(label) {
        if (label === void 0) {
          counters.clear();
        } else {
          counters.delete(String(label));
        }
      };
      console.debug = function debug(...args) {
        logger.log(serialize(args));
      };
      console.dir = function dir(arg, options) {
        logger.log((0, node_util_1.inspect)(arg, options));
      };
      console.log = function log(...args) {
        logger.log(serialize(args));
      };
      console.error = function error(...args) {
        logger.error(serialize(args));
      };
      console.trace = function trace2(...args) {
        const stack = new Error().stack.replace(/(.+\n){2}/, "");
        let message = "Trace";
        if (args.length !== 0) {
          message += `: ${serialize(args)}`;
        }
        logger.log(`${message}
${stack}`);
      };
      console.warn = function warn(...args) {
        logger.warn(serialize(args));
      };
    }
  }
});

// node_modules/vscode-languageserver/node.js
var require_node3 = __commonJS({
  "node_modules/vscode-languageserver/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main4();
  }
});

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports2.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate2(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate2(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify2(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify2;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent: parent2 } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent2;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not2(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not2(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not2;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it, schema2) {
      if (typeof schema2 == "boolean")
        return schema2;
      if (Object.keys(schema2).length === 0)
        return true;
      checkUnknownRules(it, schema2);
      return !schemaHasRules(schema2, it.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema2 = it.schema) {
      const { opts, self } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema2 === "boolean")
        return;
      const rules = self.RULES.keywords;
      for (const key in schema2) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema2, rules) {
      if (typeof schema2 == "boolean")
        return !schema2;
      for (const key in schema2)
        if (rules[key])
          return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema2, RULES) {
      if (typeof schema2 == "boolean")
        return !schema2;
      for (const key in schema2)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema2, keyword, $data) {
      if (!$data) {
        if (typeof schema2 == "number" || typeof schema2 == "boolean")
          return schema2;
        if (typeof schema2 == "string")
          return (0, codegen_1._)`${schema2}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports2.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports2.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports2.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema: schema2, validateName } = it;
      if (schema2 === false) {
        falseSchemaError(it, false);
      } else if (typeof schema2 == "object" && schema2.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema: schema2 } = it;
      if (schema2 === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema: schema2, self }, type2) {
      const group = self.RULES.types[type2];
      return group && group !== true && shouldUseGroup(schema2, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema2, group) {
      return group.rules.some((rule) => shouldUseRule(schema2, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema2, rule) {
      var _a;
      return schema2[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema2[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports2.DataType = DataType = {}));
    function getSchemaTypes(schema2) {
      const types4 = getJSONTypes(schema2.type);
      const hasNull = types4.includes("null");
      if (hasNull) {
        if (schema2.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types4.length && schema2.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema2.nullable === true)
          types4.push("null");
      }
      return types4;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types4 = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types4.every(rules_1.isJSONType))
        return types4;
      throw new Error("type must be JSONType or JSONType[]: " + types4.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types4) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types4, opts.coerceTypes);
      const checkTypes = types4.length > 0 && !(coerceTo.length === 0 && types4.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types4[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types4, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types4, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types4, coerceTypes) {
      return coerceTypes ? types4.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types4, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types4, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types4 = (0, util_1.toHash)(dataTypes);
      if (types4.array && types4.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types4.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types4.null;
        delete types4.array;
        delete types4.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types4.number)
        delete types4.integer;
      for (const t in types4)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema: schema2 }) => `must be ${schema2}`,
      params: ({ schema: schema2, schemaValue }) => typeof schema2 == "string" ? (0, codegen_1._)`{type: ${schema2}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema: schema2 } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema2, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema2.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema2,
        params: {},
        it
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties: properties2, items } = it.schema;
      if (ty === "object" && properties2) {
        for (const key in properties2) {
          assignDefault(it, key, properties2[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue2) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue2 === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue2)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
      return (0, codegen_1.or)(...properties2.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema: schema2, keyword, it } = cxt;
      if (!Array.isArray(schema2))
        throw new Error("ajv implementation error");
      const alwaysValid = schema2.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema2.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports2.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema: schema2, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema2, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema: schema2, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema2, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema2, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema2) : st === "object" ? schema2 && typeof schema2 == "object" && !Array.isArray(schema2) : typeof schema2 == st || allowUndefined && typeof schema2 == "undefined");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema: schema2, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema2, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema2[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema: schema2, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema2 !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema2 !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema: schema2,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema2, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema2, "", schema2);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema2 && typeof schema2 == "object" && !Array.isArray(schema2)) {
        pre(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema2) {
          var sch = schema2[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema2, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema2, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema2);
          }
        }
        post(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema2, limit = true) {
      if (typeof schema2 == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema2);
      if (!limit)
        return false;
      return countKeys(schema2) <= limit;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema2) {
      for (const key in schema2) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema2[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema2) {
      let count = 0;
      for (const key in schema2) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema2[key] == "object") {
          (0, util_1.eachItem)(schema2[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver2, id = "", normalize2) {
      if (normalize2 !== false)
        id = normalizeId(id);
      const p = resolver2.parse(id);
      return _getFullPath(resolver2, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver2, p) {
      const serialized = resolver2.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver2, baseId, id) {
      id = normalizeId(id);
      return resolver2.resolve(baseId, id);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema2, baseId) {
      if (typeof schema2 == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema2[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema2, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema: schema2, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema2, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema2, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema: schema2, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema2.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema2, opts) {
      const schId = typeof schema2 == "object" && schema2[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema: schema2, self }) {
      if (typeof schema2 == "boolean")
        return !schema2;
      for (const key in schema2)
        if (self.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema: schema2, gen, opts } = it;
      if (opts.$comment && schema2.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types4 = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types4);
      schemaKeywords(it, types4, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema: schema2, errSchemaPath, opts, self } = it;
      if (schema2.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema2, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema: schema2, opts } = it;
      if (schema2.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema: schema2, errSchemaPath, opts }) {
      const msg = schema2.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types4, typeErrors, errsCount) {
      const { gen, schema: schema2, data, allErrors, opts, self } = it;
      const { RULES } = self;
      if (schema2.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema2, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types4);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema2, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types4.length === 1 && types4[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema: schema2, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema2, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types4) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types4);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types4);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types4) {
      if (!types4.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types4;
        return;
      }
      types4.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types4);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type: type2 } = rule.definition;
          if (type2.length && !type2.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver2, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver2, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver2, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema2;
        if (typeof env.schema == "object")
          schema2 = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema2 === null || schema2 === void 0 ? void 0 : schema2[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema2 === null || schema2 === void 0 ? void 0 : schema2.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema2 = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema2)
          _sch = new SchemaEnv({ schema: schema2, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema: schema2 } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema2[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema: schema2, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema: schema2, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema2 === "boolean")
          return;
        const partSchema = schema2[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema2 = partSchema;
        const schId = typeof schema2 === "object" && schema2[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema2 != "boolean" && schema2.$ref && !(0, util_1.schemaHasRulesButRef)(schema2, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema2.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema: schema2, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/scopedChars.js
var require_scopedChars = __commonJS({
  "node_modules/fast-uri/lib/scopedChars.js"(exports2, module2) {
    "use strict";
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    module2.exports = {
      HEX
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports2, module2) {
    "use strict";
    var { HEX } = require_scopedChars();
    var IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches = host.match(IPV4_REG) || [];
      const [address] = matches;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c of input) {
        if (HEX[c] === void 0) return void 0;
        if (c !== "0" && strip === true) strip = false;
        if (!strip) acc += c;
      }
      if (keepZero && acc.length === 0) acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer.length) {
          if (isZone === false) {
            const hex = stringArrayToHexStripped(buffer);
            if (hex !== void 0) {
              address.push(hex);
            } else {
              output.error = true;
              return false;
            }
          }
          buffer.length = 0;
        }
        return true;
      }
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i - 1 >= 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (isZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip = true;
      const l = str.length;
      for (let i = 0; i < l; i++) {
        const c = str[i];
        if (c === "0" && skip) {
          if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
            out += c;
            skip = false;
          }
        } else {
          if (c === token) {
            skip = true;
          } else {
            skip = false;
          }
          out += c;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    var RDS1 = /^\.\.?\//u;
    var RDS2 = /^\/\.(?:\/|$)/u;
    var RDS3 = /^\/\.\.(?:\/|$)/u;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module2.exports = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports2, module2) {
    "use strict";
    var UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path5, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path5 && path5 !== "/" ? path5 : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches = urnComponents.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase();
        urnComponents.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    var http = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    var https = {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    var ws = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    var wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    };
    var urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    var urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    var SCHEMES = {
      http,
      https,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    module2.exports = SCHEMES;
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports2, module2) {
    "use strict";
    var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils();
    var SCHEMES = require_schemes();
    function normalize2(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse3(uri, options), options);
      } else if (typeof uri === "object") {
        uri = parse3(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse3(baseURI, schemelessOptions), parse3(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, { ...schemelessOptions, skipEscape: true });
    }
    function resolveComponents(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse3(serialize(base, options), options);
        relative = parse3(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse3(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse3(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme, ":");
      }
      const authority = recomposeAuthority(components);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?", components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#", components.fragment);
      }
      return uriTokens.join("");
    }
    var hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code = 0;
      for (let i = 0, len = value.length; i < len; ++i) {
        code = value.charCodeAt(i);
        if (code > 126 || hexLookUp[code]) {
          return true;
        }
      }
      return false;
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse3(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix") uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize: normalize2,
      resolve,
      resolveComponents,
      equal,
      serialize,
      parse: parse3
    };
    module2.exports = fastUri;
    module2.exports.default = fastUri;
    module2.exports.fastUri = fastUri;
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema2, _meta) {
        const sch = this._addSchema(schema2, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema2, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema2, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema2, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema2)) {
          for (const sch of schema2)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema2 === "object") {
          const { schemaId } = this.opts;
          id = schema2[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema2, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema2, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema2, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema2, throwOrLogError) {
        if (typeof schema2 == "boolean")
          return true;
        let $schema2;
        $schema2 = schema2.$schema;
        if ($schema2 !== void 0 && typeof $schema2 != "string") {
          throw new Error("$schema must be a string");
        }
        $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema2) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema2, schema2);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey2 = schemaKeyRef;
            this._cache.delete(cacheKey2);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions2) {
        for (const def of definitions2)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format2) {
        if (typeof format2 == "string")
          format2 = new RegExp(format2);
        this.formats[name] = format2;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema2 = keywords[key];
            if ($data && schema2)
              keywords[key] = schemaOrData(schema2);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema2, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema2 == "object") {
          id = schema2[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema2 != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema2);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema2, baseId);
        sch = new compile_1.SchemaEnv({ schema: schema2, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema2, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports2.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format2 = this.opts.formats[name];
        if (format2)
          this.addFormat(name, format2);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema2) {
      return { anyOf: [schema2, $dataRef] };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports2.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema: schema2, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema2);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema: schema2, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema2.length === 0)
          return;
        const useLoop = schema2.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema2) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema2) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema2, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema: schema2, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema2)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema: schema2 } = cxt;
        if ($data || schema2 && typeof schema2 == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema2} !== ${data}`);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
        if (!$data && schema2.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema2.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema2))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema2.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema2[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema: schema2, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema2 === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema2 == "object" && !(0, util_1.alwaysValidSchema)(it, schema2)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema: schema2, it } = cxt;
        if (Array.isArray(schema2))
          return validateTuple(cxt, "additionalItems", schema2);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema2))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema: schema2, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema2))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema: schema2, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema2)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema: schema2 }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema2) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema2[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema2[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema: schema2, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema2))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema: schema2, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema2))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema2 === false) {
            deleteAdditional(key);
            return;
          }
          if (schema2 === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema2 == "object" && !(0, util_1.alwaysValidSchema)(it, schema2)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema: schema2, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema2);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties2 = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema2[p]));
        if (properties2.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties2) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema2[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema: schema2, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema2);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema2[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema: schema2, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema2)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema: schema2, parentSchema, it } = cxt;
        if (!Array.isArray(schema2))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema2;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema: schema2, it } = cxt;
        if (!Array.isArray(schema2))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema2.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema2 = it.schema[keyword];
      return schema2 !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema2);
    }
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format2 = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format2}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1._)`${format2}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
            return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self.formats[schema2];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format2, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema2}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema2)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema2, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var format_1 = require_format();
    var format2 = [format_1.default];
    exports2.default = format2;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports2.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports2.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema: schema2, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema2.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema2.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping2 = getMapping();
          gen.if(false);
          for (const tagValue in mapping2) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping2[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports2.Ajv = Ajv2;
    module2.exports = exports2 = Ajv2;
    module2.exports.Ajv = Ajv2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric2 = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric2.test(a);
      const bnum = numeric2.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof _SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match2 = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match2 || match2[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse3 = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse3;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse3 = require_parse();
    var valid = (version2, options) => {
      const v = parse3(version2, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse3 = require_parse();
    var clean = (version2, options) => {
      const s = parse3(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse3 = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse3(version1, null, true);
      const v2 = parse3(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse3 = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse3(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq2 = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq2;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte2 = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte2;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte2 = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte2;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq2 = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte2 = require_gte();
    var lt = require_lt();
    var lte2 = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq2(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte2(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte2(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse3 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match2 = null;
      if (!options.rtl) {
        match2 = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version2)) && (!match2 || match2.index + match2[0].length !== version2.length)) {
          if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
            match2 = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match2 === null) {
        return null;
      }
      const major = match2[2];
      const minor = match2[3] || "0";
      const patch = match2[4] || "0";
      const prerelease = options.includePrerelease && match2[5] ? `-${match2[5]}` : "";
      const build = options.includePrerelease && match2[6] ? `+${match2[6]}` : "";
      return parse3(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    var LRUCache2 = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache2;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range2, options) {
        options = parseOptions(options);
        if (range2 instanceof _Range) {
          if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
            return range2;
          } else {
            return new _Range(range2.raw, options);
          }
        }
        if (range2 instanceof Comparator) {
          this.raw = range2.value;
          this.set = [[range2]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range2) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range2;
        const cached = cache2.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range2);
        range2 = range2.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range2);
        range2 = range2.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range2);
        range2 = range2.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range2);
        let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache2.set(memoKey, result);
        return result;
      }
      intersects(range2, options) {
        if (!(range2 instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache2 = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var satisfies2 = (version2, range2, options) => {
      try {
        range2 = new Range(range2, options);
      } catch (er) {
        return false;
      }
      return range2.test(version2);
    };
    module2.exports = satisfies2;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range2, options) => new Range(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range2, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range2, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range2, loose) => {
      range2 = new Range(range2, loose);
      let minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range2.set.length; ++i) {
        const comparators = range2.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range2, options) => {
      try {
        return new Range(range2, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies2 = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte2 = require_lte();
    var gte2 = require_gte();
    var outside = (version2, range2, hilo, options) => {
      version2 = new SemVer(version2, options);
      range2 = new Range(range2, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte2;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte2;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies2(version2, range2, options)) {
        return false;
      }
      for (let i = 0; i < range2.set.length; ++i) {
        const comparators = range2.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version2, range2, options) => outside(version2, range2, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version2, range2, options) => outside(version2, range2, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies2 = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range2, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies2(version2, range2, options);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range2.raw === "string" ? range2.raw : String(range2);
      return simplified.length < original.length ? simplified : range2;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies2 = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq2 of eqSet) {
        if (gt && !satisfies2(eq2, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies2(eq2, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies2(eq2, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies2(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies2(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse3 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq2 = require_eq();
    var neq = require_neq();
    var gte2 = require_gte();
    var lte2 = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies2 = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse3,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq: eq2,
      neq,
      gte: gte2,
      lte: lte2,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies: satisfies2,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/prompts/node_modules/kleur/index.js
var require_kleur = __commonJS({
  "node_modules/prompts/node_modules/kleur/index.js"(exports2, module2) {
    "use strict";
    var { FORCE_COLOR: FORCE_COLOR3, NODE_DISABLE_COLORS: NODE_DISABLE_COLORS3, TERM: TERM3 } = process.env;
    var $3 = {
      enabled: !NODE_DISABLE_COLORS3 && TERM3 !== "dumb" && FORCE_COLOR3 !== "0",
      // modifiers
      reset: init3(0, 0),
      bold: init3(1, 22),
      dim: init3(2, 22),
      italic: init3(3, 23),
      underline: init3(4, 24),
      inverse: init3(7, 27),
      hidden: init3(8, 28),
      strikethrough: init3(9, 29),
      // colors
      black: init3(30, 39),
      red: init3(31, 39),
      green: init3(32, 39),
      yellow: init3(33, 39),
      blue: init3(34, 39),
      magenta: init3(35, 39),
      cyan: init3(36, 39),
      white: init3(37, 39),
      gray: init3(90, 39),
      grey: init3(90, 39),
      // background colors
      bgBlack: init3(40, 49),
      bgRed: init3(41, 49),
      bgGreen: init3(42, 49),
      bgYellow: init3(43, 49),
      bgBlue: init3(44, 49),
      bgMagenta: init3(45, 49),
      bgCyan: init3(46, 49),
      bgWhite: init3(47, 49)
    };
    function run2(arr, str) {
      let i = 0, tmp, beg = "", end = "";
      for (; i < arr.length; i++) {
        tmp = arr[i];
        beg += tmp.open;
        end += tmp.close;
        if (str.includes(tmp.close)) {
          str = str.replace(tmp.rgx, tmp.close + tmp.open);
        }
      }
      return beg + str + end;
    }
    function chain2(has, keys) {
      let ctx = { has, keys };
      ctx.reset = $3.reset.bind(ctx);
      ctx.bold = $3.bold.bind(ctx);
      ctx.dim = $3.dim.bind(ctx);
      ctx.italic = $3.italic.bind(ctx);
      ctx.underline = $3.underline.bind(ctx);
      ctx.inverse = $3.inverse.bind(ctx);
      ctx.hidden = $3.hidden.bind(ctx);
      ctx.strikethrough = $3.strikethrough.bind(ctx);
      ctx.black = $3.black.bind(ctx);
      ctx.red = $3.red.bind(ctx);
      ctx.green = $3.green.bind(ctx);
      ctx.yellow = $3.yellow.bind(ctx);
      ctx.blue = $3.blue.bind(ctx);
      ctx.magenta = $3.magenta.bind(ctx);
      ctx.cyan = $3.cyan.bind(ctx);
      ctx.white = $3.white.bind(ctx);
      ctx.gray = $3.gray.bind(ctx);
      ctx.grey = $3.grey.bind(ctx);
      ctx.bgBlack = $3.bgBlack.bind(ctx);
      ctx.bgRed = $3.bgRed.bind(ctx);
      ctx.bgGreen = $3.bgGreen.bind(ctx);
      ctx.bgYellow = $3.bgYellow.bind(ctx);
      ctx.bgBlue = $3.bgBlue.bind(ctx);
      ctx.bgMagenta = $3.bgMagenta.bind(ctx);
      ctx.bgCyan = $3.bgCyan.bind(ctx);
      ctx.bgWhite = $3.bgWhite.bind(ctx);
      return ctx;
    }
    function init3(open, close) {
      let blk = {
        open: `\x1B[${open}m`,
        close: `\x1B[${close}m`,
        rgx: new RegExp(`\\x1b\\[${close}m`, "g")
      };
      return function(txt) {
        if (this !== void 0 && this.has !== void 0) {
          this.has.includes(open) || (this.has.push(open), this.keys.push(blk));
          return txt === void 0 ? this : $3.enabled ? run2(this.keys, txt + "") : txt + "";
        }
        return txt === void 0 ? chain2([open], [blk]) : $3.enabled ? run2([blk], txt + "") : txt + "";
      };
    }
    module2.exports = $3;
  }
});

// node_modules/prompts/dist/util/action.js
var require_action = __commonJS({
  "node_modules/prompts/dist/util/action.js"(exports2, module2) {
    "use strict";
    module2.exports = (key, isSelect) => {
      if (key.meta && key.name !== "escape") return;
      if (key.ctrl) {
        if (key.name === "a") return "first";
        if (key.name === "c") return "abort";
        if (key.name === "d") return "abort";
        if (key.name === "e") return "last";
        if (key.name === "g") return "reset";
      }
      if (isSelect) {
        if (key.name === "j") return "down";
        if (key.name === "k") return "up";
      }
      if (key.name === "return") return "submit";
      if (key.name === "enter") return "submit";
      if (key.name === "backspace") return "delete";
      if (key.name === "delete") return "deleteForward";
      if (key.name === "abort") return "abort";
      if (key.name === "escape") return "exit";
      if (key.name === "tab") return "next";
      if (key.name === "pagedown") return "nextPage";
      if (key.name === "pageup") return "prevPage";
      if (key.name === "home") return "home";
      if (key.name === "end") return "end";
      if (key.name === "up") return "up";
      if (key.name === "down") return "down";
      if (key.name === "right") return "right";
      if (key.name === "left") return "left";
      return false;
    };
  }
});

// node_modules/prompts/dist/util/strip.js
var require_strip = __commonJS({
  "node_modules/prompts/dist/util/strip.js"(exports2, module2) {
    "use strict";
    module2.exports = (str) => {
      const pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|");
      const RGX = new RegExp(pattern, "g");
      return typeof str === "string" ? str.replace(RGX, "") : str;
    };
  }
});

// node_modules/sisteransi/src/index.js
var require_src = __commonJS({
  "node_modules/sisteransi/src/index.js"(exports2, module2) {
    "use strict";
    var ESC = "\x1B";
    var CSI = `${ESC}[`;
    var beep = "\x07";
    var cursor = {
      to(x, y) {
        if (!y) return `${CSI}${x + 1}G`;
        return `${CSI}${y + 1};${x + 1}H`;
      },
      move(x, y) {
        let ret = "";
        if (x < 0) ret += `${CSI}${-x}D`;
        else if (x > 0) ret += `${CSI}${x}C`;
        if (y < 0) ret += `${CSI}${-y}A`;
        else if (y > 0) ret += `${CSI}${y}B`;
        return ret;
      },
      up: (count = 1) => `${CSI}${count}A`,
      down: (count = 1) => `${CSI}${count}B`,
      forward: (count = 1) => `${CSI}${count}C`,
      backward: (count = 1) => `${CSI}${count}D`,
      nextLine: (count = 1) => `${CSI}E`.repeat(count),
      prevLine: (count = 1) => `${CSI}F`.repeat(count),
      left: `${CSI}G`,
      hide: `${CSI}?25l`,
      show: `${CSI}?25h`,
      save: `${ESC}7`,
      restore: `${ESC}8`
    };
    var scroll = {
      up: (count = 1) => `${CSI}S`.repeat(count),
      down: (count = 1) => `${CSI}T`.repeat(count)
    };
    var erase = {
      screen: `${CSI}2J`,
      up: (count = 1) => `${CSI}1J`.repeat(count),
      down: (count = 1) => `${CSI}J`.repeat(count),
      line: `${CSI}2K`,
      lineEnd: `${CSI}K`,
      lineStart: `${CSI}1K`,
      lines(count) {
        let clear = "";
        for (let i = 0; i < count; i++)
          clear += this.line + (i < count - 1 ? cursor.up() : "");
        if (count)
          clear += cursor.left;
        return clear;
      }
    };
    module2.exports = { cursor, scroll, erase, beep };
  }
});

// node_modules/prompts/dist/util/clear.js
var require_clear = __commonJS({
  "node_modules/prompts/dist/util/clear.js"(exports2, module2) {
    "use strict";
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    var strip = require_strip();
    var _require = require_src();
    var erase = _require.erase;
    var cursor = _require.cursor;
    var width = (str) => [...strip(str)].length;
    module2.exports = function(prompt, perLine) {
      if (!perLine) return erase.line + cursor.to(0);
      let rows = 0;
      const lines = prompt.split(/\r?\n/);
      var _iterator = _createForOfIteratorHelper(lines), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          let line = _step.value;
          rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return erase.lines(rows);
    };
  }
});

// node_modules/prompts/dist/util/figures.js
var require_figures = __commonJS({
  "node_modules/prompts/dist/util/figures.js"(exports2, module2) {
    "use strict";
    var main = {
      arrowUp: "\u2191",
      arrowDown: "\u2193",
      arrowLeft: "\u2190",
      arrowRight: "\u2192",
      radioOn: "\u25C9",
      radioOff: "\u25EF",
      tick: "\u2714",
      cross: "\u2716",
      ellipsis: "\u2026",
      pointerSmall: "\u203A",
      line: "\u2500",
      pointer: "\u276F"
    };
    var win = {
      arrowUp: main.arrowUp,
      arrowDown: main.arrowDown,
      arrowLeft: main.arrowLeft,
      arrowRight: main.arrowRight,
      radioOn: "(*)",
      radioOff: "( )",
      tick: "\u221A",
      cross: "\xD7",
      ellipsis: "...",
      pointerSmall: "\xBB",
      line: "\u2500",
      pointer: ">"
    };
    var figures = process.platform === "win32" ? win : main;
    module2.exports = figures;
  }
});

// node_modules/prompts/dist/util/style.js
var require_style = __commonJS({
  "node_modules/prompts/dist/util/style.js"(exports2, module2) {
    "use strict";
    var c = require_kleur();
    var figures = require_figures();
    var styles = Object.freeze({
      password: {
        scale: 1,
        render: (input) => "*".repeat(input.length)
      },
      emoji: {
        scale: 2,
        render: (input) => "\u{1F603}".repeat(input.length)
      },
      invisible: {
        scale: 0,
        render: (input) => ""
      },
      default: {
        scale: 1,
        render: (input) => `${input}`
      }
    });
    var render = (type2) => styles[type2] || styles.default;
    var symbols = Object.freeze({
      aborted: c.red(figures.cross),
      done: c.green(figures.tick),
      exited: c.yellow(figures.cross),
      default: c.cyan("?")
    });
    var symbol = (done, aborted, exited) => aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols.default;
    var delimiter = (completing) => c.gray(completing ? figures.ellipsis : figures.pointerSmall);
    var item = (expandable, expanded) => c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
    module2.exports = {
      styles,
      render,
      symbols,
      symbol,
      delimiter,
      item
    };
  }
});

// node_modules/prompts/dist/util/lines.js
var require_lines = __commonJS({
  "node_modules/prompts/dist/util/lines.js"(exports2, module2) {
    "use strict";
    var strip = require_strip();
    module2.exports = function(msg, perLine) {
      let lines = String(strip(msg) || "").split(/\r?\n/);
      if (!perLine) return lines.length;
      return lines.map((l) => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
    };
  }
});

// node_modules/prompts/dist/util/wrap.js
var require_wrap = __commonJS({
  "node_modules/prompts/dist/util/wrap.js"(exports2, module2) {
    "use strict";
    module2.exports = (msg, opts = {}) => {
      const tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(" ").join("") : opts.margin || "";
      const width = opts.width;
      return (msg || "").split(/\r?\n/g).map((line) => line.split(/\s+/g).reduce((arr, w) => {
        if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width) arr[arr.length - 1] += ` ${w}`;
        else arr.push(`${tab}${w}`);
        return arr;
      }, [tab]).join("\n")).join("\n");
    };
  }
});

// node_modules/prompts/dist/util/entriesToDisplay.js
var require_entriesToDisplay = __commonJS({
  "node_modules/prompts/dist/util/entriesToDisplay.js"(exports2, module2) {
    "use strict";
    module2.exports = (cursor, total, maxVisible) => {
      maxVisible = maxVisible || total;
      let startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
      if (startIndex < 0) startIndex = 0;
      let endIndex = Math.min(startIndex + maxVisible, total);
      return {
        startIndex,
        endIndex
      };
    };
  }
});

// node_modules/prompts/dist/util/index.js
var require_util2 = __commonJS({
  "node_modules/prompts/dist/util/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      action: require_action(),
      clear: require_clear(),
      style: require_style(),
      strip: require_strip(),
      figures: require_figures(),
      lines: require_lines(),
      wrap: require_wrap(),
      entriesToDisplay: require_entriesToDisplay()
    };
  }
});

// node_modules/prompts/dist/elements/prompt.js
var require_prompt = __commonJS({
  "node_modules/prompts/dist/elements/prompt.js"(exports2, module2) {
    "use strict";
    var readline = require("readline");
    var _require = require_util2();
    var action = _require.action;
    var EventEmitter2 = require("events");
    var _require2 = require_src();
    var beep = _require2.beep;
    var cursor = _require2.cursor;
    var color = require_kleur();
    var Prompt = class extends EventEmitter2 {
      constructor(opts = {}) {
        super();
        this.firstRender = true;
        this.in = opts.stdin || process.stdin;
        this.out = opts.stdout || process.stdout;
        this.onRender = (opts.onRender || (() => void 0)).bind(this);
        const rl = readline.createInterface({
          input: this.in,
          escapeCodeTimeout: 50
        });
        readline.emitKeypressEvents(this.in, rl);
        if (this.in.isTTY) this.in.setRawMode(true);
        const isSelect = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1;
        const keypress = (str, key) => {
          let a = action(key, isSelect);
          if (a === false) {
            this._ && this._(str, key);
          } else if (typeof this[a] === "function") {
            this[a](key);
          } else {
            this.bell();
          }
        };
        this.close = () => {
          this.out.write(cursor.show);
          this.in.removeListener("keypress", keypress);
          if (this.in.isTTY) this.in.setRawMode(false);
          rl.close();
          this.emit(this.aborted ? "abort" : this.exited ? "exit" : "submit", this.value);
          this.closed = true;
        };
        this.in.on("keypress", keypress);
      }
      fire() {
        this.emit("state", {
          value: this.value,
          aborted: !!this.aborted,
          exited: !!this.exited
        });
      }
      bell() {
        this.out.write(beep);
      }
      render() {
        this.onRender(color);
        if (this.firstRender) this.firstRender = false;
      }
    };
    module2.exports = Prompt;
  }
});

// node_modules/prompts/dist/elements/text.js
var require_text = __commonJS({
  "node_modules/prompts/dist/elements/text.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_src();
    var erase = _require.erase;
    var cursor = _require.cursor;
    var _require2 = require_util2();
    var style = _require2.style;
    var clear = _require2.clear;
    var lines = _require2.lines;
    var figures = _require2.figures;
    var TextPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.transform = style.render(opts.style);
        this.scale = this.transform.scale;
        this.msg = opts.message;
        this.initial = opts.initial || ``;
        this.validator = opts.validate || (() => true);
        this.value = ``;
        this.errorMsg = opts.error || `Please Enter A Valid Value`;
        this.cursor = Number(!!this.initial);
        this.cursorOffset = 0;
        this.clear = clear(``, this.out.columns);
        this.render();
      }
      set value(v) {
        if (!v && this.initial) {
          this.placeholder = true;
          this.rendered = color.gray(this.transform.render(this.initial));
        } else {
          this.placeholder = false;
          this.rendered = this.transform.render(v);
        }
        this._value = v;
        this.fire();
      }
      get value() {
        return this._value;
      }
      reset() {
        this.value = ``;
        this.cursor = Number(!!this.initial);
        this.cursorOffset = 0;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.value = this.value || this.initial;
        this.done = this.aborted = true;
        this.error = false;
        this.red = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      validate() {
        var _this = this;
        return _asyncToGenerator(function* () {
          let valid = yield _this.validator(_this.value);
          if (typeof valid === `string`) {
            _this.errorMsg = valid;
            valid = false;
          }
          _this.error = !valid;
        })();
      }
      submit() {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          _this2.value = _this2.value || _this2.initial;
          _this2.cursorOffset = 0;
          _this2.cursor = _this2.rendered.length;
          yield _this2.validate();
          if (_this2.error) {
            _this2.red = true;
            _this2.fire();
            _this2.render();
            return;
          }
          _this2.done = true;
          _this2.aborted = false;
          _this2.fire();
          _this2.render();
          _this2.out.write("\n");
          _this2.close();
        })();
      }
      next() {
        if (!this.placeholder) return this.bell();
        this.value = this.initial;
        this.cursor = this.rendered.length;
        this.fire();
        this.render();
      }
      moveCursor(n) {
        if (this.placeholder) return;
        this.cursor = this.cursor + n;
        this.cursorOffset += n;
      }
      _(c, key) {
        let s1 = this.value.slice(0, this.cursor);
        let s2 = this.value.slice(this.cursor);
        this.value = `${s1}${c}${s2}`;
        this.red = false;
        this.cursor = this.placeholder ? 0 : s1.length + 1;
        this.render();
      }
      delete() {
        if (this.isCursorAtStart()) return this.bell();
        let s1 = this.value.slice(0, this.cursor - 1);
        let s2 = this.value.slice(this.cursor);
        this.value = `${s1}${s2}`;
        this.red = false;
        if (this.isCursorAtStart()) {
          this.cursorOffset = 0;
        } else {
          this.cursorOffset++;
          this.moveCursor(-1);
        }
        this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
        let s1 = this.value.slice(0, this.cursor);
        let s2 = this.value.slice(this.cursor + 1);
        this.value = `${s1}${s2}`;
        this.red = false;
        if (this.isCursorAtEnd()) {
          this.cursorOffset = 0;
        } else {
          this.cursorOffset++;
        }
        this.render();
      }
      first() {
        this.cursor = 0;
        this.render();
      }
      last() {
        this.cursor = this.value.length;
        this.render();
      }
      left() {
        if (this.cursor <= 0 || this.placeholder) return this.bell();
        this.moveCursor(-1);
        this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
        this.moveCursor(1);
        this.render();
      }
      isCursorAtStart() {
        return this.cursor === 0 || this.placeholder && this.cursor === 1;
      }
      isCursorAtEnd() {
        return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
      }
      render() {
        if (this.closed) return;
        if (!this.firstRender) {
          if (this.outputError) this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
          this.out.write(clear(this.outputText, this.out.columns));
        }
        super.render();
        this.outputError = "";
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.red ? color.red(this.rendered) : this.rendered].join(` `);
        if (this.error) {
          this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
      }
    };
    module2.exports = TextPrompt;
  }
});

// node_modules/prompts/dist/elements/select.js
var require_select = __commonJS({
  "node_modules/prompts/dist/elements/select.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_util2();
    var style = _require.style;
    var clear = _require.clear;
    var figures = _require.figures;
    var wrap2 = _require.wrap;
    var entriesToDisplay = _require.entriesToDisplay;
    var _require2 = require_src();
    var cursor = _require2.cursor;
    var SelectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.hint = opts.hint || "- Use arrow-keys. Return to submit.";
        this.warn = opts.warn || "- This option is disabled";
        this.cursor = opts.initial || 0;
        this.choices = opts.choices.map((ch, idx) => {
          if (typeof ch === "string") ch = {
            title: ch,
            value: idx
          };
          return {
            title: ch && (ch.title || ch.value || ch),
            value: ch && (ch.value === void 0 ? idx : ch.value),
            description: ch && ch.description,
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        });
        this.optionsPerPage = opts.optionsPerPage || 10;
        this.value = (this.choices[this.cursor] || {}).value;
        this.clear = clear("", this.out.columns);
        this.render();
      }
      moveCursor(n) {
        this.cursor = n;
        this.value = this.choices[n].value;
        this.fire();
      }
      reset() {
        this.moveCursor(0);
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        if (!this.selection.disabled) {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        } else this.bell();
      }
      first() {
        this.moveCursor(0);
        this.render();
      }
      last() {
        this.moveCursor(this.choices.length - 1);
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.moveCursor(this.choices.length - 1);
        } else {
          this.moveCursor(this.cursor - 1);
        }
        this.render();
      }
      down() {
        if (this.cursor === this.choices.length - 1) {
          this.moveCursor(0);
        } else {
          this.moveCursor(this.cursor + 1);
        }
        this.render();
      }
      next() {
        this.moveCursor((this.cursor + 1) % this.choices.length);
        this.render();
      }
      _(c, key) {
        if (c === " ") return this.submit();
      }
      get selection() {
        return this.choices[this.cursor];
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        else this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        let _entriesToDisplay = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)].join(" ");
        if (!this.done) {
          this.outputText += "\n";
          for (let i = startIndex; i < endIndex; i++) {
            let title2, prefix, desc = "", v = this.choices[i];
            if (i === startIndex && startIndex > 0) {
              prefix = figures.arrowUp;
            } else if (i === endIndex - 1 && endIndex < this.choices.length) {
              prefix = figures.arrowDown;
            } else {
              prefix = " ";
            }
            if (v.disabled) {
              title2 = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
              prefix = (this.cursor === i ? color.bold().gray(figures.pointer) + " " : "  ") + prefix;
            } else {
              title2 = this.cursor === i ? color.cyan().underline(v.title) : v.title;
              prefix = (this.cursor === i ? color.cyan(figures.pointer) + " " : "  ") + prefix;
              if (v.description && this.cursor === i) {
                desc = ` - ${v.description}`;
                if (prefix.length + title2.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                  desc = "\n" + wrap2(v.description, {
                    margin: 3,
                    width: this.out.columns
                  });
                }
              }
            }
            this.outputText += `${prefix} ${title2}${color.gray(desc)}
`;
          }
        }
        this.out.write(this.outputText);
      }
    };
    module2.exports = SelectPrompt;
  }
});

// node_modules/prompts/dist/elements/toggle.js
var require_toggle = __commonJS({
  "node_modules/prompts/dist/elements/toggle.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_util2();
    var style = _require.style;
    var clear = _require.clear;
    var _require2 = require_src();
    var cursor = _require2.cursor;
    var erase = _require2.erase;
    var TogglePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.value = !!opts.initial;
        this.active = opts.active || "on";
        this.inactive = opts.inactive || "off";
        this.initialValue = this.value;
        this.render();
      }
      reset() {
        this.value = this.initialValue;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      deactivate() {
        if (this.value === false) return this.bell();
        this.value = false;
        this.render();
      }
      activate() {
        if (this.value === true) return this.bell();
        this.value = true;
        this.render();
      }
      delete() {
        this.deactivate();
      }
      left() {
        this.deactivate();
      }
      right() {
        this.activate();
      }
      down() {
        this.deactivate();
      }
      up() {
        this.activate();
      }
      next() {
        this.value = !this.value;
        this.fire();
        this.render();
      }
      _(c, key) {
        if (c === " ") {
          this.value = !this.value;
        } else if (c === "1") {
          this.value = true;
        } else if (c === "0") {
          this.value = false;
        } else return this.bell();
        this.render();
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        else this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.value ? this.inactive : color.cyan().underline(this.inactive), color.gray("/"), this.value ? color.cyan().underline(this.active) : this.active].join(" ");
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = TogglePrompt;
  }
});

// node_modules/prompts/dist/dateparts/datepart.js
var require_datepart = __commonJS({
  "node_modules/prompts/dist/dateparts/datepart.js"(exports2, module2) {
    "use strict";
    var DatePart = class _DatePart {
      constructor({
        token,
        date,
        parts,
        locales
      }) {
        this.token = token;
        this.date = date || /* @__PURE__ */ new Date();
        this.parts = parts || [this];
        this.locales = locales || {};
      }
      up() {
      }
      down() {
      }
      next() {
        const currentIdx = this.parts.indexOf(this);
        return this.parts.find((part, idx) => idx > currentIdx && part instanceof _DatePart);
      }
      setTo(val) {
      }
      prev() {
        let parts = [].concat(this.parts).reverse();
        const currentIdx = parts.indexOf(this);
        return parts.find((part, idx) => idx > currentIdx && part instanceof _DatePart);
      }
      toString() {
        return String(this.date);
      }
    };
    module2.exports = DatePart;
  }
});

// node_modules/prompts/dist/dateparts/meridiem.js
var require_meridiem = __commonJS({
  "node_modules/prompts/dist/dateparts/meridiem.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Meridiem = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours((this.date.getHours() + 12) % 24);
      }
      down() {
        this.up();
      }
      toString() {
        let meridiem = this.date.getHours() > 12 ? "pm" : "am";
        return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
      }
    };
    module2.exports = Meridiem;
  }
});

// node_modules/prompts/dist/dateparts/day.js
var require_day = __commonJS({
  "node_modules/prompts/dist/dateparts/day.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var pos = (n) => {
      n = n % 10;
      return n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
    };
    var Day = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setDate(this.date.getDate() + 1);
      }
      down() {
        this.date.setDate(this.date.getDate() - 1);
      }
      setTo(val) {
        this.date.setDate(parseInt(val.substr(-2)));
      }
      toString() {
        let date = this.date.getDate();
        let day = this.date.getDay();
        return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
      }
    };
    module2.exports = Day;
  }
});

// node_modules/prompts/dist/dateparts/hours.js
var require_hours = __commonJS({
  "node_modules/prompts/dist/dateparts/hours.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Hours = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours(this.date.getHours() + 1);
      }
      down() {
        this.date.setHours(this.date.getHours() - 1);
      }
      setTo(val) {
        this.date.setHours(parseInt(val.substr(-2)));
      }
      toString() {
        let hours = this.date.getHours();
        if (/h/.test(this.token)) hours = hours % 12 || 12;
        return this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
      }
    };
    module2.exports = Hours;
  }
});

// node_modules/prompts/dist/dateparts/milliseconds.js
var require_milliseconds = __commonJS({
  "node_modules/prompts/dist/dateparts/milliseconds.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Milliseconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMilliseconds(this.date.getMilliseconds() + 1);
      }
      down() {
        this.date.setMilliseconds(this.date.getMilliseconds() - 1);
      }
      setTo(val) {
        this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
      }
      toString() {
        return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
      }
    };
    module2.exports = Milliseconds;
  }
});

// node_modules/prompts/dist/dateparts/minutes.js
var require_minutes = __commonJS({
  "node_modules/prompts/dist/dateparts/minutes.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Minutes = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMinutes(this.date.getMinutes() + 1);
      }
      down() {
        this.date.setMinutes(this.date.getMinutes() - 1);
      }
      setTo(val) {
        this.date.setMinutes(parseInt(val.substr(-2)));
      }
      toString() {
        let m = this.date.getMinutes();
        return this.token.length > 1 ? String(m).padStart(2, "0") : m;
      }
    };
    module2.exports = Minutes;
  }
});

// node_modules/prompts/dist/dateparts/month.js
var require_month = __commonJS({
  "node_modules/prompts/dist/dateparts/month.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Month = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMonth(this.date.getMonth() + 1);
      }
      down() {
        this.date.setMonth(this.date.getMonth() - 1);
      }
      setTo(val) {
        val = parseInt(val.substr(-2)) - 1;
        this.date.setMonth(val < 0 ? 0 : val);
      }
      toString() {
        let month = this.date.getMonth();
        let tl = this.token.length;
        return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
      }
    };
    module2.exports = Month;
  }
});

// node_modules/prompts/dist/dateparts/seconds.js
var require_seconds = __commonJS({
  "node_modules/prompts/dist/dateparts/seconds.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Seconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setSeconds(this.date.getSeconds() + 1);
      }
      down() {
        this.date.setSeconds(this.date.getSeconds() - 1);
      }
      setTo(val) {
        this.date.setSeconds(parseInt(val.substr(-2)));
      }
      toString() {
        let s = this.date.getSeconds();
        return this.token.length > 1 ? String(s).padStart(2, "0") : s;
      }
    };
    module2.exports = Seconds;
  }
});

// node_modules/prompts/dist/dateparts/year.js
var require_year = __commonJS({
  "node_modules/prompts/dist/dateparts/year.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart();
    var Year = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setFullYear(this.date.getFullYear() + 1);
      }
      down() {
        this.date.setFullYear(this.date.getFullYear() - 1);
      }
      setTo(val) {
        this.date.setFullYear(val.substr(-4));
      }
      toString() {
        let year = String(this.date.getFullYear()).padStart(4, "0");
        return this.token.length === 2 ? year.substr(-2) : year;
      }
    };
    module2.exports = Year;
  }
});

// node_modules/prompts/dist/dateparts/index.js
var require_dateparts = __commonJS({
  "node_modules/prompts/dist/dateparts/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      DatePart: require_datepart(),
      Meridiem: require_meridiem(),
      Day: require_day(),
      Hours: require_hours(),
      Milliseconds: require_milliseconds(),
      Minutes: require_minutes(),
      Month: require_month(),
      Seconds: require_seconds(),
      Year: require_year()
    };
  }
});

// node_modules/prompts/dist/elements/date.js
var require_date = __commonJS({
  "node_modules/prompts/dist/elements/date.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_util2();
    var style = _require.style;
    var clear = _require.clear;
    var figures = _require.figures;
    var _require2 = require_src();
    var erase = _require2.erase;
    var cursor = _require2.cursor;
    var _require3 = require_dateparts();
    var DatePart = _require3.DatePart;
    var Meridiem = _require3.Meridiem;
    var Day = _require3.Day;
    var Hours = _require3.Hours;
    var Milliseconds = _require3.Milliseconds;
    var Minutes = _require3.Minutes;
    var Month = _require3.Month;
    var Seconds = _require3.Seconds;
    var Year = _require3.Year;
    var regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
    var regexGroups = {
      1: ({
        token
      }) => token.replace(/\\(.)/g, "$1"),
      2: (opts) => new Day(opts),
      // Day // TODO
      3: (opts) => new Month(opts),
      // Month
      4: (opts) => new Year(opts),
      // Year
      5: (opts) => new Meridiem(opts),
      // AM/PM // TODO (special)
      6: (opts) => new Hours(opts),
      // Hours
      7: (opts) => new Minutes(opts),
      // Minutes
      8: (opts) => new Seconds(opts),
      // Seconds
      9: (opts) => new Milliseconds(opts)
      // Fractional seconds
    };
    var dfltLocales = {
      months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
      monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
      weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
      weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
    };
    var DatePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.cursor = 0;
        this.typed = "";
        this.locales = Object.assign(dfltLocales, opts.locales);
        this._date = opts.initial || /* @__PURE__ */ new Date();
        this.errorMsg = opts.error || "Please Enter A Valid Value";
        this.validator = opts.validate || (() => true);
        this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss";
        this.clear = clear("", this.out.columns);
        this.render();
      }
      get value() {
        return this.date;
      }
      get date() {
        return this._date;
      }
      set date(date) {
        if (date) this._date.setTime(date.getTime());
      }
      set mask(mask) {
        let result;
        this.parts = [];
        while (result = regex.exec(mask)) {
          let match2 = result.shift();
          let idx = result.findIndex((gr) => gr != null);
          this.parts.push(idx in regexGroups ? regexGroups[idx]({
            token: result[idx] || match2,
            date: this.date,
            parts: this.parts,
            locales: this.locales
          }) : result[idx] || match2);
        }
        let parts = this.parts.reduce((arr, i) => {
          if (typeof i === "string" && typeof arr[arr.length - 1] === "string") arr[arr.length - 1] += i;
          else arr.push(i);
          return arr;
        }, []);
        this.parts.splice(0);
        this.parts.push(...parts);
        this.reset();
      }
      moveCursor(n) {
        this.typed = "";
        this.cursor = n;
        this.fire();
      }
      reset() {
        this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart));
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.error = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      validate() {
        var _this = this;
        return _asyncToGenerator(function* () {
          let valid = yield _this.validator(_this.value);
          if (typeof valid === "string") {
            _this.errorMsg = valid;
            valid = false;
          }
          _this.error = !valid;
        })();
      }
      submit() {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          yield _this2.validate();
          if (_this2.error) {
            _this2.color = "red";
            _this2.fire();
            _this2.render();
            return;
          }
          _this2.done = true;
          _this2.aborted = false;
          _this2.fire();
          _this2.render();
          _this2.out.write("\n");
          _this2.close();
        })();
      }
      up() {
        this.typed = "";
        this.parts[this.cursor].up();
        this.render();
      }
      down() {
        this.typed = "";
        this.parts[this.cursor].down();
        this.render();
      }
      left() {
        let prev = this.parts[this.cursor].prev();
        if (prev == null) return this.bell();
        this.moveCursor(this.parts.indexOf(prev));
        this.render();
      }
      right() {
        let next = this.parts[this.cursor].next();
        if (next == null) return this.bell();
        this.moveCursor(this.parts.indexOf(next));
        this.render();
      }
      next() {
        let next = this.parts[this.cursor].next();
        this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart));
        this.render();
      }
      _(c) {
        if (/\d/.test(c)) {
          this.typed += c;
          this.parts[this.cursor].setTo(this.typed);
          this.render();
        }
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        else this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")].join(" ");
        if (this.error) {
          this.outputText += this.errorMsg.split("\n").reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = DatePrompt;
  }
});

// node_modules/prompts/dist/elements/number.js
var require_number = __commonJS({
  "node_modules/prompts/dist/elements/number.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_src();
    var cursor = _require.cursor;
    var erase = _require.erase;
    var _require2 = require_util2();
    var style = _require2.style;
    var figures = _require2.figures;
    var clear = _require2.clear;
    var lines = _require2.lines;
    var isNumber = /[0-9]/;
    var isDef = (any) => any !== void 0;
    var round = (number, precision) => {
      let factor = Math.pow(10, precision);
      return Math.round(number * factor) / factor;
    };
    var NumberPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.transform = style.render(opts.style);
        this.msg = opts.message;
        this.initial = isDef(opts.initial) ? opts.initial : "";
        this.float = !!opts.float;
        this.round = opts.round || 2;
        this.inc = opts.increment || 1;
        this.min = isDef(opts.min) ? opts.min : -Infinity;
        this.max = isDef(opts.max) ? opts.max : Infinity;
        this.errorMsg = opts.error || `Please Enter A Valid Value`;
        this.validator = opts.validate || (() => true);
        this.color = `cyan`;
        this.value = ``;
        this.typed = ``;
        this.lastHit = 0;
        this.render();
      }
      set value(v) {
        if (!v && v !== 0) {
          this.placeholder = true;
          this.rendered = color.gray(this.transform.render(`${this.initial}`));
          this._value = ``;
        } else {
          this.placeholder = false;
          this.rendered = this.transform.render(`${round(v, this.round)}`);
          this._value = round(v, this.round);
        }
        this.fire();
      }
      get value() {
        return this._value;
      }
      parse(x) {
        return this.float ? parseFloat(x) : parseInt(x);
      }
      valid(c) {
        return c === `-` || c === `.` && this.float || isNumber.test(c);
      }
      reset() {
        this.typed = ``;
        this.value = ``;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        let x = this.value;
        this.value = x !== `` ? x : this.initial;
        this.done = this.aborted = true;
        this.error = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      }
      validate() {
        var _this = this;
        return _asyncToGenerator(function* () {
          let valid = yield _this.validator(_this.value);
          if (typeof valid === `string`) {
            _this.errorMsg = valid;
            valid = false;
          }
          _this.error = !valid;
        })();
      }
      submit() {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          yield _this2.validate();
          if (_this2.error) {
            _this2.color = `red`;
            _this2.fire();
            _this2.render();
            return;
          }
          let x = _this2.value;
          _this2.value = x !== `` ? x : _this2.initial;
          _this2.done = true;
          _this2.aborted = false;
          _this2.error = false;
          _this2.fire();
          _this2.render();
          _this2.out.write(`
`);
          _this2.close();
        })();
      }
      up() {
        this.typed = ``;
        if (this.value === "") {
          this.value = this.min - this.inc;
        }
        if (this.value >= this.max) return this.bell();
        this.value += this.inc;
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      down() {
        this.typed = ``;
        if (this.value === "") {
          this.value = this.min + this.inc;
        }
        if (this.value <= this.min) return this.bell();
        this.value -= this.inc;
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      delete() {
        let val = this.value.toString();
        if (val.length === 0) return this.bell();
        this.value = this.parse(val = val.slice(0, -1)) || ``;
        if (this.value !== "" && this.value < this.min) {
          this.value = this.min;
        }
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      next() {
        this.value = this.initial;
        this.fire();
        this.render();
      }
      _(c, key) {
        if (!this.valid(c)) return this.bell();
        const now = Date.now();
        if (now - this.lastHit > 1e3) this.typed = ``;
        this.typed += c;
        this.lastHit = now;
        this.color = `cyan`;
        if (c === `.`) return this.fire();
        this.value = Math.min(this.parse(this.typed), this.max);
        if (this.value > this.max) this.value = this.max;
        if (this.value < this.min) this.value = this.min;
        this.fire();
        this.render();
      }
      render() {
        if (this.closed) return;
        if (!this.firstRender) {
          if (this.outputError) this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
          this.out.write(clear(this.outputText, this.out.columns));
        }
        super.render();
        this.outputError = "";
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered].join(` `);
        if (this.error) {
          this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
      }
    };
    module2.exports = NumberPrompt;
  }
});

// node_modules/prompts/dist/elements/multiselect.js
var require_multiselect = __commonJS({
  "node_modules/prompts/dist/elements/multiselect.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var _require = require_src();
    var cursor = _require.cursor;
    var Prompt = require_prompt();
    var _require2 = require_util2();
    var clear = _require2.clear;
    var figures = _require2.figures;
    var style = _require2.style;
    var wrap2 = _require2.wrap;
    var entriesToDisplay = _require2.entriesToDisplay;
    var MultiselectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.cursor = opts.cursor || 0;
        this.scrollIndex = opts.cursor || 0;
        this.hint = opts.hint || "";
        this.warn = opts.warn || "- This option is disabled -";
        this.minSelected = opts.min;
        this.showMinError = false;
        this.maxChoices = opts.max;
        this.instructions = opts.instructions;
        this.optionsPerPage = opts.optionsPerPage || 10;
        this.value = opts.choices.map((ch, idx) => {
          if (typeof ch === "string") ch = {
            title: ch,
            value: idx
          };
          return {
            title: ch && (ch.title || ch.value || ch),
            description: ch && ch.description,
            value: ch && (ch.value === void 0 ? idx : ch.value),
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        });
        this.clear = clear("", this.out.columns);
        if (!opts.overrideRender) {
          this.render();
        }
      }
      reset() {
        this.value.map((v) => !v.selected);
        this.cursor = 0;
        this.fire();
        this.render();
      }
      selected() {
        return this.value.filter((v) => v.selected);
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        const selected = this.value.filter((e) => e.selected);
        if (this.minSelected && selected.length < this.minSelected) {
          this.showMinError = true;
          this.render();
        } else {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
      }
      first() {
        this.cursor = 0;
        this.render();
      }
      last() {
        this.cursor = this.value.length - 1;
        this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.value.length;
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.cursor = this.value.length - 1;
        } else {
          this.cursor--;
        }
        this.render();
      }
      down() {
        if (this.cursor === this.value.length - 1) {
          this.cursor = 0;
        } else {
          this.cursor++;
        }
        this.render();
      }
      left() {
        this.value[this.cursor].selected = false;
        this.render();
      }
      right() {
        if (this.value.filter((e) => e.selected).length >= this.maxChoices) return this.bell();
        this.value[this.cursor].selected = true;
        this.render();
      }
      handleSpaceToggle() {
        const v = this.value[this.cursor];
        if (v.selected) {
          v.selected = false;
          this.render();
        } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
          return this.bell();
        } else {
          v.selected = true;
          this.render();
        }
      }
      toggleAll() {
        if (this.maxChoices !== void 0 || this.value[this.cursor].disabled) {
          return this.bell();
        }
        const newSelected = !this.value[this.cursor].selected;
        this.value.filter((v) => !v.disabled).forEach((v) => v.selected = newSelected);
        this.render();
      }
      _(c, key) {
        if (c === " ") {
          this.handleSpaceToggle();
        } else if (c === "a") {
          this.toggleAll();
        } else {
          return this.bell();
        }
      }
      renderInstructions() {
        if (this.instructions === void 0 || this.instructions) {
          if (typeof this.instructions === "string") {
            return this.instructions;
          }
          return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + `    enter/return: Complete answer`;
        }
        return "";
      }
      renderOption(cursor2, v, i, arrowIndicator) {
        const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + " " + arrowIndicator + " ";
        let title2, desc;
        if (v.disabled) {
          title2 = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
        } else {
          title2 = cursor2 === i ? color.cyan().underline(v.title) : v.title;
          if (cursor2 === i && v.description) {
            desc = ` - ${v.description}`;
            if (prefix.length + title2.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
              desc = "\n" + wrap2(v.description, {
                margin: prefix.length,
                width: this.out.columns
              });
            }
          }
        }
        return prefix + title2 + color.gray(desc || "");
      }
      // shared with autocompleteMultiselect
      paginateOptions(options) {
        if (options.length === 0) {
          return color.red("No matches for this query.");
        }
        let _entriesToDisplay = entriesToDisplay(this.cursor, options.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
        let prefix, styledOptions = [];
        for (let i = startIndex; i < endIndex; i++) {
          if (i === startIndex && startIndex > 0) {
            prefix = figures.arrowUp;
          } else if (i === endIndex - 1 && endIndex < options.length) {
            prefix = figures.arrowDown;
          } else {
            prefix = " ";
          }
          styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
        }
        return "\n" + styledOptions.join("\n");
      }
      // shared with autocomleteMultiselect
      renderOptions(options) {
        if (!this.done) {
          return this.paginateOptions(options);
        }
        return "";
      }
      renderDoneOrInstructions() {
        if (this.done) {
          return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
        }
        const output = [color.gray(this.hint), this.renderInstructions()];
        if (this.value[this.cursor].disabled) {
          output.push(color.yellow(this.warn));
        }
        return output.join(" ");
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        super.render();
        let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(" ");
        if (this.showMinError) {
          prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
          this.showMinError = false;
        }
        prompt += this.renderOptions(this.value);
        this.out.write(this.clear + prompt);
        this.clear = clear(prompt, this.out.columns);
      }
    };
    module2.exports = MultiselectPrompt;
  }
});

// node_modules/prompts/dist/elements/autocomplete.js
var require_autocomplete = __commonJS({
  "node_modules/prompts/dist/elements/autocomplete.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_src();
    var erase = _require.erase;
    var cursor = _require.cursor;
    var _require2 = require_util2();
    var style = _require2.style;
    var clear = _require2.clear;
    var figures = _require2.figures;
    var wrap2 = _require2.wrap;
    var entriesToDisplay = _require2.entriesToDisplay;
    var getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);
    var getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);
    var getIndex = (arr, valOrTitle) => {
      const index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
      return index > -1 ? index : void 0;
    };
    var AutocompletePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.suggest = opts.suggest;
        this.choices = opts.choices;
        this.initial = typeof opts.initial === "number" ? opts.initial : getIndex(opts.choices, opts.initial);
        this.select = this.initial || opts.cursor || 0;
        this.i18n = {
          noMatches: opts.noMatches || "no matches found"
        };
        this.fallback = opts.fallback || this.initial;
        this.clearFirst = opts.clearFirst || false;
        this.suggestions = [];
        this.input = "";
        this.limit = opts.limit || 10;
        this.cursor = 0;
        this.transform = style.render(opts.style);
        this.scale = this.transform.scale;
        this.render = this.render.bind(this);
        this.complete = this.complete.bind(this);
        this.clear = clear("", this.out.columns);
        this.complete(this.render);
        this.render();
      }
      set fallback(fb) {
        this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
      }
      get fallback() {
        let choice;
        if (typeof this._fb === "number") choice = this.choices[this._fb];
        else if (typeof this._fb === "string") choice = {
          title: this._fb
        };
        return choice || this._fb || {
          title: this.i18n.noMatches
        };
      }
      moveSelect(i) {
        this.select = i;
        if (this.suggestions.length > 0) this.value = getVal(this.suggestions, i);
        else this.value = this.fallback.value;
        this.fire();
      }
      complete(cb) {
        var _this = this;
        return _asyncToGenerator(function* () {
          const p = _this.completing = _this.suggest(_this.input, _this.choices);
          const suggestions = yield p;
          if (_this.completing !== p) return;
          _this.suggestions = suggestions.map((s, i, arr) => ({
            title: getTitle(arr, i),
            value: getVal(arr, i),
            description: s.description
          }));
          _this.completing = false;
          const l = Math.max(suggestions.length - 1, 0);
          _this.moveSelect(Math.min(l, _this.select));
          cb && cb();
        })();
      }
      reset() {
        this.input = "";
        this.complete(() => {
          this.moveSelect(this.initial !== void 0 ? this.initial : 0);
          this.render();
        });
        this.render();
      }
      exit() {
        if (this.clearFirst && this.input.length > 0) {
          this.reset();
        } else {
          this.done = this.exited = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
      }
      abort() {
        this.done = this.aborted = true;
        this.exited = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.done = true;
        this.aborted = this.exited = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      _(c, key) {
        let s1 = this.input.slice(0, this.cursor);
        let s2 = this.input.slice(this.cursor);
        this.input = `${s1}${c}${s2}`;
        this.cursor = s1.length + 1;
        this.complete(this.render);
        this.render();
      }
      delete() {
        if (this.cursor === 0) return this.bell();
        let s1 = this.input.slice(0, this.cursor - 1);
        let s2 = this.input.slice(this.cursor);
        this.input = `${s1}${s2}`;
        this.complete(this.render);
        this.cursor = this.cursor - 1;
        this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length) return this.bell();
        let s1 = this.input.slice(0, this.cursor);
        let s2 = this.input.slice(this.cursor + 1);
        this.input = `${s1}${s2}`;
        this.complete(this.render);
        this.render();
      }
      first() {
        this.moveSelect(0);
        this.render();
      }
      last() {
        this.moveSelect(this.suggestions.length - 1);
        this.render();
      }
      up() {
        if (this.select === 0) {
          this.moveSelect(this.suggestions.length - 1);
        } else {
          this.moveSelect(this.select - 1);
        }
        this.render();
      }
      down() {
        if (this.select === this.suggestions.length - 1) {
          this.moveSelect(0);
        } else {
          this.moveSelect(this.select + 1);
        }
        this.render();
      }
      next() {
        if (this.select === this.suggestions.length - 1) {
          this.moveSelect(0);
        } else this.moveSelect(this.select + 1);
        this.render();
      }
      nextPage() {
        this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
        this.render();
      }
      prevPage() {
        this.moveSelect(Math.max(this.select - this.limit, 0));
        this.render();
      }
      left() {
        if (this.cursor <= 0) return this.bell();
        this.cursor = this.cursor - 1;
        this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length) return this.bell();
        this.cursor = this.cursor + 1;
        this.render();
      }
      renderOption(v, hovered, isStart, isEnd) {
        let desc;
        let prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : " ";
        let title2 = hovered ? color.cyan().underline(v.title) : v.title;
        prefix = (hovered ? color.cyan(figures.pointer) + " " : "  ") + prefix;
        if (v.description) {
          desc = ` - ${v.description}`;
          if (prefix.length + title2.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
            desc = "\n" + wrap2(v.description, {
              margin: 3,
              width: this.out.columns
            });
          }
        }
        return prefix + " " + title2 + color.gray(desc || "");
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        else this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        let _entriesToDisplay = entriesToDisplay(this.select, this.choices.length, this.limit), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
        this.outputText = [style.symbol(this.done, this.aborted, this.exited), color.bold(this.msg), style.delimiter(this.completing), this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(" ");
        if (!this.done) {
          const suggestions = this.suggestions.slice(startIndex, endIndex).map((item, i) => this.renderOption(item, this.select === i + startIndex, i === 0 && startIndex > 0, i + startIndex === endIndex - 1 && endIndex < this.choices.length)).join("\n");
          this.outputText += `
` + (suggestions || color.gray(this.fallback.title));
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = AutocompletePrompt;
  }
});

// node_modules/prompts/dist/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect = __commonJS({
  "node_modules/prompts/dist/elements/autocompleteMultiselect.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var _require = require_src();
    var cursor = _require.cursor;
    var MultiselectPrompt = require_multiselect();
    var _require2 = require_util2();
    var clear = _require2.clear;
    var style = _require2.style;
    var figures = _require2.figures;
    var AutocompleteMultiselectPrompt = class extends MultiselectPrompt {
      constructor(opts = {}) {
        opts.overrideRender = true;
        super(opts);
        this.inputValue = "";
        this.clear = clear("", this.out.columns);
        this.filteredOptions = this.value;
        this.render();
      }
      last() {
        this.cursor = this.filteredOptions.length - 1;
        this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.filteredOptions.length;
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.cursor = this.filteredOptions.length - 1;
        } else {
          this.cursor--;
        }
        this.render();
      }
      down() {
        if (this.cursor === this.filteredOptions.length - 1) {
          this.cursor = 0;
        } else {
          this.cursor++;
        }
        this.render();
      }
      left() {
        this.filteredOptions[this.cursor].selected = false;
        this.render();
      }
      right() {
        if (this.value.filter((e) => e.selected).length >= this.maxChoices) return this.bell();
        this.filteredOptions[this.cursor].selected = true;
        this.render();
      }
      delete() {
        if (this.inputValue.length) {
          this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
          this.updateFilteredOptions();
        }
      }
      updateFilteredOptions() {
        const currentHighlight = this.filteredOptions[this.cursor];
        this.filteredOptions = this.value.filter((v) => {
          if (this.inputValue) {
            if (typeof v.title === "string") {
              if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
                return true;
              }
            }
            if (typeof v.value === "string") {
              if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
                return true;
              }
            }
            return false;
          }
          return true;
        });
        const newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
        this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
        this.render();
      }
      handleSpaceToggle() {
        const v = this.filteredOptions[this.cursor];
        if (v.selected) {
          v.selected = false;
          this.render();
        } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
          return this.bell();
        } else {
          v.selected = true;
          this.render();
        }
      }
      handleInputChange(c) {
        this.inputValue = this.inputValue + c;
        this.updateFilteredOptions();
      }
      _(c, key) {
        if (c === " ") {
          this.handleSpaceToggle();
        } else {
          this.handleInputChange(c);
        }
      }
      renderInstructions() {
        if (this.instructions === void 0 || this.instructions) {
          if (typeof this.instructions === "string") {
            return this.instructions;
          }
          return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
        }
        return "";
      }
      renderCurrentInput() {
        return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
      }
      renderOption(cursor2, v, i) {
        let title2;
        if (v.disabled) title2 = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
        else title2 = cursor2 === i ? color.cyan().underline(v.title) : v.title;
        return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title2;
      }
      renderDoneOrInstructions() {
        if (this.done) {
          return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
        }
        const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
        if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
          output.push(color.yellow(this.warn));
        }
        return output.join(" ");
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        super.render();
        let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(" ");
        if (this.showMinError) {
          prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
          this.showMinError = false;
        }
        prompt += this.renderOptions(this.filteredOptions);
        this.out.write(this.clear + prompt);
        this.clear = clear(prompt, this.out.columns);
      }
    };
    module2.exports = AutocompleteMultiselectPrompt;
  }
});

// node_modules/prompts/dist/elements/confirm.js
var require_confirm = __commonJS({
  "node_modules/prompts/dist/elements/confirm.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var Prompt = require_prompt();
    var _require = require_util2();
    var style = _require.style;
    var clear = _require.clear;
    var _require2 = require_src();
    var erase = _require2.erase;
    var cursor = _require2.cursor;
    var ConfirmPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.value = opts.initial;
        this.initialValue = !!opts.initial;
        this.yesMsg = opts.yes || "yes";
        this.yesOption = opts.yesOption || "(Y/n)";
        this.noMsg = opts.no || "no";
        this.noOption = opts.noOption || "(y/N)";
        this.render();
      }
      reset() {
        this.value = this.initialValue;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.value = this.value || false;
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      _(c, key) {
        if (c.toLowerCase() === "y") {
          this.value = true;
          return this.submit();
        }
        if (c.toLowerCase() === "n") {
          this.value = false;
          return this.submit();
        }
        return this.bell();
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        else this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)].join(" ");
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = ConfirmPrompt;
  }
});

// node_modules/prompts/dist/elements/index.js
var require_elements = __commonJS({
  "node_modules/prompts/dist/elements/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      TextPrompt: require_text(),
      SelectPrompt: require_select(),
      TogglePrompt: require_toggle(),
      DatePrompt: require_date(),
      NumberPrompt: require_number(),
      MultiselectPrompt: require_multiselect(),
      AutocompletePrompt: require_autocomplete(),
      AutocompleteMultiselectPrompt: require_autocompleteMultiselect(),
      ConfirmPrompt: require_confirm()
    };
  }
});

// node_modules/prompts/dist/prompts.js
var require_prompts = __commonJS({
  "node_modules/prompts/dist/prompts.js"(exports2) {
    "use strict";
    var $3 = exports2;
    var el = require_elements();
    var noop = (v) => v;
    function toPrompt(type2, args, opts = {}) {
      return new Promise((res, rej) => {
        const p = new el[type2](args);
        const onAbort = opts.onAbort || noop;
        const onSubmit = opts.onSubmit || noop;
        const onExit = opts.onExit || noop;
        p.on("state", args.onState || noop);
        p.on("submit", (x) => res(onSubmit(x)));
        p.on("exit", (x) => res(onExit(x)));
        p.on("abort", (x) => rej(onAbort(x)));
      });
    }
    $3.text = (args) => toPrompt("TextPrompt", args);
    $3.password = (args) => {
      args.style = "password";
      return $3.text(args);
    };
    $3.invisible = (args) => {
      args.style = "invisible";
      return $3.text(args);
    };
    $3.number = (args) => toPrompt("NumberPrompt", args);
    $3.date = (args) => toPrompt("DatePrompt", args);
    $3.confirm = (args) => toPrompt("ConfirmPrompt", args);
    $3.list = (args) => {
      const sep2 = args.separator || ",";
      return toPrompt("TextPrompt", args, {
        onSubmit: (str) => str.split(sep2).map((s) => s.trim())
      });
    };
    $3.toggle = (args) => toPrompt("TogglePrompt", args);
    $3.select = (args) => toPrompt("SelectPrompt", args);
    $3.multiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("MultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    $3.autocompleteMultiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("AutocompleteMultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    var byTitle = (input, choices) => Promise.resolve(choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase()));
    $3.autocomplete = (args) => {
      args.suggest = args.suggest || byTitle;
      args.choices = [].concat(args.choices || []);
      return toPrompt("AutocompletePrompt", args);
    };
  }
});

// node_modules/prompts/dist/index.js
var require_dist = __commonJS({
  "node_modules/prompts/dist/index.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var prompts2 = require_prompts();
    var passOn = ["suggest", "format", "onState", "validate", "onRender", "type"];
    var noop = () => {
    };
    function prompt() {
      return _prompt.apply(this, arguments);
    }
    function _prompt() {
      _prompt = _asyncToGenerator(function* (questions = [], {
        onSubmit = noop,
        onCancel = noop
      } = {}) {
        const answers = {};
        const override2 = prompt._override || {};
        questions = [].concat(questions);
        let answer, question, quit, name, type2, lastPrompt;
        const getFormattedAnswer = /* @__PURE__ */ (function() {
          var _ref = _asyncToGenerator(function* (question2, answer2, skipValidation = false) {
            if (!skipValidation && question2.validate && question2.validate(answer2) !== true) {
              return;
            }
            return question2.format ? yield question2.format(answer2, answers) : answer2;
          });
          return function getFormattedAnswer2(_x, _x2) {
            return _ref.apply(this, arguments);
          };
        })();
        var _iterator = _createForOfIteratorHelper(questions), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            question = _step.value;
            var _question = question;
            name = _question.name;
            type2 = _question.type;
            if (typeof type2 === "function") {
              type2 = yield type2(answer, _objectSpread({}, answers), question);
              question["type"] = type2;
            }
            if (!type2) continue;
            for (let key in question) {
              if (passOn.includes(key)) continue;
              let value = question[key];
              question[key] = typeof value === "function" ? yield value(answer, _objectSpread({}, answers), lastPrompt) : value;
            }
            lastPrompt = question;
            if (typeof question.message !== "string") {
              throw new Error("prompt message is required");
            }
            var _question2 = question;
            name = _question2.name;
            type2 = _question2.type;
            if (prompts2[type2] === void 0) {
              throw new Error(`prompt type (${type2}) is not defined`);
            }
            if (override2[question.name] !== void 0) {
              answer = yield getFormattedAnswer(question, override2[question.name]);
              if (answer !== void 0) {
                answers[name] = answer;
                continue;
              }
            }
            try {
              answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : yield prompts2[type2](question);
              answers[name] = answer = yield getFormattedAnswer(question, answer, true);
              quit = yield onSubmit(question, answer, answers);
            } catch (err) {
              quit = !(yield onCancel(question, answers));
            }
            if (quit) return answers;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return answers;
      });
      return _prompt.apply(this, arguments);
    }
    function getInjectedAnswer(injected, deafultValue) {
      const answer = injected.shift();
      if (answer instanceof Error) {
        throw answer;
      }
      return answer === void 0 ? deafultValue : answer;
    }
    function inject(answers) {
      prompt._injected = (prompt._injected || []).concat(answers);
    }
    function override(answers) {
      prompt._override = Object.assign({}, answers);
    }
    module2.exports = Object.assign(prompt, {
      prompt,
      prompts: prompts2,
      inject,
      override
    });
  }
});

// node_modules/prompts/lib/util/action.js
var require_action2 = __commonJS({
  "node_modules/prompts/lib/util/action.js"(exports2, module2) {
    "use strict";
    module2.exports = (key, isSelect) => {
      if (key.meta && key.name !== "escape") return;
      if (key.ctrl) {
        if (key.name === "a") return "first";
        if (key.name === "c") return "abort";
        if (key.name === "d") return "abort";
        if (key.name === "e") return "last";
        if (key.name === "g") return "reset";
      }
      if (isSelect) {
        if (key.name === "j") return "down";
        if (key.name === "k") return "up";
      }
      if (key.name === "return") return "submit";
      if (key.name === "enter") return "submit";
      if (key.name === "backspace") return "delete";
      if (key.name === "delete") return "deleteForward";
      if (key.name === "abort") return "abort";
      if (key.name === "escape") return "exit";
      if (key.name === "tab") return "next";
      if (key.name === "pagedown") return "nextPage";
      if (key.name === "pageup") return "prevPage";
      if (key.name === "home") return "home";
      if (key.name === "end") return "end";
      if (key.name === "up") return "up";
      if (key.name === "down") return "down";
      if (key.name === "right") return "right";
      if (key.name === "left") return "left";
      return false;
    };
  }
});

// node_modules/prompts/lib/util/strip.js
var require_strip2 = __commonJS({
  "node_modules/prompts/lib/util/strip.js"(exports2, module2) {
    "use strict";
    module2.exports = (str) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
      ].join("|");
      const RGX = new RegExp(pattern, "g");
      return typeof str === "string" ? str.replace(RGX, "") : str;
    };
  }
});

// node_modules/prompts/lib/util/clear.js
var require_clear2 = __commonJS({
  "node_modules/prompts/lib/util/clear.js"(exports2, module2) {
    "use strict";
    var strip = require_strip2();
    var { erase, cursor } = require_src();
    var width = (str) => [...strip(str)].length;
    module2.exports = function(prompt, perLine) {
      if (!perLine) return erase.line + cursor.to(0);
      let rows = 0;
      const lines = prompt.split(/\r?\n/);
      for (let line of lines) {
        rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
      }
      return erase.lines(rows);
    };
  }
});

// node_modules/prompts/lib/util/figures.js
var require_figures2 = __commonJS({
  "node_modules/prompts/lib/util/figures.js"(exports2, module2) {
    "use strict";
    var main = {
      arrowUp: "\u2191",
      arrowDown: "\u2193",
      arrowLeft: "\u2190",
      arrowRight: "\u2192",
      radioOn: "\u25C9",
      radioOff: "\u25EF",
      tick: "\u2714",
      cross: "\u2716",
      ellipsis: "\u2026",
      pointerSmall: "\u203A",
      line: "\u2500",
      pointer: "\u276F"
    };
    var win = {
      arrowUp: main.arrowUp,
      arrowDown: main.arrowDown,
      arrowLeft: main.arrowLeft,
      arrowRight: main.arrowRight,
      radioOn: "(*)",
      radioOff: "( )",
      tick: "\u221A",
      cross: "\xD7",
      ellipsis: "...",
      pointerSmall: "\xBB",
      line: "\u2500",
      pointer: ">"
    };
    var figures = process.platform === "win32" ? win : main;
    module2.exports = figures;
  }
});

// node_modules/prompts/lib/util/style.js
var require_style2 = __commonJS({
  "node_modules/prompts/lib/util/style.js"(exports2, module2) {
    "use strict";
    var c = require_kleur();
    var figures = require_figures2();
    var styles = Object.freeze({
      password: { scale: 1, render: (input) => "*".repeat(input.length) },
      emoji: { scale: 2, render: (input) => "\u{1F603}".repeat(input.length) },
      invisible: { scale: 0, render: (input) => "" },
      default: { scale: 1, render: (input) => `${input}` }
    });
    var render = (type2) => styles[type2] || styles.default;
    var symbols = Object.freeze({
      aborted: c.red(figures.cross),
      done: c.green(figures.tick),
      exited: c.yellow(figures.cross),
      default: c.cyan("?")
    });
    var symbol = (done, aborted, exited) => aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols.default;
    var delimiter = (completing) => c.gray(completing ? figures.ellipsis : figures.pointerSmall);
    var item = (expandable, expanded) => c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
    module2.exports = {
      styles,
      render,
      symbols,
      symbol,
      delimiter,
      item
    };
  }
});

// node_modules/prompts/lib/util/lines.js
var require_lines2 = __commonJS({
  "node_modules/prompts/lib/util/lines.js"(exports2, module2) {
    "use strict";
    var strip = require_strip2();
    module2.exports = function(msg, perLine) {
      let lines = String(strip(msg) || "").split(/\r?\n/);
      if (!perLine) return lines.length;
      return lines.map((l) => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
    };
  }
});

// node_modules/prompts/lib/util/wrap.js
var require_wrap2 = __commonJS({
  "node_modules/prompts/lib/util/wrap.js"(exports2, module2) {
    "use strict";
    module2.exports = (msg, opts = {}) => {
      const tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(" ").join("") : opts.margin || "";
      const width = opts.width;
      return (msg || "").split(/\r?\n/g).map((line) => line.split(/\s+/g).reduce((arr, w) => {
        if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width)
          arr[arr.length - 1] += ` ${w}`;
        else arr.push(`${tab}${w}`);
        return arr;
      }, [tab]).join("\n")).join("\n");
    };
  }
});

// node_modules/prompts/lib/util/entriesToDisplay.js
var require_entriesToDisplay2 = __commonJS({
  "node_modules/prompts/lib/util/entriesToDisplay.js"(exports2, module2) {
    "use strict";
    module2.exports = (cursor, total, maxVisible) => {
      maxVisible = maxVisible || total;
      let startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
      if (startIndex < 0) startIndex = 0;
      let endIndex = Math.min(startIndex + maxVisible, total);
      return { startIndex, endIndex };
    };
  }
});

// node_modules/prompts/lib/util/index.js
var require_util3 = __commonJS({
  "node_modules/prompts/lib/util/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      action: require_action2(),
      clear: require_clear2(),
      style: require_style2(),
      strip: require_strip2(),
      figures: require_figures2(),
      lines: require_lines2(),
      wrap: require_wrap2(),
      entriesToDisplay: require_entriesToDisplay2()
    };
  }
});

// node_modules/prompts/lib/elements/prompt.js
var require_prompt2 = __commonJS({
  "node_modules/prompts/lib/elements/prompt.js"(exports2, module2) {
    "use strict";
    var readline = require("readline");
    var { action } = require_util3();
    var EventEmitter2 = require("events");
    var { beep, cursor } = require_src();
    var color = require_kleur();
    var Prompt = class extends EventEmitter2 {
      constructor(opts = {}) {
        super();
        this.firstRender = true;
        this.in = opts.stdin || process.stdin;
        this.out = opts.stdout || process.stdout;
        this.onRender = (opts.onRender || (() => void 0)).bind(this);
        const rl = readline.createInterface({ input: this.in, escapeCodeTimeout: 50 });
        readline.emitKeypressEvents(this.in, rl);
        if (this.in.isTTY) this.in.setRawMode(true);
        const isSelect = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1;
        const keypress = (str, key) => {
          let a = action(key, isSelect);
          if (a === false) {
            this._ && this._(str, key);
          } else if (typeof this[a] === "function") {
            this[a](key);
          } else {
            this.bell();
          }
        };
        this.close = () => {
          this.out.write(cursor.show);
          this.in.removeListener("keypress", keypress);
          if (this.in.isTTY) this.in.setRawMode(false);
          rl.close();
          this.emit(this.aborted ? "abort" : this.exited ? "exit" : "submit", this.value);
          this.closed = true;
        };
        this.in.on("keypress", keypress);
      }
      fire() {
        this.emit("state", {
          value: this.value,
          aborted: !!this.aborted,
          exited: !!this.exited
        });
      }
      bell() {
        this.out.write(beep);
      }
      render() {
        this.onRender(color);
        if (this.firstRender) this.firstRender = false;
      }
    };
    module2.exports = Prompt;
  }
});

// node_modules/prompts/lib/elements/text.js
var require_text2 = __commonJS({
  "node_modules/prompts/lib/elements/text.js"(exports2, module2) {
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { erase, cursor } = require_src();
    var { style, clear, lines, figures } = require_util3();
    var TextPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.transform = style.render(opts.style);
        this.scale = this.transform.scale;
        this.msg = opts.message;
        this.initial = opts.initial || ``;
        this.validator = opts.validate || (() => true);
        this.value = ``;
        this.errorMsg = opts.error || `Please Enter A Valid Value`;
        this.cursor = Number(!!this.initial);
        this.cursorOffset = 0;
        this.clear = clear(``, this.out.columns);
        this.render();
      }
      set value(v) {
        if (!v && this.initial) {
          this.placeholder = true;
          this.rendered = color.gray(this.transform.render(this.initial));
        } else {
          this.placeholder = false;
          this.rendered = this.transform.render(v);
        }
        this._value = v;
        this.fire();
      }
      get value() {
        return this._value;
      }
      reset() {
        this.value = ``;
        this.cursor = Number(!!this.initial);
        this.cursorOffset = 0;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.value = this.value || this.initial;
        this.done = this.aborted = true;
        this.error = false;
        this.red = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      async validate() {
        let valid = await this.validator(this.value);
        if (typeof valid === `string`) {
          this.errorMsg = valid;
          valid = false;
        }
        this.error = !valid;
      }
      async submit() {
        this.value = this.value || this.initial;
        this.cursorOffset = 0;
        this.cursor = this.rendered.length;
        await this.validate();
        if (this.error) {
          this.red = true;
          this.fire();
          this.render();
          return;
        }
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      next() {
        if (!this.placeholder) return this.bell();
        this.value = this.initial;
        this.cursor = this.rendered.length;
        this.fire();
        this.render();
      }
      moveCursor(n) {
        if (this.placeholder) return;
        this.cursor = this.cursor + n;
        this.cursorOffset += n;
      }
      _(c, key) {
        let s1 = this.value.slice(0, this.cursor);
        let s2 = this.value.slice(this.cursor);
        this.value = `${s1}${c}${s2}`;
        this.red = false;
        this.cursor = this.placeholder ? 0 : s1.length + 1;
        this.render();
      }
      delete() {
        if (this.isCursorAtStart()) return this.bell();
        let s1 = this.value.slice(0, this.cursor - 1);
        let s2 = this.value.slice(this.cursor);
        this.value = `${s1}${s2}`;
        this.red = false;
        if (this.isCursorAtStart()) {
          this.cursorOffset = 0;
        } else {
          this.cursorOffset++;
          this.moveCursor(-1);
        }
        this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
        let s1 = this.value.slice(0, this.cursor);
        let s2 = this.value.slice(this.cursor + 1);
        this.value = `${s1}${s2}`;
        this.red = false;
        if (this.isCursorAtEnd()) {
          this.cursorOffset = 0;
        } else {
          this.cursorOffset++;
        }
        this.render();
      }
      first() {
        this.cursor = 0;
        this.render();
      }
      last() {
        this.cursor = this.value.length;
        this.render();
      }
      left() {
        if (this.cursor <= 0 || this.placeholder) return this.bell();
        this.moveCursor(-1);
        this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
        this.moveCursor(1);
        this.render();
      }
      isCursorAtStart() {
        return this.cursor === 0 || this.placeholder && this.cursor === 1;
      }
      isCursorAtEnd() {
        return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
      }
      render() {
        if (this.closed) return;
        if (!this.firstRender) {
          if (this.outputError)
            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
          this.out.write(clear(this.outputText, this.out.columns));
        }
        super.render();
        this.outputError = "";
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          this.red ? color.red(this.rendered) : this.rendered
        ].join(` `);
        if (this.error) {
          this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
      }
    };
    module2.exports = TextPrompt;
  }
});

// node_modules/prompts/lib/elements/select.js
var require_select2 = __commonJS({
  "node_modules/prompts/lib/elements/select.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { style, clear, figures, wrap: wrap2, entriesToDisplay } = require_util3();
    var { cursor } = require_src();
    var SelectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.hint = opts.hint || "- Use arrow-keys. Return to submit.";
        this.warn = opts.warn || "- This option is disabled";
        this.cursor = opts.initial || 0;
        this.choices = opts.choices.map((ch, idx) => {
          if (typeof ch === "string")
            ch = { title: ch, value: idx };
          return {
            title: ch && (ch.title || ch.value || ch),
            value: ch && (ch.value === void 0 ? idx : ch.value),
            description: ch && ch.description,
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        });
        this.optionsPerPage = opts.optionsPerPage || 10;
        this.value = (this.choices[this.cursor] || {}).value;
        this.clear = clear("", this.out.columns);
        this.render();
      }
      moveCursor(n) {
        this.cursor = n;
        this.value = this.choices[n].value;
        this.fire();
      }
      reset() {
        this.moveCursor(0);
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        if (!this.selection.disabled) {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        } else
          this.bell();
      }
      first() {
        this.moveCursor(0);
        this.render();
      }
      last() {
        this.moveCursor(this.choices.length - 1);
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.moveCursor(this.choices.length - 1);
        } else {
          this.moveCursor(this.cursor - 1);
        }
        this.render();
      }
      down() {
        if (this.cursor === this.choices.length - 1) {
          this.moveCursor(0);
        } else {
          this.moveCursor(this.cursor + 1);
        }
        this.render();
      }
      next() {
        this.moveCursor((this.cursor + 1) % this.choices.length);
        this.render();
      }
      _(c, key) {
        if (c === " ") return this.submit();
      }
      get selection() {
        return this.choices[this.cursor];
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        else this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        let { startIndex, endIndex } = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage);
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(false),
          this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)
        ].join(" ");
        if (!this.done) {
          this.outputText += "\n";
          for (let i = startIndex; i < endIndex; i++) {
            let title2, prefix, desc = "", v = this.choices[i];
            if (i === startIndex && startIndex > 0) {
              prefix = figures.arrowUp;
            } else if (i === endIndex - 1 && endIndex < this.choices.length) {
              prefix = figures.arrowDown;
            } else {
              prefix = " ";
            }
            if (v.disabled) {
              title2 = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
              prefix = (this.cursor === i ? color.bold().gray(figures.pointer) + " " : "  ") + prefix;
            } else {
              title2 = this.cursor === i ? color.cyan().underline(v.title) : v.title;
              prefix = (this.cursor === i ? color.cyan(figures.pointer) + " " : "  ") + prefix;
              if (v.description && this.cursor === i) {
                desc = ` - ${v.description}`;
                if (prefix.length + title2.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                  desc = "\n" + wrap2(v.description, { margin: 3, width: this.out.columns });
                }
              }
            }
            this.outputText += `${prefix} ${title2}${color.gray(desc)}
`;
          }
        }
        this.out.write(this.outputText);
      }
    };
    module2.exports = SelectPrompt;
  }
});

// node_modules/prompts/lib/elements/toggle.js
var require_toggle2 = __commonJS({
  "node_modules/prompts/lib/elements/toggle.js"(exports2, module2) {
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { style, clear } = require_util3();
    var { cursor, erase } = require_src();
    var TogglePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.value = !!opts.initial;
        this.active = opts.active || "on";
        this.inactive = opts.inactive || "off";
        this.initialValue = this.value;
        this.render();
      }
      reset() {
        this.value = this.initialValue;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      deactivate() {
        if (this.value === false) return this.bell();
        this.value = false;
        this.render();
      }
      activate() {
        if (this.value === true) return this.bell();
        this.value = true;
        this.render();
      }
      delete() {
        this.deactivate();
      }
      left() {
        this.deactivate();
      }
      right() {
        this.activate();
      }
      down() {
        this.deactivate();
      }
      up() {
        this.activate();
      }
      next() {
        this.value = !this.value;
        this.fire();
        this.render();
      }
      _(c, key) {
        if (c === " ") {
          this.value = !this.value;
        } else if (c === "1") {
          this.value = true;
        } else if (c === "0") {
          this.value = false;
        } else return this.bell();
        this.render();
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        else this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          this.value ? this.inactive : color.cyan().underline(this.inactive),
          color.gray("/"),
          this.value ? color.cyan().underline(this.active) : this.active
        ].join(" ");
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = TogglePrompt;
  }
});

// node_modules/prompts/lib/dateparts/datepart.js
var require_datepart2 = __commonJS({
  "node_modules/prompts/lib/dateparts/datepart.js"(exports2, module2) {
    "use strict";
    var DatePart = class _DatePart {
      constructor({ token, date, parts, locales }) {
        this.token = token;
        this.date = date || /* @__PURE__ */ new Date();
        this.parts = parts || [this];
        this.locales = locales || {};
      }
      up() {
      }
      down() {
      }
      next() {
        const currentIdx = this.parts.indexOf(this);
        return this.parts.find((part, idx) => idx > currentIdx && part instanceof _DatePart);
      }
      setTo(val) {
      }
      prev() {
        let parts = [].concat(this.parts).reverse();
        const currentIdx = parts.indexOf(this);
        return parts.find((part, idx) => idx > currentIdx && part instanceof _DatePart);
      }
      toString() {
        return String(this.date);
      }
    };
    module2.exports = DatePart;
  }
});

// node_modules/prompts/lib/dateparts/meridiem.js
var require_meridiem2 = __commonJS({
  "node_modules/prompts/lib/dateparts/meridiem.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Meridiem = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours((this.date.getHours() + 12) % 24);
      }
      down() {
        this.up();
      }
      toString() {
        let meridiem = this.date.getHours() > 12 ? "pm" : "am";
        return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
      }
    };
    module2.exports = Meridiem;
  }
});

// node_modules/prompts/lib/dateparts/day.js
var require_day2 = __commonJS({
  "node_modules/prompts/lib/dateparts/day.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var pos = (n) => {
      n = n % 10;
      return n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
    };
    var Day = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setDate(this.date.getDate() + 1);
      }
      down() {
        this.date.setDate(this.date.getDate() - 1);
      }
      setTo(val) {
        this.date.setDate(parseInt(val.substr(-2)));
      }
      toString() {
        let date = this.date.getDate();
        let day = this.date.getDay();
        return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
      }
    };
    module2.exports = Day;
  }
});

// node_modules/prompts/lib/dateparts/hours.js
var require_hours2 = __commonJS({
  "node_modules/prompts/lib/dateparts/hours.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Hours = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours(this.date.getHours() + 1);
      }
      down() {
        this.date.setHours(this.date.getHours() - 1);
      }
      setTo(val) {
        this.date.setHours(parseInt(val.substr(-2)));
      }
      toString() {
        let hours = this.date.getHours();
        if (/h/.test(this.token))
          hours = hours % 12 || 12;
        return this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
      }
    };
    module2.exports = Hours;
  }
});

// node_modules/prompts/lib/dateparts/milliseconds.js
var require_milliseconds2 = __commonJS({
  "node_modules/prompts/lib/dateparts/milliseconds.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Milliseconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMilliseconds(this.date.getMilliseconds() + 1);
      }
      down() {
        this.date.setMilliseconds(this.date.getMilliseconds() - 1);
      }
      setTo(val) {
        this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
      }
      toString() {
        return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
      }
    };
    module2.exports = Milliseconds;
  }
});

// node_modules/prompts/lib/dateparts/minutes.js
var require_minutes2 = __commonJS({
  "node_modules/prompts/lib/dateparts/minutes.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Minutes = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMinutes(this.date.getMinutes() + 1);
      }
      down() {
        this.date.setMinutes(this.date.getMinutes() - 1);
      }
      setTo(val) {
        this.date.setMinutes(parseInt(val.substr(-2)));
      }
      toString() {
        let m = this.date.getMinutes();
        return this.token.length > 1 ? String(m).padStart(2, "0") : m;
      }
    };
    module2.exports = Minutes;
  }
});

// node_modules/prompts/lib/dateparts/month.js
var require_month2 = __commonJS({
  "node_modules/prompts/lib/dateparts/month.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Month = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMonth(this.date.getMonth() + 1);
      }
      down() {
        this.date.setMonth(this.date.getMonth() - 1);
      }
      setTo(val) {
        val = parseInt(val.substr(-2)) - 1;
        this.date.setMonth(val < 0 ? 0 : val);
      }
      toString() {
        let month = this.date.getMonth();
        let tl = this.token.length;
        return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
      }
    };
    module2.exports = Month;
  }
});

// node_modules/prompts/lib/dateparts/seconds.js
var require_seconds2 = __commonJS({
  "node_modules/prompts/lib/dateparts/seconds.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Seconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setSeconds(this.date.getSeconds() + 1);
      }
      down() {
        this.date.setSeconds(this.date.getSeconds() - 1);
      }
      setTo(val) {
        this.date.setSeconds(parseInt(val.substr(-2)));
      }
      toString() {
        let s = this.date.getSeconds();
        return this.token.length > 1 ? String(s).padStart(2, "0") : s;
      }
    };
    module2.exports = Seconds;
  }
});

// node_modules/prompts/lib/dateparts/year.js
var require_year2 = __commonJS({
  "node_modules/prompts/lib/dateparts/year.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2();
    var Year = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setFullYear(this.date.getFullYear() + 1);
      }
      down() {
        this.date.setFullYear(this.date.getFullYear() - 1);
      }
      setTo(val) {
        this.date.setFullYear(val.substr(-4));
      }
      toString() {
        let year = String(this.date.getFullYear()).padStart(4, "0");
        return this.token.length === 2 ? year.substr(-2) : year;
      }
    };
    module2.exports = Year;
  }
});

// node_modules/prompts/lib/dateparts/index.js
var require_dateparts2 = __commonJS({
  "node_modules/prompts/lib/dateparts/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      DatePart: require_datepart2(),
      Meridiem: require_meridiem2(),
      Day: require_day2(),
      Hours: require_hours2(),
      Milliseconds: require_milliseconds2(),
      Minutes: require_minutes2(),
      Month: require_month2(),
      Seconds: require_seconds2(),
      Year: require_year2()
    };
  }
});

// node_modules/prompts/lib/elements/date.js
var require_date2 = __commonJS({
  "node_modules/prompts/lib/elements/date.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { style, clear, figures } = require_util3();
    var { erase, cursor } = require_src();
    var { DatePart, Meridiem, Day, Hours, Milliseconds, Minutes, Month, Seconds, Year } = require_dateparts2();
    var regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
    var regexGroups = {
      1: ({ token }) => token.replace(/\\(.)/g, "$1"),
      2: (opts) => new Day(opts),
      // Day // TODO
      3: (opts) => new Month(opts),
      // Month
      4: (opts) => new Year(opts),
      // Year
      5: (opts) => new Meridiem(opts),
      // AM/PM // TODO (special)
      6: (opts) => new Hours(opts),
      // Hours
      7: (opts) => new Minutes(opts),
      // Minutes
      8: (opts) => new Seconds(opts),
      // Seconds
      9: (opts) => new Milliseconds(opts)
      // Fractional seconds
    };
    var dfltLocales = {
      months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
      monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
      weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
      weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
    };
    var DatePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.cursor = 0;
        this.typed = "";
        this.locales = Object.assign(dfltLocales, opts.locales);
        this._date = opts.initial || /* @__PURE__ */ new Date();
        this.errorMsg = opts.error || "Please Enter A Valid Value";
        this.validator = opts.validate || (() => true);
        this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss";
        this.clear = clear("", this.out.columns);
        this.render();
      }
      get value() {
        return this.date;
      }
      get date() {
        return this._date;
      }
      set date(date) {
        if (date) this._date.setTime(date.getTime());
      }
      set mask(mask) {
        let result;
        this.parts = [];
        while (result = regex.exec(mask)) {
          let match2 = result.shift();
          let idx = result.findIndex((gr) => gr != null);
          this.parts.push(idx in regexGroups ? regexGroups[idx]({ token: result[idx] || match2, date: this.date, parts: this.parts, locales: this.locales }) : result[idx] || match2);
        }
        let parts = this.parts.reduce((arr, i) => {
          if (typeof i === "string" && typeof arr[arr.length - 1] === "string")
            arr[arr.length - 1] += i;
          else arr.push(i);
          return arr;
        }, []);
        this.parts.splice(0);
        this.parts.push(...parts);
        this.reset();
      }
      moveCursor(n) {
        this.typed = "";
        this.cursor = n;
        this.fire();
      }
      reset() {
        this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart));
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.error = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      async validate() {
        let valid = await this.validator(this.value);
        if (typeof valid === "string") {
          this.errorMsg = valid;
          valid = false;
        }
        this.error = !valid;
      }
      async submit() {
        await this.validate();
        if (this.error) {
          this.color = "red";
          this.fire();
          this.render();
          return;
        }
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      up() {
        this.typed = "";
        this.parts[this.cursor].up();
        this.render();
      }
      down() {
        this.typed = "";
        this.parts[this.cursor].down();
        this.render();
      }
      left() {
        let prev = this.parts[this.cursor].prev();
        if (prev == null) return this.bell();
        this.moveCursor(this.parts.indexOf(prev));
        this.render();
      }
      right() {
        let next = this.parts[this.cursor].next();
        if (next == null) return this.bell();
        this.moveCursor(this.parts.indexOf(next));
        this.render();
      }
      next() {
        let next = this.parts[this.cursor].next();
        this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart));
        this.render();
      }
      _(c) {
        if (/\d/.test(c)) {
          this.typed += c;
          this.parts[this.cursor].setTo(this.typed);
          this.render();
        }
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        else this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(false),
          this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")
        ].join(" ");
        if (this.error) {
          this.outputText += this.errorMsg.split("\n").reduce(
            (a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`,
            ``
          );
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = DatePrompt;
  }
});

// node_modules/prompts/lib/elements/number.js
var require_number2 = __commonJS({
  "node_modules/prompts/lib/elements/number.js"(exports2, module2) {
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { cursor, erase } = require_src();
    var { style, figures, clear, lines } = require_util3();
    var isNumber = /[0-9]/;
    var isDef = (any) => any !== void 0;
    var round = (number, precision) => {
      let factor = Math.pow(10, precision);
      return Math.round(number * factor) / factor;
    };
    var NumberPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.transform = style.render(opts.style);
        this.msg = opts.message;
        this.initial = isDef(opts.initial) ? opts.initial : "";
        this.float = !!opts.float;
        this.round = opts.round || 2;
        this.inc = opts.increment || 1;
        this.min = isDef(opts.min) ? opts.min : -Infinity;
        this.max = isDef(opts.max) ? opts.max : Infinity;
        this.errorMsg = opts.error || `Please Enter A Valid Value`;
        this.validator = opts.validate || (() => true);
        this.color = `cyan`;
        this.value = ``;
        this.typed = ``;
        this.lastHit = 0;
        this.render();
      }
      set value(v) {
        if (!v && v !== 0) {
          this.placeholder = true;
          this.rendered = color.gray(this.transform.render(`${this.initial}`));
          this._value = ``;
        } else {
          this.placeholder = false;
          this.rendered = this.transform.render(`${round(v, this.round)}`);
          this._value = round(v, this.round);
        }
        this.fire();
      }
      get value() {
        return this._value;
      }
      parse(x) {
        return this.float ? parseFloat(x) : parseInt(x);
      }
      valid(c) {
        return c === `-` || c === `.` && this.float || isNumber.test(c);
      }
      reset() {
        this.typed = ``;
        this.value = ``;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        let x = this.value;
        this.value = x !== `` ? x : this.initial;
        this.done = this.aborted = true;
        this.error = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      }
      async validate() {
        let valid = await this.validator(this.value);
        if (typeof valid === `string`) {
          this.errorMsg = valid;
          valid = false;
        }
        this.error = !valid;
      }
      async submit() {
        await this.validate();
        if (this.error) {
          this.color = `red`;
          this.fire();
          this.render();
          return;
        }
        let x = this.value;
        this.value = x !== `` ? x : this.initial;
        this.done = true;
        this.aborted = false;
        this.error = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      }
      up() {
        this.typed = ``;
        if (this.value === "") {
          this.value = this.min - this.inc;
        }
        if (this.value >= this.max) return this.bell();
        this.value += this.inc;
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      down() {
        this.typed = ``;
        if (this.value === "") {
          this.value = this.min + this.inc;
        }
        if (this.value <= this.min) return this.bell();
        this.value -= this.inc;
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      delete() {
        let val = this.value.toString();
        if (val.length === 0) return this.bell();
        this.value = this.parse(val = val.slice(0, -1)) || ``;
        if (this.value !== "" && this.value < this.min) {
          this.value = this.min;
        }
        this.color = `cyan`;
        this.fire();
        this.render();
      }
      next() {
        this.value = this.initial;
        this.fire();
        this.render();
      }
      _(c, key) {
        if (!this.valid(c)) return this.bell();
        const now = Date.now();
        if (now - this.lastHit > 1e3) this.typed = ``;
        this.typed += c;
        this.lastHit = now;
        this.color = `cyan`;
        if (c === `.`) return this.fire();
        this.value = Math.min(this.parse(this.typed), this.max);
        if (this.value > this.max) this.value = this.max;
        if (this.value < this.min) this.value = this.min;
        this.fire();
        this.render();
      }
      render() {
        if (this.closed) return;
        if (!this.firstRender) {
          if (this.outputError)
            this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
          this.out.write(clear(this.outputText, this.out.columns));
        }
        super.render();
        this.outputError = "";
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered
        ].join(` `);
        if (this.error) {
          this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
      }
    };
    module2.exports = NumberPrompt;
  }
});

// node_modules/prompts/lib/elements/multiselect.js
var require_multiselect2 = __commonJS({
  "node_modules/prompts/lib/elements/multiselect.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var { cursor } = require_src();
    var Prompt = require_prompt2();
    var { clear, figures, style, wrap: wrap2, entriesToDisplay } = require_util3();
    var MultiselectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.cursor = opts.cursor || 0;
        this.scrollIndex = opts.cursor || 0;
        this.hint = opts.hint || "";
        this.warn = opts.warn || "- This option is disabled -";
        this.minSelected = opts.min;
        this.showMinError = false;
        this.maxChoices = opts.max;
        this.instructions = opts.instructions;
        this.optionsPerPage = opts.optionsPerPage || 10;
        this.value = opts.choices.map((ch, idx) => {
          if (typeof ch === "string")
            ch = { title: ch, value: idx };
          return {
            title: ch && (ch.title || ch.value || ch),
            description: ch && ch.description,
            value: ch && (ch.value === void 0 ? idx : ch.value),
            selected: ch && ch.selected,
            disabled: ch && ch.disabled
          };
        });
        this.clear = clear("", this.out.columns);
        if (!opts.overrideRender) {
          this.render();
        }
      }
      reset() {
        this.value.map((v) => !v.selected);
        this.cursor = 0;
        this.fire();
        this.render();
      }
      selected() {
        return this.value.filter((v) => v.selected);
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        const selected = this.value.filter((e) => e.selected);
        if (this.minSelected && selected.length < this.minSelected) {
          this.showMinError = true;
          this.render();
        } else {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
      }
      first() {
        this.cursor = 0;
        this.render();
      }
      last() {
        this.cursor = this.value.length - 1;
        this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.value.length;
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.cursor = this.value.length - 1;
        } else {
          this.cursor--;
        }
        this.render();
      }
      down() {
        if (this.cursor === this.value.length - 1) {
          this.cursor = 0;
        } else {
          this.cursor++;
        }
        this.render();
      }
      left() {
        this.value[this.cursor].selected = false;
        this.render();
      }
      right() {
        if (this.value.filter((e) => e.selected).length >= this.maxChoices) return this.bell();
        this.value[this.cursor].selected = true;
        this.render();
      }
      handleSpaceToggle() {
        const v = this.value[this.cursor];
        if (v.selected) {
          v.selected = false;
          this.render();
        } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
          return this.bell();
        } else {
          v.selected = true;
          this.render();
        }
      }
      toggleAll() {
        if (this.maxChoices !== void 0 || this.value[this.cursor].disabled) {
          return this.bell();
        }
        const newSelected = !this.value[this.cursor].selected;
        this.value.filter((v) => !v.disabled).forEach((v) => v.selected = newSelected);
        this.render();
      }
      _(c, key) {
        if (c === " ") {
          this.handleSpaceToggle();
        } else if (c === "a") {
          this.toggleAll();
        } else {
          return this.bell();
        }
      }
      renderInstructions() {
        if (this.instructions === void 0 || this.instructions) {
          if (typeof this.instructions === "string") {
            return this.instructions;
          }
          return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + `    enter/return: Complete answer`;
        }
        return "";
      }
      renderOption(cursor2, v, i, arrowIndicator) {
        const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + " " + arrowIndicator + " ";
        let title2, desc;
        if (v.disabled) {
          title2 = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
        } else {
          title2 = cursor2 === i ? color.cyan().underline(v.title) : v.title;
          if (cursor2 === i && v.description) {
            desc = ` - ${v.description}`;
            if (prefix.length + title2.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
              desc = "\n" + wrap2(v.description, { margin: prefix.length, width: this.out.columns });
            }
          }
        }
        return prefix + title2 + color.gray(desc || "");
      }
      // shared with autocompleteMultiselect
      paginateOptions(options) {
        if (options.length === 0) {
          return color.red("No matches for this query.");
        }
        let { startIndex, endIndex } = entriesToDisplay(this.cursor, options.length, this.optionsPerPage);
        let prefix, styledOptions = [];
        for (let i = startIndex; i < endIndex; i++) {
          if (i === startIndex && startIndex > 0) {
            prefix = figures.arrowUp;
          } else if (i === endIndex - 1 && endIndex < options.length) {
            prefix = figures.arrowDown;
          } else {
            prefix = " ";
          }
          styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
        }
        return "\n" + styledOptions.join("\n");
      }
      // shared with autocomleteMultiselect
      renderOptions(options) {
        if (!this.done) {
          return this.paginateOptions(options);
        }
        return "";
      }
      renderDoneOrInstructions() {
        if (this.done) {
          return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
        }
        const output = [color.gray(this.hint), this.renderInstructions()];
        if (this.value[this.cursor].disabled) {
          output.push(color.yellow(this.warn));
        }
        return output.join(" ");
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        super.render();
        let prompt = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(false),
          this.renderDoneOrInstructions()
        ].join(" ");
        if (this.showMinError) {
          prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
          this.showMinError = false;
        }
        prompt += this.renderOptions(this.value);
        this.out.write(this.clear + prompt);
        this.clear = clear(prompt, this.out.columns);
      }
    };
    module2.exports = MultiselectPrompt;
  }
});

// node_modules/prompts/lib/elements/autocomplete.js
var require_autocomplete2 = __commonJS({
  "node_modules/prompts/lib/elements/autocomplete.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { erase, cursor } = require_src();
    var { style, clear, figures, wrap: wrap2, entriesToDisplay } = require_util3();
    var getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);
    var getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);
    var getIndex = (arr, valOrTitle) => {
      const index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
      return index > -1 ? index : void 0;
    };
    var AutocompletePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.suggest = opts.suggest;
        this.choices = opts.choices;
        this.initial = typeof opts.initial === "number" ? opts.initial : getIndex(opts.choices, opts.initial);
        this.select = this.initial || opts.cursor || 0;
        this.i18n = { noMatches: opts.noMatches || "no matches found" };
        this.fallback = opts.fallback || this.initial;
        this.clearFirst = opts.clearFirst || false;
        this.suggestions = [];
        this.input = "";
        this.limit = opts.limit || 10;
        this.cursor = 0;
        this.transform = style.render(opts.style);
        this.scale = this.transform.scale;
        this.render = this.render.bind(this);
        this.complete = this.complete.bind(this);
        this.clear = clear("", this.out.columns);
        this.complete(this.render);
        this.render();
      }
      set fallback(fb) {
        this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
      }
      get fallback() {
        let choice;
        if (typeof this._fb === "number")
          choice = this.choices[this._fb];
        else if (typeof this._fb === "string")
          choice = { title: this._fb };
        return choice || this._fb || { title: this.i18n.noMatches };
      }
      moveSelect(i) {
        this.select = i;
        if (this.suggestions.length > 0)
          this.value = getVal(this.suggestions, i);
        else this.value = this.fallback.value;
        this.fire();
      }
      async complete(cb) {
        const p = this.completing = this.suggest(this.input, this.choices);
        const suggestions = await p;
        if (this.completing !== p) return;
        this.suggestions = suggestions.map((s, i, arr) => ({ title: getTitle(arr, i), value: getVal(arr, i), description: s.description }));
        this.completing = false;
        const l = Math.max(suggestions.length - 1, 0);
        this.moveSelect(Math.min(l, this.select));
        cb && cb();
      }
      reset() {
        this.input = "";
        this.complete(() => {
          this.moveSelect(this.initial !== void 0 ? this.initial : 0);
          this.render();
        });
        this.render();
      }
      exit() {
        if (this.clearFirst && this.input.length > 0) {
          this.reset();
        } else {
          this.done = this.exited = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
      }
      abort() {
        this.done = this.aborted = true;
        this.exited = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.done = true;
        this.aborted = this.exited = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      _(c, key) {
        let s1 = this.input.slice(0, this.cursor);
        let s2 = this.input.slice(this.cursor);
        this.input = `${s1}${c}${s2}`;
        this.cursor = s1.length + 1;
        this.complete(this.render);
        this.render();
      }
      delete() {
        if (this.cursor === 0) return this.bell();
        let s1 = this.input.slice(0, this.cursor - 1);
        let s2 = this.input.slice(this.cursor);
        this.input = `${s1}${s2}`;
        this.complete(this.render);
        this.cursor = this.cursor - 1;
        this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length) return this.bell();
        let s1 = this.input.slice(0, this.cursor);
        let s2 = this.input.slice(this.cursor + 1);
        this.input = `${s1}${s2}`;
        this.complete(this.render);
        this.render();
      }
      first() {
        this.moveSelect(0);
        this.render();
      }
      last() {
        this.moveSelect(this.suggestions.length - 1);
        this.render();
      }
      up() {
        if (this.select === 0) {
          this.moveSelect(this.suggestions.length - 1);
        } else {
          this.moveSelect(this.select - 1);
        }
        this.render();
      }
      down() {
        if (this.select === this.suggestions.length - 1) {
          this.moveSelect(0);
        } else {
          this.moveSelect(this.select + 1);
        }
        this.render();
      }
      next() {
        if (this.select === this.suggestions.length - 1) {
          this.moveSelect(0);
        } else this.moveSelect(this.select + 1);
        this.render();
      }
      nextPage() {
        this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
        this.render();
      }
      prevPage() {
        this.moveSelect(Math.max(this.select - this.limit, 0));
        this.render();
      }
      left() {
        if (this.cursor <= 0) return this.bell();
        this.cursor = this.cursor - 1;
        this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length) return this.bell();
        this.cursor = this.cursor + 1;
        this.render();
      }
      renderOption(v, hovered, isStart, isEnd) {
        let desc;
        let prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : " ";
        let title2 = hovered ? color.cyan().underline(v.title) : v.title;
        prefix = (hovered ? color.cyan(figures.pointer) + " " : "  ") + prefix;
        if (v.description) {
          desc = ` - ${v.description}`;
          if (prefix.length + title2.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
            desc = "\n" + wrap2(v.description, { margin: 3, width: this.out.columns });
          }
        }
        return prefix + " " + title2 + color.gray(desc || "");
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        else this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        let { startIndex, endIndex } = entriesToDisplay(this.select, this.choices.length, this.limit);
        this.outputText = [
          style.symbol(this.done, this.aborted, this.exited),
          color.bold(this.msg),
          style.delimiter(this.completing),
          this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)
        ].join(" ");
        if (!this.done) {
          const suggestions = this.suggestions.slice(startIndex, endIndex).map((item, i) => this.renderOption(
            item,
            this.select === i + startIndex,
            i === 0 && startIndex > 0,
            i + startIndex === endIndex - 1 && endIndex < this.choices.length
          )).join("\n");
          this.outputText += `
` + (suggestions || color.gray(this.fallback.title));
        }
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = AutocompletePrompt;
  }
});

// node_modules/prompts/lib/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect2 = __commonJS({
  "node_modules/prompts/lib/elements/autocompleteMultiselect.js"(exports2, module2) {
    "use strict";
    var color = require_kleur();
    var { cursor } = require_src();
    var MultiselectPrompt = require_multiselect2();
    var { clear, style, figures } = require_util3();
    var AutocompleteMultiselectPrompt = class extends MultiselectPrompt {
      constructor(opts = {}) {
        opts.overrideRender = true;
        super(opts);
        this.inputValue = "";
        this.clear = clear("", this.out.columns);
        this.filteredOptions = this.value;
        this.render();
      }
      last() {
        this.cursor = this.filteredOptions.length - 1;
        this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.filteredOptions.length;
        this.render();
      }
      up() {
        if (this.cursor === 0) {
          this.cursor = this.filteredOptions.length - 1;
        } else {
          this.cursor--;
        }
        this.render();
      }
      down() {
        if (this.cursor === this.filteredOptions.length - 1) {
          this.cursor = 0;
        } else {
          this.cursor++;
        }
        this.render();
      }
      left() {
        this.filteredOptions[this.cursor].selected = false;
        this.render();
      }
      right() {
        if (this.value.filter((e) => e.selected).length >= this.maxChoices) return this.bell();
        this.filteredOptions[this.cursor].selected = true;
        this.render();
      }
      delete() {
        if (this.inputValue.length) {
          this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
          this.updateFilteredOptions();
        }
      }
      updateFilteredOptions() {
        const currentHighlight = this.filteredOptions[this.cursor];
        this.filteredOptions = this.value.filter((v) => {
          if (this.inputValue) {
            if (typeof v.title === "string") {
              if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
                return true;
              }
            }
            if (typeof v.value === "string") {
              if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
                return true;
              }
            }
            return false;
          }
          return true;
        });
        const newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
        this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
        this.render();
      }
      handleSpaceToggle() {
        const v = this.filteredOptions[this.cursor];
        if (v.selected) {
          v.selected = false;
          this.render();
        } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
          return this.bell();
        } else {
          v.selected = true;
          this.render();
        }
      }
      handleInputChange(c) {
        this.inputValue = this.inputValue + c;
        this.updateFilteredOptions();
      }
      _(c, key) {
        if (c === " ") {
          this.handleSpaceToggle();
        } else {
          this.handleInputChange(c);
        }
      }
      renderInstructions() {
        if (this.instructions === void 0 || this.instructions) {
          if (typeof this.instructions === "string") {
            return this.instructions;
          }
          return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
        }
        return "";
      }
      renderCurrentInput() {
        return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
      }
      renderOption(cursor2, v, i) {
        let title2;
        if (v.disabled) title2 = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
        else title2 = cursor2 === i ? color.cyan().underline(v.title) : v.title;
        return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title2;
      }
      renderDoneOrInstructions() {
        if (this.done) {
          return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
        }
        const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
        if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
          output.push(color.yellow(this.warn));
        }
        return output.join(" ");
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        super.render();
        let prompt = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(false),
          this.renderDoneOrInstructions()
        ].join(" ");
        if (this.showMinError) {
          prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
          this.showMinError = false;
        }
        prompt += this.renderOptions(this.filteredOptions);
        this.out.write(this.clear + prompt);
        this.clear = clear(prompt, this.out.columns);
      }
    };
    module2.exports = AutocompleteMultiselectPrompt;
  }
});

// node_modules/prompts/lib/elements/confirm.js
var require_confirm2 = __commonJS({
  "node_modules/prompts/lib/elements/confirm.js"(exports2, module2) {
    var color = require_kleur();
    var Prompt = require_prompt2();
    var { style, clear } = require_util3();
    var { erase, cursor } = require_src();
    var ConfirmPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts);
        this.msg = opts.message;
        this.value = opts.initial;
        this.initialValue = !!opts.initial;
        this.yesMsg = opts.yes || "yes";
        this.yesOption = opts.yesOption || "(Y/n)";
        this.noMsg = opts.no || "no";
        this.noOption = opts.noOption || "(y/N)";
        this.render();
      }
      reset() {
        this.value = this.initialValue;
        this.fire();
        this.render();
      }
      exit() {
        this.abort();
      }
      abort() {
        this.done = this.aborted = true;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      submit() {
        this.value = this.value || false;
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write("\n");
        this.close();
      }
      _(c, key) {
        if (c.toLowerCase() === "y") {
          this.value = true;
          return this.submit();
        }
        if (c.toLowerCase() === "n") {
          this.value = false;
          return this.submit();
        }
        return this.bell();
      }
      render() {
        if (this.closed) return;
        if (this.firstRender) this.out.write(cursor.hide);
        else this.out.write(clear(this.outputText, this.out.columns));
        super.render();
        this.outputText = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)
        ].join(" ");
        this.out.write(erase.line + cursor.to(0) + this.outputText);
      }
    };
    module2.exports = ConfirmPrompt;
  }
});

// node_modules/prompts/lib/elements/index.js
var require_elements2 = __commonJS({
  "node_modules/prompts/lib/elements/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      TextPrompt: require_text2(),
      SelectPrompt: require_select2(),
      TogglePrompt: require_toggle2(),
      DatePrompt: require_date2(),
      NumberPrompt: require_number2(),
      MultiselectPrompt: require_multiselect2(),
      AutocompletePrompt: require_autocomplete2(),
      AutocompleteMultiselectPrompt: require_autocompleteMultiselect2(),
      ConfirmPrompt: require_confirm2()
    };
  }
});

// node_modules/prompts/lib/prompts.js
var require_prompts2 = __commonJS({
  "node_modules/prompts/lib/prompts.js"(exports2) {
    "use strict";
    var $3 = exports2;
    var el = require_elements2();
    var noop = (v) => v;
    function toPrompt(type2, args, opts = {}) {
      return new Promise((res, rej) => {
        const p = new el[type2](args);
        const onAbort = opts.onAbort || noop;
        const onSubmit = opts.onSubmit || noop;
        const onExit = opts.onExit || noop;
        p.on("state", args.onState || noop);
        p.on("submit", (x) => res(onSubmit(x)));
        p.on("exit", (x) => res(onExit(x)));
        p.on("abort", (x) => rej(onAbort(x)));
      });
    }
    $3.text = (args) => toPrompt("TextPrompt", args);
    $3.password = (args) => {
      args.style = "password";
      return $3.text(args);
    };
    $3.invisible = (args) => {
      args.style = "invisible";
      return $3.text(args);
    };
    $3.number = (args) => toPrompt("NumberPrompt", args);
    $3.date = (args) => toPrompt("DatePrompt", args);
    $3.confirm = (args) => toPrompt("ConfirmPrompt", args);
    $3.list = (args) => {
      const sep2 = args.separator || ",";
      return toPrompt("TextPrompt", args, {
        onSubmit: (str) => str.split(sep2).map((s) => s.trim())
      });
    };
    $3.toggle = (args) => toPrompt("TogglePrompt", args);
    $3.select = (args) => toPrompt("SelectPrompt", args);
    $3.multiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("MultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    $3.autocompleteMultiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("AutocompleteMultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    var byTitle = (input, choices) => Promise.resolve(
      choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase())
    );
    $3.autocomplete = (args) => {
      args.suggest = args.suggest || byTitle;
      args.choices = [].concat(args.choices || []);
      return toPrompt("AutocompletePrompt", args);
    };
  }
});

// node_modules/prompts/lib/index.js
var require_lib = __commonJS({
  "node_modules/prompts/lib/index.js"(exports2, module2) {
    "use strict";
    var prompts2 = require_prompts2();
    var passOn = ["suggest", "format", "onState", "validate", "onRender", "type"];
    var noop = () => {
    };
    async function prompt(questions = [], { onSubmit = noop, onCancel = noop } = {}) {
      const answers = {};
      const override2 = prompt._override || {};
      questions = [].concat(questions);
      let answer, question, quit, name, type2, lastPrompt;
      const getFormattedAnswer = async (question2, answer2, skipValidation = false) => {
        if (!skipValidation && question2.validate && question2.validate(answer2) !== true) {
          return;
        }
        return question2.format ? await question2.format(answer2, answers) : answer2;
      };
      for (question of questions) {
        ({ name, type: type2 } = question);
        if (typeof type2 === "function") {
          type2 = await type2(answer, { ...answers }, question);
          question["type"] = type2;
        }
        if (!type2) continue;
        for (let key in question) {
          if (passOn.includes(key)) continue;
          let value = question[key];
          question[key] = typeof value === "function" ? await value(answer, { ...answers }, lastPrompt) : value;
        }
        lastPrompt = question;
        if (typeof question.message !== "string") {
          throw new Error("prompt message is required");
        }
        ({ name, type: type2 } = question);
        if (prompts2[type2] === void 0) {
          throw new Error(`prompt type (${type2}) is not defined`);
        }
        if (override2[question.name] !== void 0) {
          answer = await getFormattedAnswer(question, override2[question.name]);
          if (answer !== void 0) {
            answers[name] = answer;
            continue;
          }
        }
        try {
          answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : await prompts2[type2](question);
          answers[name] = answer = await getFormattedAnswer(question, answer, true);
          quit = await onSubmit(question, answer, answers);
        } catch (err) {
          quit = !await onCancel(question, answers);
        }
        if (quit) return answers;
      }
      return answers;
    }
    function getInjectedAnswer(injected, deafultValue) {
      const answer = injected.shift();
      if (answer instanceof Error) {
        throw answer;
      }
      return answer === void 0 ? deafultValue : answer;
    }
    function inject(answers) {
      prompt._injected = (prompt._injected || []).concat(answers);
    }
    function override(answers) {
      prompt._override = Object.assign({}, answers);
    }
    module2.exports = Object.assign(prompt, { prompt, prompts: prompts2, inject, override });
  }
});

// node_modules/prompts/index.js
var require_prompts3 = __commonJS({
  "node_modules/prompts/index.js"(exports2, module2) {
    function isNodeLT(tar) {
      tar = (Array.isArray(tar) ? tar : tar.split(".")).map(Number);
      let i = 0, src = process.versions.node.split(".").map(Number);
      for (; i < tar.length; i++) {
        if (src[i] > tar[i]) return false;
        if (tar[i] > src[i]) return true;
      }
      return false;
    }
    module2.exports = isNodeLT("8.6.0") ? require_dist() : require_lib();
  }
});

// server/src/server.ts
var import_path = __toESM(require("path"));
var import_node_fs2 = __toESM(require("node:fs"));
var import_node = __toESM(require_node3());

// node_modules/vscode-languageserver-textdocument/lib/esm/main.js
var FullTextDocument = class _FullTextDocument {
  constructor(uri, languageId, version2, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version2;
    this._content = content;
    this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(range2) {
    if (range2) {
      const start = this.offsetAt(range2.start);
      const end = this.offsetAt(range2.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  update(changes, version2) {
    for (const change of changes) {
      if (_FullTextDocument.isIncremental(change)) {
        const range2 = getWellformedRange(change.range);
        const startOffset = this.offsetAt(range2.start);
        const endOffset = this.offsetAt(range2.end);
        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
        const startLine = Math.max(range2.start.line, 0);
        const endLine = Math.max(range2.end.line, 0);
        let lineOffsets = this._lineOffsets;
        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
        if (endLine - startLine === addedLineOffsets.length) {
          for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
            lineOffsets[i + startLine + 1] = addedLineOffsets[i];
          }
        } else {
          if (addedLineOffsets.length < 1e4) {
            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
          } else {
            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
          }
        }
        const diff = change.text.length - (endOffset - startOffset);
        if (diff !== 0) {
          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
            lineOffsets[i] = lineOffsets[i] + diff;
          }
        }
      } else if (_FullTextDocument.isFull(change)) {
        this._content = change.text;
        this._lineOffsets = void 0;
      } else {
        throw new Error("Unknown change event received");
      }
    }
    this._version = version2;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      this._lineOffsets = computeLineOffsets(this._content, true);
    }
    return this._lineOffsets;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    const lineOffsets = this.getLineOffsets();
    let low = 0, high = lineOffsets.length;
    if (high === 0) {
      return { line: 0, character: offset };
    }
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    const line = low - 1;
    offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
    return { line, character: offset - lineOffsets[line] };
  }
  offsetAt(position) {
    const lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }
    const lineOffset = lineOffsets[position.line];
    if (position.character <= 0) {
      return lineOffset;
    }
    const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    const offset = Math.min(lineOffset + position.character, nextLineOffset);
    return this.ensureBeforeEOL(offset, lineOffset);
  }
  ensureBeforeEOL(offset, lineOffset) {
    while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
      offset--;
    }
    return offset;
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(event) {
    const candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
  }
  static isFull(event) {
    const candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
  }
};
var TextDocument;
(function(TextDocument2) {
  function create(uri, languageId, version2, content) {
    return new FullTextDocument(uri, languageId, version2, content);
  }
  TextDocument2.create = create;
  function update(document, changes, version2) {
    if (document instanceof FullTextDocument) {
      document.update(changes, version2);
      return document;
    } else {
      throw new Error("TextDocument.update: document must be created by TextDocument.create");
    }
  }
  TextDocument2.update = update;
  function applyEdits(document, edits) {
    const text = document.getText();
    const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
      const diff = a.range.start.line - b.range.start.line;
      if (diff === 0) {
        return a.range.start.character - b.range.start.character;
      }
      return diff;
    });
    let lastModifiedOffset = 0;
    const spans = [];
    for (const e of sortedEdits) {
      const startOffset = document.offsetAt(e.range.start);
      if (startOffset < lastModifiedOffset) {
        throw new Error("Overlapping edit");
      } else if (startOffset > lastModifiedOffset) {
        spans.push(text.substring(lastModifiedOffset, startOffset));
      }
      if (e.newText.length) {
        spans.push(e.newText);
      }
      lastModifiedOffset = document.offsetAt(e.range.end);
    }
    spans.push(text.substr(lastModifiedOffset));
    return spans.join("");
  }
  TextDocument2.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare);
  mergeSort(right, compare);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    const ret = compare(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    const ch = text.charCodeAt(i);
    if (isEOL(ch)) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function isEOL(char) {
  return char === 13 || char === 10;
}
function getWellformedRange(range2) {
  const start = range2.start;
  const end = range2.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range2;
}
function getWellformedEdit(textEdit) {
  const range2 = getWellformedRange(textEdit.range);
  if (range2 !== textEdit.range) {
    return { newText: textEdit.newText, range: range2 };
  }
  return textEdit;
}

// node_modules/vscode-uri/lib/esm/index.mjs
var LIB;
(() => {
  "use strict";
  var t = { 975: (t2) => {
    function e2(t3) {
      if ("string" != typeof t3) throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
    }
    function r2(t3, e3) {
      for (var r3, n3 = "", i2 = 0, o2 = -1, s2 = 0, h2 = 0; h2 <= t3.length; ++h2) {
        if (h2 < t3.length) r3 = t3.charCodeAt(h2);
        else {
          if (47 === r3) break;
          r3 = 47;
        }
        if (47 === r3) {
          if (o2 === h2 - 1 || 1 === s2) ;
          else if (o2 !== h2 - 1 && 2 === s2) {
            if (n3.length < 2 || 2 !== i2 || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
              if (n3.length > 2) {
                var a2 = n3.lastIndexOf("/");
                if (a2 !== n3.length - 1) {
                  -1 === a2 ? (n3 = "", i2 = 0) : i2 = (n3 = n3.slice(0, a2)).length - 1 - n3.lastIndexOf("/"), o2 = h2, s2 = 0;
                  continue;
                }
              } else if (2 === n3.length || 1 === n3.length) {
                n3 = "", i2 = 0, o2 = h2, s2 = 0;
                continue;
              }
            }
            e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i2 = 2);
          } else n3.length > 0 ? n3 += "/" + t3.slice(o2 + 1, h2) : n3 = t3.slice(o2 + 1, h2), i2 = h2 - o2 - 1;
          o2 = h2, s2 = 0;
        } else 46 === r3 && -1 !== s2 ? ++s2 : s2 = -1;
      }
      return n3;
    }
    var n2 = { resolve: function() {
      for (var t3, n3 = "", i2 = false, o2 = arguments.length - 1; o2 >= -1 && !i2; o2--) {
        var s2;
        o2 >= 0 ? s2 = arguments[o2] : (void 0 === t3 && (t3 = process.cwd()), s2 = t3), e2(s2), 0 !== s2.length && (n3 = s2 + "/" + n3, i2 = 47 === s2.charCodeAt(0));
      }
      return n3 = r2(n3, !i2), i2 ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
    }, normalize: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      var n3 = 47 === t3.charCodeAt(0), i2 = 47 === t3.charCodeAt(t3.length - 1);
      return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i2 && (t3 += "/"), n3 ? "/" + t3 : t3;
    }, isAbsolute: function(t3) {
      return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
    }, join: function() {
      if (0 === arguments.length) return ".";
      for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
        var i2 = arguments[r3];
        e2(i2), i2.length > 0 && (void 0 === t3 ? t3 = i2 : t3 += "/" + i2);
      }
      return void 0 === t3 ? "." : n2.normalize(t3);
    }, relative: function(t3, r3) {
      if (e2(t3), e2(r3), t3 === r3) return "";
      if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return "";
      for (var i2 = 1; i2 < t3.length && 47 === t3.charCodeAt(i2); ++i2) ;
      for (var o2 = t3.length, s2 = o2 - i2, h2 = 1; h2 < r3.length && 47 === r3.charCodeAt(h2); ++h2) ;
      for (var a2 = r3.length - h2, c2 = s2 < a2 ? s2 : a2, f2 = -1, u2 = 0; u2 <= c2; ++u2) {
        if (u2 === c2) {
          if (a2 > c2) {
            if (47 === r3.charCodeAt(h2 + u2)) return r3.slice(h2 + u2 + 1);
            if (0 === u2) return r3.slice(h2 + u2);
          } else s2 > c2 && (47 === t3.charCodeAt(i2 + u2) ? f2 = u2 : 0 === u2 && (f2 = 0));
          break;
        }
        var l2 = t3.charCodeAt(i2 + u2);
        if (l2 !== r3.charCodeAt(h2 + u2)) break;
        47 === l2 && (f2 = u2);
      }
      var g2 = "";
      for (u2 = i2 + f2 + 1; u2 <= o2; ++u2) u2 !== o2 && 47 !== t3.charCodeAt(u2) || (0 === g2.length ? g2 += ".." : g2 += "/..");
      return g2.length > 0 ? g2 + r3.slice(h2 + f2) : (h2 += f2, 47 === r3.charCodeAt(h2) && ++h2, r3.slice(h2));
    }, _makeLong: function(t3) {
      return t3;
    }, dirname: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i2 = -1, o2 = true, s2 = t3.length - 1; s2 >= 1; --s2) if (47 === (r3 = t3.charCodeAt(s2))) {
        if (!o2) {
          i2 = s2;
          break;
        }
      } else o2 = false;
      return -1 === i2 ? n3 ? "/" : "." : n3 && 1 === i2 ? "//" : t3.slice(0, i2);
    }, basename: function(t3, r3) {
      if (void 0 !== r3 && "string" != typeof r3) throw new TypeError('"ext" argument must be a string');
      e2(t3);
      var n3, i2 = 0, o2 = -1, s2 = true;
      if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
        if (r3.length === t3.length && r3 === t3) return "";
        var h2 = r3.length - 1, a2 = -1;
        for (n3 = t3.length - 1; n3 >= 0; --n3) {
          var c2 = t3.charCodeAt(n3);
          if (47 === c2) {
            if (!s2) {
              i2 = n3 + 1;
              break;
            }
          } else -1 === a2 && (s2 = false, a2 = n3 + 1), h2 >= 0 && (c2 === r3.charCodeAt(h2) ? -1 == --h2 && (o2 = n3) : (h2 = -1, o2 = a2));
        }
        return i2 === o2 ? o2 = a2 : -1 === o2 && (o2 = t3.length), t3.slice(i2, o2);
      }
      for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {
        if (!s2) {
          i2 = n3 + 1;
          break;
        }
      } else -1 === o2 && (s2 = false, o2 = n3 + 1);
      return -1 === o2 ? "" : t3.slice(i2, o2);
    }, extname: function(t3) {
      e2(t3);
      for (var r3 = -1, n3 = 0, i2 = -1, o2 = true, s2 = 0, h2 = t3.length - 1; h2 >= 0; --h2) {
        var a2 = t3.charCodeAt(h2);
        if (47 !== a2) -1 === i2 && (o2 = false, i2 = h2 + 1), 46 === a2 ? -1 === r3 ? r3 = h2 : 1 !== s2 && (s2 = 1) : -1 !== r3 && (s2 = -1);
        else if (!o2) {
          n3 = h2 + 1;
          break;
        }
      }
      return -1 === r3 || -1 === i2 || 0 === s2 || 1 === s2 && r3 === i2 - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i2);
    }, format: function(t3) {
      if (null === t3 || "object" != typeof t3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
      return (function(t4, e3) {
        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
        return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
      })(0, t3);
    }, parse: function(t3) {
      e2(t3);
      var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
      if (0 === t3.length) return r3;
      var n3, i2 = t3.charCodeAt(0), o2 = 47 === i2;
      o2 ? (r3.root = "/", n3 = 1) : n3 = 0;
      for (var s2 = -1, h2 = 0, a2 = -1, c2 = true, f2 = t3.length - 1, u2 = 0; f2 >= n3; --f2) if (47 !== (i2 = t3.charCodeAt(f2))) -1 === a2 && (c2 = false, a2 = f2 + 1), 46 === i2 ? -1 === s2 ? s2 = f2 : 1 !== u2 && (u2 = 1) : -1 !== s2 && (u2 = -1);
      else if (!c2) {
        h2 = f2 + 1;
        break;
      }
      return -1 === s2 || -1 === a2 || 0 === u2 || 1 === u2 && s2 === a2 - 1 && s2 === h2 + 1 ? -1 !== a2 && (r3.base = r3.name = 0 === h2 && o2 ? t3.slice(1, a2) : t3.slice(h2, a2)) : (0 === h2 && o2 ? (r3.name = t3.slice(1, s2), r3.base = t3.slice(1, a2)) : (r3.name = t3.slice(h2, s2), r3.base = t3.slice(h2, a2)), r3.ext = t3.slice(s2, a2)), h2 > 0 ? r3.dir = t3.slice(0, h2 - 1) : o2 && (r3.dir = "/"), r3;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    n2.posix = n2, t2.exports = n2;
  } }, e = {};
  function r(n2) {
    var i2 = e[n2];
    if (void 0 !== i2) return i2.exports;
    var o2 = e[n2] = { exports: {} };
    return t[n2](o2, o2.exports, r), o2.exports;
  }
  r.d = (t2, e2) => {
    for (var n2 in e2) r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
  }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
  };
  var n = {};
  let i;
  if (r.r(n), r.d(n, { URI: () => l, Utils: () => I }), "object" == typeof process) i = "win32" === process.platform;
  else if ("object" == typeof navigator) {
    let t2 = navigator.userAgent;
    i = t2.indexOf("Windows") >= 0;
  }
  const o = /^\w[\w\d+.-]*$/, s = /^\//, h = /^\/\//;
  function a(t2, e2) {
    if (!t2.scheme && e2) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t2.authority}", path: "${t2.path}", query: "${t2.query}", fragment: "${t2.fragment}"}`);
    if (t2.scheme && !o.test(t2.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
    if (t2.path) {
      if (t2.authority) {
        if (!s.test(t2.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      } else if (h.test(t2.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
    }
  }
  const c = "", f = "/", u = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
  class l {
    static isUri(t2) {
      return t2 instanceof l || !!t2 && "string" == typeof t2.authority && "string" == typeof t2.fragment && "string" == typeof t2.path && "string" == typeof t2.query && "string" == typeof t2.scheme && "string" == typeof t2.fsPath && "function" == typeof t2.with && "function" == typeof t2.toString;
    }
    scheme;
    authority;
    path;
    query;
    fragment;
    constructor(t2, e2, r2, n2, i2, o2 = false) {
      "object" == typeof t2 ? (this.scheme = t2.scheme || c, this.authority = t2.authority || c, this.path = t2.path || c, this.query = t2.query || c, this.fragment = t2.fragment || c) : (this.scheme = /* @__PURE__ */ (function(t3, e3) {
        return t3 || e3 ? t3 : "file";
      })(t2, o2), this.authority = e2 || c, this.path = (function(t3, e3) {
        switch (t3) {
          case "https":
          case "http":
          case "file":
            e3 ? e3[0] !== f && (e3 = f + e3) : e3 = f;
        }
        return e3;
      })(this.scheme, r2 || c), this.query = n2 || c, this.fragment = i2 || c, a(this, o2));
    }
    get fsPath() {
      return v(this, false);
    }
    with(t2) {
      if (!t2) return this;
      let { scheme: e2, authority: r2, path: n2, query: i2, fragment: o2 } = t2;
      return void 0 === e2 ? e2 = this.scheme : null === e2 && (e2 = c), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = c), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = c), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = c), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = c), e2 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new d(e2, r2, n2, i2, o2);
    }
    static parse(t2, e2 = false) {
      const r2 = u.exec(t2);
      return r2 ? new d(r2[2] || c, w(r2[4] || c), w(r2[5] || c), w(r2[7] || c), w(r2[9] || c), e2) : new d(c, c, c, c, c);
    }
    static file(t2) {
      let e2 = c;
      if (i && (t2 = t2.replace(/\\/g, f)), t2[0] === f && t2[1] === f) {
        const r2 = t2.indexOf(f, 2);
        -1 === r2 ? (e2 = t2.substring(2), t2 = f) : (e2 = t2.substring(2, r2), t2 = t2.substring(r2) || f);
      }
      return new d("file", e2, t2, c, c);
    }
    static from(t2) {
      const e2 = new d(t2.scheme, t2.authority, t2.path, t2.query, t2.fragment);
      return a(e2, true), e2;
    }
    toString(t2 = false) {
      return b(this, t2);
    }
    toJSON() {
      return this;
    }
    static revive(t2) {
      if (t2) {
        if (t2 instanceof l) return t2;
        {
          const e2 = new d(t2);
          return e2._formatted = t2.external, e2._fsPath = t2._sep === g ? t2.fsPath : null, e2;
        }
      }
      return t2;
    }
  }
  const g = i ? 1 : void 0;
  class d extends l {
    _formatted = null;
    _fsPath = null;
    get fsPath() {
      return this._fsPath || (this._fsPath = v(this, false)), this._fsPath;
    }
    toString(t2 = false) {
      return t2 ? b(this, true) : (this._formatted || (this._formatted = b(this, false)), this._formatted);
    }
    toJSON() {
      const t2 = { $mid: 1 };
      return this._fsPath && (t2.fsPath = this._fsPath, t2._sep = g), this._formatted && (t2.external = this._formatted), this.path && (t2.path = this.path), this.scheme && (t2.scheme = this.scheme), this.authority && (t2.authority = this.authority), this.query && (t2.query = this.query), this.fragment && (t2.fragment = this.fragment), t2;
    }
  }
  const p = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
  function m(t2, e2, r2) {
    let n2, i2 = -1;
    for (let o2 = 0; o2 < t2.length; o2++) {
      const s2 = t2.charCodeAt(o2);
      if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e2 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2) -1 !== i2 && (n2 += encodeURIComponent(t2.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t2.charAt(o2));
      else {
        void 0 === n2 && (n2 = t2.substr(0, o2));
        const e3 = p[s2];
        void 0 !== e3 ? (-1 !== i2 && (n2 += encodeURIComponent(t2.substring(i2, o2)), i2 = -1), n2 += e3) : -1 === i2 && (i2 = o2);
      }
    }
    return -1 !== i2 && (n2 += encodeURIComponent(t2.substring(i2))), void 0 !== n2 ? n2 : t2;
  }
  function y(t2) {
    let e2;
    for (let r2 = 0; r2 < t2.length; r2++) {
      const n2 = t2.charCodeAt(r2);
      35 === n2 || 63 === n2 ? (void 0 === e2 && (e2 = t2.substr(0, r2)), e2 += p[n2]) : void 0 !== e2 && (e2 += t2[r2]);
    }
    return void 0 !== e2 ? e2 : t2;
  }
  function v(t2, e2) {
    let r2;
    return r2 = t2.authority && t2.path.length > 1 && "file" === t2.scheme ? `//${t2.authority}${t2.path}` : 47 === t2.path.charCodeAt(0) && (t2.path.charCodeAt(1) >= 65 && t2.path.charCodeAt(1) <= 90 || t2.path.charCodeAt(1) >= 97 && t2.path.charCodeAt(1) <= 122) && 58 === t2.path.charCodeAt(2) ? e2 ? t2.path.substr(1) : t2.path[1].toLowerCase() + t2.path.substr(2) : t2.path, i && (r2 = r2.replace(/\//g, "\\")), r2;
  }
  function b(t2, e2) {
    const r2 = e2 ? y : m;
    let n2 = "", { scheme: i2, authority: o2, path: s2, query: h2, fragment: a2 } = t2;
    if (i2 && (n2 += i2, n2 += ":"), (o2 || "file" === i2) && (n2 += f, n2 += f), o2) {
      let t3 = o2.indexOf("@");
      if (-1 !== t3) {
        const e3 = o2.substr(0, t3);
        o2 = o2.substr(t3 + 1), t3 = e3.lastIndexOf(":"), -1 === t3 ? n2 += r2(e3, false, false) : (n2 += r2(e3.substr(0, t3), false, false), n2 += ":", n2 += r2(e3.substr(t3 + 1), false, true)), n2 += "@";
      }
      o2 = o2.toLowerCase(), t3 = o2.lastIndexOf(":"), -1 === t3 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t3), false, true), n2 += o2.substr(t3));
    }
    if (s2) {
      if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
        const t3 = s2.charCodeAt(1);
        t3 >= 65 && t3 <= 90 && (s2 = `/${String.fromCharCode(t3 + 32)}:${s2.substr(3)}`);
      } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
        const t3 = s2.charCodeAt(0);
        t3 >= 65 && t3 <= 90 && (s2 = `${String.fromCharCode(t3 + 32)}:${s2.substr(2)}`);
      }
      n2 += r2(s2, true, false);
    }
    return h2 && (n2 += "?", n2 += r2(h2, false, false)), a2 && (n2 += "#", n2 += e2 ? a2 : m(a2, false, false)), n2;
  }
  function C(t2) {
    try {
      return decodeURIComponent(t2);
    } catch {
      return t2.length > 3 ? t2.substr(0, 3) + C(t2.substr(3)) : t2;
    }
  }
  const A = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  function w(t2) {
    return t2.match(A) ? t2.replace(A, ((t3) => C(t3))) : t2;
  }
  var x = r(975);
  const P = x.posix || x, _ = "/";
  var I;
  !(function(t2) {
    t2.joinPath = function(t3, ...e2) {
      return t3.with({ path: P.join(t3.path, ...e2) });
    }, t2.resolvePath = function(t3, ...e2) {
      let r2 = t3.path, n2 = false;
      r2[0] !== _ && (r2 = _ + r2, n2 = true);
      let i2 = P.resolve(r2, ...e2);
      return n2 && i2[0] === _ && !t3.authority && (i2 = i2.substring(1)), t3.with({ path: i2 });
    }, t2.dirname = function(t3) {
      if (0 === t3.path.length || t3.path === _) return t3;
      let e2 = P.dirname(t3.path);
      return 1 === e2.length && 46 === e2.charCodeAt(0) && (e2 = ""), t3.with({ path: e2 });
    }, t2.basename = function(t3) {
      return P.basename(t3.path);
    }, t2.extname = function(t3) {
      return P.extname(t3.path);
    };
  })(I || (I = {})), LIB = n;
})();
var { URI, Utils } = LIB;

// node_modules/html-validate/dist/esm/core-nodejs.js
var import_node_fs = __toESM(require("node:fs"), 1);

// node_modules/html-validate/dist/esm/core.js
var import_ajv = __toESM(require_ajv(), 1);

// node_modules/html-validate/dist/esm/utils/natural-join.js
function naturalJoin(values, conjunction = "or") {
  switch (values.length) {
    case 0:
      return "";
    case 1:
      return values[0];
    case 2:
      return `${values[0]} ${conjunction} ${values[1]}`;
    default:
      return `${values.slice(0, -1).join(", ")} ${conjunction} ${values.slice(-1)[0]}`;
  }
}

// node_modules/html-validate/dist/esm/meta-helper.js
function defineMetadata(metatable) {
  return metatable;
}
function allowedIfAttributeIsPresent(...attr) {
  return (node) => {
    if (attr.some((it) => node.hasAttribute(it))) {
      return null;
    }
    const expected = naturalJoin(attr.map((it) => `"${it}"`));
    return `requires ${expected} attribute to be present`;
  };
}
function allowedIfAttributeIsAbsent(...attr) {
  return (node) => {
    const present = attr.filter((it) => node.hasAttribute(it));
    if (present.length === 0) {
      return null;
    }
    const expected = naturalJoin(present.map((it) => `"${it}"`));
    return `cannot be used at the same time as ${expected}`;
  };
}
function allowedIfAttributeHasValue(key, expectedValue, { defaultValue: defaultValue2 } = {}) {
  return (node) => {
    const attr = node.getAttribute(key);
    if (attr && typeof attr !== "string") {
      return null;
    }
    const actualValue = attr ?? defaultValue2;
    if (actualValue && expectedValue.includes(actualValue.toLocaleLowerCase())) {
      return null;
    }
    const expected = naturalJoin(expectedValue.map((it) => `"${it}"`));
    return `"${key}" attribute must be ${expected}`;
  };
}
function allowedIfParentIsPresent(...tags) {
  return (node) => {
    const match2 = tags.some((it) => node.closest(it));
    if (match2) {
      return null;
    }
    const expected = naturalJoin(tags.map((it) => `<${it}>`));
    return `requires ${expected} as parent`;
  };
}
var metadataHelper = {
  allowedIfAttributeIsPresent,
  allowedIfAttributeIsAbsent,
  allowedIfAttributeHasValue,
  allowedIfParentIsPresent
};

// node_modules/html-validate/dist/esm/elements.js
var {
  allowedIfAttributeIsPresent: allowedIfAttributeIsPresent2,
  allowedIfAttributeIsAbsent: allowedIfAttributeIsAbsent2,
  allowedIfAttributeHasValue: allowedIfAttributeHasValue2,
  allowedIfParentIsPresent: allowedIfParentIsPresent2
} = metadataHelper;
var validId = "/\\S+/";
var ReferrerPolicy = [
  "",
  "no-referrer",
  "no-referrer-when-downgrade",
  "same-origin",
  "origin",
  "strict-origin",
  "origin-when-cross-origin",
  "strict-origin-when-cross-origin",
  "unsafe-url"
];
function isInsideLandmark(node) {
  const selectors2 = [
    "article",
    "aside",
    "main",
    "nav",
    "section",
    '[role="article"]',
    '[role="complementary"]',
    '[role="main"]',
    '[role="navigation"]',
    '[role="region"]'
  ];
  return Boolean(node.closest(selectors2.join(",")));
}
function linkBodyOk(node) {
  if (node.hasAttribute("itemprop")) {
    return true;
  }
  const rel = node.getAttribute("rel");
  if (!rel) {
    return false;
  }
  if (typeof rel !== "string") {
    return false;
  }
  const bodyOk = [
    "dns-prefetch",
    "modulepreload",
    "pingback",
    "preconnect",
    "prefetch",
    "preload",
    "stylesheet"
  ];
  const tokens = rel.toLowerCase().split(/\s+/);
  return tokens.some((keyword) => bodyOk.includes(keyword));
}
var html5 = defineMetadata({
  "*": {
    attributes: {
      contenteditable: {
        omit: true,
        enum: ["true", "false"]
      },
      contextmenu: {
        deprecated: true
      },
      dir: {
        enum: ["ltr", "rtl", "auto"]
      },
      draggable: {
        enum: ["true", "false"]
      },
      hidden: {
        boolean: true
      },
      id: {
        enum: [validId]
      },
      inert: {
        boolean: true
      },
      spellcheck: {
        omit: true,
        enum: ["true", "false"]
      },
      tabindex: {
        enum: ["/-?\\d+/"]
      }
    }
  },
  a: {
    flow: true,
    focusable(node) {
      return node.hasAttribute("href");
    },
    phrasing: true,
    interactive: true,
    transparent: true,
    attributes: {
      charset: {
        deprecated: true
      },
      coords: {
        deprecated: true
      },
      datafld: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      },
      download: {
        allowed: allowedIfAttributeIsPresent2("href"),
        omit: true,
        enum: ["/.+/"]
      },
      href: {
        enum: ["/.*/"]
      },
      hreflang: {
        allowed: allowedIfAttributeIsPresent2("href")
      },
      itemprop: {
        allowed: allowedIfAttributeIsPresent2("href")
      },
      methods: {
        deprecated: true
      },
      name: {
        deprecated: true
      },
      ping: {
        allowed: allowedIfAttributeIsPresent2("href")
      },
      referrerpolicy: {
        allowed: allowedIfAttributeIsPresent2("href"),
        enum: ReferrerPolicy
      },
      rel: {
        allowed(node, attr) {
          if (!node.hasAttribute("href")) {
            return `requires "href" attribute to be present`;
          }
          if (!attr || attr === "" || typeof attr !== "string") {
            return null;
          }
          const disallowed = [
            /* whatwg */
            "canonical",
            "dns-prefetch",
            "expect",
            "icon",
            "manifest",
            "modulepreload",
            "pingback",
            "preconnect",
            "prefetch",
            "preload",
            "stylesheet",
            /* microformats.org */
            "apple-touch-icon",
            "apple-touch-icon-precomposed",
            "apple-touch-startup-image",
            "authorization_endpoint",
            "component",
            "chrome-webstore-item",
            "dns-prefetch",
            "edit",
            "gbfs",
            "gtfs-static",
            "gtfs-realtime",
            "import",
            "mask-icon",
            "meta",
            "micropub",
            "openid.delegate",
            "openid.server",
            "openid2.local_id",
            "openid2.provider",
            "p3pv1",
            "pgpkey",
            "schema.dcterms",
            "service",
            "shortlink",
            "sitemap",
            "subresource",
            "sword",
            "timesheet",
            "token_endpoint",
            "wlwmanifest",
            "stylesheet/less",
            "token_endpoint",
            "yandex-tableau-widget"
          ];
          const tokens = attr.toLowerCase().split(/\s+/);
          for (const keyword of tokens) {
            if (disallowed.includes(keyword)) {
              return `<a> does not allow rel="${keyword}"`;
            }
            if (keyword.startsWith("dcterms.")) {
              return `<a> does not allow rel="${keyword}"`;
            }
          }
          return null;
        },
        list: true,
        enum: ["/.+/"]
      },
      shape: {
        deprecated: true
      },
      target: {
        allowed: allowedIfAttributeIsPresent2("href"),
        enum: ["/[^_].*/", "_blank", "_self", "_parent", "_top"]
      },
      type: {
        allowed: allowedIfAttributeIsPresent2("href")
      },
      urn: {
        deprecated: true
      }
    },
    permittedDescendants: [{ exclude: "@interactive" }],
    aria: {
      implicitRole(node) {
        return node.hasAttribute("href") ? "link" : "generic";
      },
      naming(node) {
        return node.hasAttribute("href") ? "allowed" : "prohibited";
      }
    }
  },
  abbr: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      naming: "prohibited"
    }
  },
  acronym: {
    deprecated: {
      message: "use <abbr> instead",
      documentation: "`<abbr>` can be used as a replacement.",
      source: "html5"
    }
  },
  address: {
    flow: true,
    aria: {
      implicitRole: "group"
    },
    permittedContent: ["@flow"],
    permittedDescendants: [{ exclude: ["address", "header", "footer", "@heading", "@sectioning"] }]
  },
  applet: {
    deprecated: {
      source: "html5"
    },
    attributes: {
      datafld: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      }
    }
  },
  area: {
    flow(node) {
      return Boolean(node.closest("map"));
    },
    focusable(node) {
      return node.hasAttribute("href");
    },
    phrasing(node) {
      return Boolean(node.closest("map"));
    },
    void: true,
    attributes: {
      alt: {},
      coords: {
        allowed(node) {
          const attr = node.getAttribute("shape");
          if (attr === "default") {
            return `cannot be used when "shape" attribute is "default"`;
          } else {
            return null;
          }
        }
      },
      download: {
        allowed: allowedIfAttributeIsPresent2("href")
      },
      nohref: {
        deprecated: true
      },
      itemprop: {
        allowed: allowedIfAttributeIsPresent2("href")
      },
      ping: {
        allowed: allowedIfAttributeIsPresent2("href")
      },
      referrerpolicy: {
        allowed: allowedIfAttributeIsPresent2("href"),
        enum: ReferrerPolicy
      },
      rel: {
        allowed(node, attr) {
          if (!node.hasAttribute("href")) {
            return `requires "href" attribute to be present`;
          }
          if (!attr || attr === "" || typeof attr !== "string") {
            return null;
          }
          const disallowed = [
            /* whatwg */
            "canonical",
            "dns-prefetch",
            "expect",
            "icon",
            "manifest",
            "modulepreload",
            "pingback",
            "preconnect",
            "prefetch",
            "preload",
            "stylesheet",
            /* microformats.org */
            "apple-touch-icon",
            "apple-touch-icon-precomposed",
            "apple-touch-startup-image",
            "authorization_endpoint",
            "component",
            "chrome-webstore-item",
            "dns-prefetch",
            "edit",
            "gbfs",
            "gtfs-static",
            "gtfs-realtime",
            "import",
            "mask-icon",
            "meta",
            "micropub",
            "openid.delegate",
            "openid.server",
            "openid2.local_id",
            "openid2.provider",
            "p3pv1",
            "pgpkey",
            "schema.dcterms",
            "service",
            "shortlink",
            "sitemap",
            "subresource",
            "sword",
            "timesheet",
            "token_endpoint",
            "wlwmanifest",
            "stylesheet/less",
            "token_endpoint",
            "yandex-tableau-widget"
          ];
          const tokens = attr.toLowerCase().split(/\s+/);
          for (const keyword of tokens) {
            if (disallowed.includes(keyword)) {
              return `<area> does not allow rel="${keyword}"`;
            }
            if (keyword.startsWith("dcterms.")) {
              return `<area> does not allow rel="${keyword}"`;
            }
          }
          return null;
        }
      },
      shape: {
        allowed(node, attr) {
          const shape = attr ?? "rect";
          switch (shape) {
            case "circ":
            case "circle":
            case "poly":
            case "polygon":
            case "rect":
            case "rectangle":
              return allowedIfAttributeIsPresent2("coords")(node, attr);
            default:
              return null;
          }
        },
        enum: ["rect", "circle", "poly", "default"]
      },
      target: {
        allowed: allowedIfAttributeIsPresent2("href"),
        enum: ["/[^_].*/", "_blank", "_self", "_parent", "_top"]
      }
    },
    aria: {
      implicitRole(node) {
        return node.hasAttribute("href") ? "link" : "generic";
      },
      naming(node) {
        return node.hasAttribute("href") ? "allowed" : "prohibited";
      }
    },
    requiredAncestors: ["map", "template"]
  },
  article: {
    flow: true,
    sectioning: true,
    permittedContent: ["@flow"],
    permittedDescendants: [{ exclude: ["main"] }],
    aria: {
      implicitRole: "article"
    }
  },
  aside: {
    flow: true,
    sectioning: true,
    permittedContent: ["@flow"],
    permittedDescendants: [{ exclude: ["main"] }],
    aria: {
      implicitRole: "complementary"
    }
  },
  audio: {
    flow: true,
    focusable(node) {
      return node.hasAttribute("controls");
    },
    phrasing: true,
    embedded: true,
    interactive(node) {
      return node.hasAttribute("controls");
    },
    transparent: ["@flow"],
    attributes: {
      crossorigin: {
        omit: true,
        enum: ["anonymous", "use-credentials"]
      },
      itemprop: {
        allowed: allowedIfAttributeIsPresent2("src")
      },
      preload: {
        omit: true,
        enum: ["none", "metadata", "auto"]
      }
    },
    permittedContent: ["@flow", "track", "source"],
    permittedDescendants: [{ exclude: ["audio", "video"] }],
    permittedOrder: ["source", "track", "@flow"]
  },
  b: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "generic",
      naming: "prohibited"
    }
  },
  base: {
    metadata: true,
    void: true,
    permittedParent: ["head"],
    aria: {
      naming: "prohibited"
    }
  },
  basefont: {
    deprecated: {
      message: "use CSS instead",
      documentation: "Use CSS `font-size` property instead.",
      source: "html4"
    }
  },
  bdi: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "generic",
      naming: "prohibited"
    }
  },
  bdo: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "generic",
      naming: "prohibited"
    }
  },
  bgsound: {
    deprecated: {
      message: "use <audio> instead",
      documentation: "Use the `<audio>` element instead but consider accessibility concerns with autoplaying sounds.",
      source: "non-standard"
    }
  },
  big: {
    deprecated: {
      message: "use CSS instead",
      documentation: "Use CSS `font-size` property instead.",
      source: "html5"
    }
  },
  blink: {
    deprecated: {
      documentation: "`<blink>` has no direct replacement and blinking text is frowned upon by accessibility standards.",
      source: "non-standard"
    }
  },
  blockquote: {
    flow: true,
    sectioning: true,
    aria: {
      implicitRole: "blockquote"
    },
    permittedContent: ["@flow"]
  },
  body: {
    permittedContent: ["@flow"],
    permittedParent: ["html"],
    attributes: {
      alink: {
        deprecated: true
      },
      background: {
        deprecated: true
      },
      bgcolor: {
        deprecated: true
      },
      link: {
        deprecated: true
      },
      marginbottom: {
        deprecated: true
      },
      marginheight: {
        deprecated: true
      },
      marginleft: {
        deprecated: true
      },
      marginright: {
        deprecated: true
      },
      margintop: {
        deprecated: true
      },
      marginwidth: {
        deprecated: true
      },
      text: {
        deprecated: true
      },
      vlink: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "generic",
      naming: "prohibited"
    }
  },
  br: {
    flow: true,
    phrasing: true,
    void: true,
    attributes: {
      clear: {
        deprecated: true
      }
    },
    aria: {
      naming: "prohibited"
    }
  },
  button: {
    flow: true,
    focusable: true,
    phrasing: true,
    interactive: true,
    formAssociated: {
      disablable: true,
      listed: true
    },
    labelable: true,
    attributes: {
      autofocus: {
        boolean: true
      },
      datafld: {
        deprecated: true
      },
      dataformatas: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      },
      disabled: {
        boolean: true
      },
      formaction: {
        allowed: allowedIfAttributeHasValue2("type", ["submit"], { defaultValue: "submit" })
      },
      formenctype: {
        allowed: allowedIfAttributeHasValue2("type", ["submit"], { defaultValue: "submit" })
      },
      formmethod: {
        allowed: allowedIfAttributeHasValue2("type", ["submit"], { defaultValue: "submit" }),
        enum: ["get", "post", "dialog"]
      },
      formnovalidate: {
        allowed: allowedIfAttributeHasValue2("type", ["submit"], { defaultValue: "submit" }),
        boolean: true
      },
      formtarget: {
        allowed: allowedIfAttributeHasValue2("type", ["submit"], { defaultValue: "submit" }),
        enum: ["/[^_].*/", "_blank", "_self", "_parent", "_top"]
      },
      type: {
        enum: ["submit", "reset", "button"]
      }
    },
    aria: {
      implicitRole: "button"
    },
    permittedContent: ["@phrasing"],
    permittedDescendants: [{ exclude: ["@interactive"] }],
    textContent: "accessible"
  },
  canvas: {
    flow: true,
    phrasing: true,
    embedded: true,
    transparent: true
  },
  caption: {
    permittedContent: ["@flow"],
    permittedDescendants: [{ exclude: ["table"] }],
    attributes: {
      align: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "caption",
      naming: "prohibited"
    }
  },
  center: {
    deprecated: {
      message: "use CSS instead",
      documentation: "Use the CSS `text-align` or `margin: auto` properties instead.",
      source: "html4"
    }
  },
  cite: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      naming: "prohibited"
    }
  },
  code: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "code",
      naming: "prohibited"
    }
  },
  col: {
    attributes: {
      align: {
        deprecated: true
      },
      char: {
        deprecated: true
      },
      charoff: {
        deprecated: true
      },
      span: {
        enum: ["/\\d+/"]
      },
      valign: {
        deprecated: true
      },
      width: {
        deprecated: true
      }
    },
    void: true,
    aria: {
      naming: "prohibited"
    }
  },
  colgroup: {
    implicitClosed: ["colgroup"],
    attributes: {
      span: {
        enum: ["/\\d+/"]
      }
    },
    permittedContent: ["col", "template"],
    aria: {
      naming: "prohibited"
    }
  },
  data: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "generic",
      naming: "prohibited"
    }
  },
  datalist: {
    flow: true,
    phrasing: true,
    aria: {
      implicitRole: "listbox",
      naming: "prohibited"
    },
    permittedContent: ["@phrasing", "option"]
  },
  dd: {
    implicitClosed: ["dd", "dt"],
    permittedContent: ["@flow"],
    requiredAncestors: ["dl > dd", "dl > div > dd", "template > dd", "template > div > dd"]
  },
  del: {
    flow: true,
    phrasing: true,
    transparent: true,
    aria: {
      implicitRole: "deletion",
      naming: "prohibited"
    }
  },
  details: {
    flow: true,
    sectioning: true,
    interactive: true,
    attributes: {
      open: {
        boolean: true
      }
    },
    aria: {
      implicitRole: "group"
    },
    permittedContent: ["summary", "@flow"],
    permittedOrder: ["summary", "@flow"],
    requiredContent: ["summary"]
  },
  dfn: {
    flow: true,
    phrasing: true,
    aria: {
      implicitRole: "term"
    },
    permittedContent: ["@phrasing"],
    permittedDescendants: [{ exclude: ["dfn"] }]
  },
  dialog: {
    flow: true,
    permittedContent: ["@flow"],
    attributes: {
      open: {
        boolean: true
      }
    },
    aria: {
      implicitRole: "dialog"
    }
  },
  dir: {
    deprecated: {
      documentation: "The non-standard `<dir>` element has no direct replacement but MDN recommends replacing with `<ul>` and CSS.",
      source: "html4"
    }
  },
  div: {
    flow: true,
    permittedContent: ["@flow", "dt", "dd"],
    attributes: {
      align: {
        deprecated: true
      },
      datafld: {
        deprecated: true
      },
      dataformatas: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "generic",
      naming: "prohibited"
    }
  },
  dl: {
    flow: true,
    permittedContent: ["@script", "dt", "dd", "div"],
    attributes: {
      compact: {
        deprecated: true
      }
    }
  },
  dt: {
    implicitClosed: ["dd", "dt"],
    permittedContent: ["@flow"],
    permittedDescendants: [{ exclude: ["header", "footer", "@sectioning", "@heading"] }],
    requiredAncestors: ["dl > dt", "dl > div > dt", "template > dt", "template > div > dt"]
  },
  em: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "emphasis",
      naming: "prohibited"
    }
  },
  embed: {
    flow: true,
    phrasing: true,
    embedded: true,
    interactive: true,
    void: true,
    attributes: {
      height: {
        enum: ["/\\d+/"]
      },
      src: {
        required: true,
        enum: ["/.+/"]
      },
      title: {
        required: true
      },
      width: {
        enum: ["/\\d+/"]
      }
    }
  },
  fieldset: {
    flow: true,
    formAssociated: {
      disablable: true,
      listed: true
    },
    attributes: {
      datafld: {
        deprecated: true
      },
      disabled: {
        boolean: true
      }
    },
    aria: {
      implicitRole: "group"
    },
    permittedContent: ["@flow", "legend?"],
    permittedOrder: ["legend", "@flow"]
  },
  figcaption: {
    permittedContent: ["@flow"],
    aria: {
      naming: "prohibited"
    }
  },
  figure: {
    flow: true,
    aria: {
      implicitRole: "figure"
    },
    permittedContent: ["@flow", "figcaption?"],
    permittedOrder: ["figcaption", "@flow", "figcaption"]
  },
  font: {
    deprecated: {
      message: "use CSS instead",
      documentation: "Use CSS font properties instead.",
      source: "html4"
    }
  },
  footer: {
    flow: true,
    aria: {
      implicitRole(node) {
        if (isInsideLandmark(node)) {
          return "generic";
        } else {
          return "contentinfo";
        }
      },
      naming(node) {
        if (isInsideLandmark(node)) {
          return "prohibited";
        } else {
          return "allowed";
        }
      }
    },
    permittedContent: ["@flow"],
    permittedDescendants: [{ exclude: ["header", "footer", "main"] }]
  },
  form: {
    flow: true,
    form: true,
    attributes: {
      action: {
        enum: [/^\s*\S+\s*$/]
      },
      accept: {
        deprecated: true
      },
      autocomplete: {
        enum: ["on", "off"]
      },
      method: {
        enum: ["get", "post", "dialog"]
      },
      novalidate: {
        boolean: true
      },
      rel: {
        allowed(_, attr) {
          if (!attr || attr === "" || typeof attr !== "string") {
            return null;
          }
          const disallowed = [
            /* whatwg */
            "alternate",
            "canonical",
            "author",
            "bookmark",
            "dns-prefetch",
            "expect",
            "icon",
            "manifest",
            "modulepreload",
            "pingback",
            "preconnect",
            "prefetch",
            "preload",
            "privacy-policy",
            "stylesheet",
            "tag",
            "terms-of-service"
          ];
          const tokens = attr.toLowerCase().split(/\s+/);
          for (const keyword of tokens) {
            if (disallowed.includes(keyword)) {
              return `<form> does not allow rel="${keyword}"`;
            }
          }
          return null;
        },
        list: true,
        enum: ["/.+/"]
      },
      target: {
        enum: ["/[^_].*/", "_blank", "_self", "_parent", "_top"]
      }
    },
    aria: {
      implicitRole: "form"
    },
    permittedContent: ["@flow"],
    permittedDescendants: [{ exclude: ["@form"] }]
  },
  frame: {
    deprecated: {
      documentation: "The `<frame>` element can be replaced with the `<iframe>` element but a better solution is to remove usage of frames entirely.",
      source: "html5"
    },
    attributes: {
      datafld: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      },
      title: {
        required: true
      }
    }
  },
  frameset: {
    deprecated: {
      documentation: "The `<frameset>` element can be replaced with the `<iframe>` element but a better solution is to remove usage of frames entirely.",
      source: "html5"
    }
  },
  h1: {
    flow: true,
    heading: true,
    permittedContent: ["@phrasing"],
    attributes: {
      align: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "heading"
    }
  },
  h2: {
    flow: true,
    heading: true,
    permittedContent: ["@phrasing"],
    attributes: {
      align: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "heading"
    }
  },
  h3: {
    flow: true,
    heading: true,
    permittedContent: ["@phrasing"],
    attributes: {
      align: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "heading"
    }
  },
  h4: {
    flow: true,
    heading: true,
    permittedContent: ["@phrasing"],
    attributes: {
      align: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "heading"
    }
  },
  h5: {
    flow: true,
    heading: true,
    permittedContent: ["@phrasing"],
    attributes: {
      align: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "heading"
    }
  },
  h6: {
    flow: true,
    heading: true,
    permittedContent: ["@phrasing"],
    attributes: {
      align: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "heading"
    }
  },
  head: {
    permittedContent: ["base?", "title?", "@meta"],
    permittedParent: ["html"],
    requiredContent: ["title"],
    attributes: {
      profile: {
        deprecated: true
      }
    },
    aria: {
      naming: "prohibited"
    }
  },
  header: {
    flow: true,
    aria: {
      implicitRole(node) {
        if (isInsideLandmark(node)) {
          return "generic";
        } else {
          return "banner";
        }
      },
      naming(node) {
        if (isInsideLandmark(node)) {
          return "prohibited";
        } else {
          return "allowed";
        }
      }
    },
    permittedContent: ["@flow"],
    permittedDescendants: [{ exclude: ["header", "footer", "main"] }]
  },
  hgroup: {
    flow: true,
    heading: true,
    permittedContent: ["p", "@heading?"],
    permittedDescendants: [{ exclude: ["hgroup"] }],
    requiredContent: ["@heading"],
    aria: {
      implicitRole: "group"
    }
  },
  hr: {
    flow: true,
    void: true,
    attributes: {
      align: {
        deprecated: true
      },
      color: {
        deprecated: true
      },
      noshade: {
        deprecated: true
      },
      size: {
        deprecated: true
      },
      width: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "separator"
    }
  },
  html: {
    permittedContent: ["head?", "body?"],
    permittedOrder: ["head", "body"],
    requiredContent: ["head", "body"],
    attributes: {
      lang: {
        required: true
      },
      version: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "document",
      naming: "prohibited"
    }
  },
  i: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "generic",
      naming: "prohibited"
    }
  },
  iframe: {
    flow: true,
    phrasing: true,
    embedded: true,
    interactive: true,
    attributes: {
      align: {
        deprecated: true
      },
      allowtransparency: {
        deprecated: true
      },
      datafld: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      },
      frameborder: {
        deprecated: true
      },
      height: {
        enum: ["/\\d+/"]
      },
      hspace: {
        deprecated: true
      },
      marginheight: {
        deprecated: true
      },
      marginwidth: {
        deprecated: true
      },
      referrerpolicy: {
        enum: ReferrerPolicy
      },
      scrolling: {
        deprecated: true
      },
      src: {
        enum: ["/.+/"]
      },
      title: {
        required: true
      },
      vspace: {
        deprecated: true
      },
      width: {
        enum: ["/\\d+/"]
      }
    },
    permittedContent: []
  },
  img: {
    flow: true,
    phrasing: true,
    embedded: true,
    interactive(node) {
      return node.hasAttribute("usemap");
    },
    void: true,
    attributes: {
      align: {
        deprecated: true
      },
      border: {
        deprecated: true
      },
      crossorigin: {
        omit: true,
        enum: ["anonymous", "use-credentials"]
      },
      datafld: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      },
      decoding: {
        enum: ["sync", "async", "auto"]
      },
      height: {
        enum: ["/\\d+/"]
      },
      hspace: {
        deprecated: true
      },
      ismap: {
        boolean: true
      },
      lowsrc: {
        deprecated: true
      },
      name: {
        deprecated: true
      },
      referrerpolicy: {
        enum: ReferrerPolicy
      },
      src: {
        required: true,
        enum: ["/.+/"]
      },
      srcset: {
        enum: ["/[^]+/"]
      },
      vspace: {
        deprecated: true
      },
      width: {
        enum: ["/\\d+/"]
      }
    },
    aria: {
      implicitRole(node) {
        const alt = node.getAttribute("alt");
        const ariaLabel = node.getAttribute("aria-label");
        const ariaLabelledBy = node.getAttribute("aria-labelledby");
        const title2 = node.getAttribute("title");
        if (alt === "" && !ariaLabel && !ariaLabelledBy && !title2) {
          return "none";
        } else {
          return "img";
        }
      },
      naming(node) {
        const alt = node.getAttribute("alt");
        const ariaLabel = node.getAttribute("aria-label");
        const ariaLabelledBy = node.getAttribute("aria-labelledby");
        const title2 = node.getAttribute("title");
        if (!alt && !ariaLabel && !ariaLabelledBy && !title2) {
          return "prohibited";
        } else {
          return "allowed";
        }
      }
    }
  },
  input: {
    flow: true,
    focusable(node) {
      return node.getAttribute("type") !== "hidden";
    },
    phrasing: true,
    interactive(node) {
      return node.getAttribute("type") !== "hidden";
    },
    void: true,
    formAssociated: {
      disablable: true,
      listed: true
    },
    labelable(node) {
      return node.getAttribute("type") !== "hidden";
    },
    attributes: {
      align: {
        deprecated: true
      },
      autofocus: {
        boolean: true
      },
      capture: {
        omit: true,
        enum: ["environment", "user"]
      },
      checked: {
        boolean: true
      },
      datafld: {
        deprecated: true
      },
      dataformatas: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      },
      disabled: {
        boolean: true
      },
      formaction: {
        allowed: allowedIfAttributeHasValue2("type", ["submit", "image"], {
          defaultValue: "submit"
        })
      },
      formenctype: {
        allowed: allowedIfAttributeHasValue2("type", ["submit", "image"], {
          defaultValue: "submit"
        })
      },
      formmethod: {
        allowed: allowedIfAttributeHasValue2("type", ["submit", "image"], {
          defaultValue: "submit"
        }),
        enum: ["get", "post", "dialog"]
      },
      formnovalidate: {
        allowed: allowedIfAttributeHasValue2("type", ["submit", "image"], {
          defaultValue: "submit"
        }),
        boolean: true
      },
      formtarget: {
        allowed: allowedIfAttributeHasValue2("type", ["submit", "image"], {
          defaultValue: "submit"
        }),
        enum: ["/[^_].*/", "_blank", "_self", "_parent", "_top"]
      },
      hspace: {
        deprecated: true
      },
      inputmode: {
        enum: ["none", "text", "decimal", "numeric", "tel", "search", "email", "url"]
      },
      ismap: {
        deprecated: true
      },
      multiple: {
        boolean: true
      },
      readonly: {
        boolean: true
      },
      required: {
        boolean: true
      },
      type: {
        enum: [
          "button",
          "checkbox",
          "color",
          "date",
          "datetime-local",
          "email",
          "file",
          "hidden",
          "image",
          "month",
          "number",
          "password",
          "radio",
          "range",
          "reset",
          "search",
          "submit",
          "tel",
          "text",
          "time",
          "url",
          "week"
        ]
      },
      usemap: {
        deprecated: true
      },
      vspace: {
        deprecated: true
      }
    },
    aria: {
      /* eslint-disable-next-line complexity -- the standard is complicated */
      implicitRole(node) {
        const list = node.hasAttribute("list");
        if (list) {
          return "combobox";
        }
        const type2 = node.getAttribute("type");
        switch (type2) {
          case "button":
            return "button";
          case "checkbox":
            return "checkbox";
          case "color":
            return null;
          case "date":
            return null;
          case "datetime-local":
            return null;
          case "email":
            return "textbox";
          case "file":
            return null;
          case "hidden":
            return null;
          case "image":
            return "button";
          case "month":
            return null;
          case "number":
            return "spinbutton";
          case "password":
            return null;
          case "radio":
            return "radio";
          case "range":
            return "slider";
          case "reset":
            return "button";
          case "search":
            return "searchbox";
          case "submit":
            return "button";
          case "tel":
            return "textbox";
          case "text":
            return "textbox";
          case "time":
            return null;
          case "url":
            return "textbox";
          case "week":
            return null;
          default:
            return "textbox";
        }
      },
      naming(node) {
        return node.getAttribute("type") !== "hidden" ? "allowed" : "prohibited";
      }
    }
  },
  ins: {
    flow: true,
    phrasing: true,
    transparent: true,
    aria: {
      implicitRole: "insertion",
      naming: "prohibited"
    }
  },
  isindex: {
    deprecated: {
      source: "html4"
    }
  },
  kbd: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      naming: "prohibited"
    }
  },
  keygen: {
    flow: true,
    phrasing: true,
    interactive: true,
    void: true,
    labelable: true,
    deprecated: true
  },
  label: {
    flow: true,
    phrasing: true,
    interactive: true,
    permittedContent: ["@phrasing"],
    permittedDescendants: [{ exclude: ["label"] }],
    attributes: {
      datafld: {
        deprecated: true
      },
      dataformatas: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      },
      for: {
        enum: [validId]
      }
    },
    aria: {
      naming: "prohibited"
    }
  },
  legend: {
    permittedContent: ["@phrasing", "@heading"],
    attributes: {
      align: {
        deprecated: true
      },
      datafld: {
        deprecated: true
      },
      dataformatas: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      }
    },
    aria: {
      naming: "prohibited"
    }
  },
  li: {
    implicitClosed: ["li"],
    permittedContent: ["@flow"],
    permittedParent: ["ul", "ol", "menu", "template"],
    attributes: {
      type: {
        deprecated: true
      }
    },
    aria: {
      implicitRole(node) {
        return node.closest("ul, ol, menu") ? "listitem" : "generic";
      }
    }
  },
  link: {
    metadata: true,
    flow(node) {
      return linkBodyOk(node);
    },
    phrasing(node) {
      return linkBodyOk(node);
    },
    void: true,
    attributes: {
      as: {
        allowed: allowedIfAttributeHasValue2("rel", ["prefetch", "preload", "modulepreload"]),
        enum: [
          "audio",
          "audioworklet",
          "document",
          "embed",
          "fetch",
          "font",
          "frame",
          "iframe",
          "image",
          "manifest",
          "object",
          "paintworklet",
          "report",
          "script",
          "serviceworker",
          "sharedworker",
          "style",
          "track",
          "video",
          "webidentity",
          "worker",
          "xslt"
        ]
      },
      blocking: {
        allowed: allowedIfAttributeHasValue2("rel", ["stylesheet", "preload", "modulepreload"]),
        list: true,
        enum: ["render"]
      },
      charset: {
        deprecated: true
      },
      crossorigin: {
        omit: true,
        enum: ["anonymous", "use-credentials"]
      },
      disabled: {
        allowed: allowedIfAttributeHasValue2("rel", ["stylesheet"]),
        boolean: true
      },
      href: {
        required: true,
        enum: ["/.+/"]
      },
      integrity: {
        allowed: allowedIfAttributeHasValue2("rel", ["stylesheet", "preload", "modulepreload"]),
        enum: ["/.+/"]
      },
      methods: {
        deprecated: true
      },
      referrerpolicy: {
        enum: ReferrerPolicy
      },
      rel: {
        allowed(_, attr) {
          if (!attr || attr === "" || typeof attr !== "string") {
            return null;
          }
          const disallowed = [
            /* whatwg */
            "bookmark",
            "external",
            "nofollow",
            "noopener",
            "noreferrer",
            "opener",
            "tag",
            /* microformats.org */
            "disclosure",
            "entry-content",
            "lightbox",
            "lightvideo"
          ];
          const tokens = attr.toLowerCase().split(/\s+/);
          for (const keyword of tokens) {
            if (disallowed.includes(keyword)) {
              return `<link> does not allow rel="${keyword}"`;
            }
          }
          return null;
        },
        list: true,
        enum: ["/.+/"]
      },
      target: {
        deprecated: true
      },
      urn: {
        deprecated: true
      }
    },
    aria: {
      naming: "prohibited"
    }
  },
  listing: {
    deprecated: {
      source: "html32"
    }
  },
  main: {
    flow: true,
    aria: {
      implicitRole: "main"
    }
  },
  map: {
    flow: true,
    phrasing: true,
    transparent: true,
    attributes: {
      name: {
        required: true,
        enum: ["/\\S+/"]
      }
    },
    aria: {
      naming: "prohibited"
    }
  },
  mark: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      naming: "prohibited"
    }
  },
  marquee: {
    deprecated: {
      documentation: "Marked as obsolete by both W3C and WHATWG standards but still implemented in most browsers. Animated text should be avoided for accessibility reasons as well.",
      source: "html5"
    },
    attributes: {
      datafld: {
        deprecated: true
      },
      dataformatas: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      }
    }
  },
  math: {
    flow: true,
    foreign: true,
    phrasing: true,
    embedded: true,
    attributes: {
      align: {
        deprecated: true
      },
      dir: {
        enum: ["ltr", "rtl"]
      },
      display: {
        enum: ["block", "inline"]
      },
      hspace: {
        deprecated: true
      },
      name: {
        deprecated: true
      },
      overflow: {
        enum: ["linebreak", "scroll", "elide", "truncate", "scale"]
      },
      vspace: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "math"
    }
  },
  menu: {
    flow: true,
    aria: {
      implicitRole: "list"
    },
    permittedContent: ["@script", "li"]
  },
  meta: {
    flow(node) {
      return node.hasAttribute("itemprop");
    },
    phrasing(node) {
      return node.hasAttribute("itemprop");
    },
    metadata: true,
    void: true,
    attributes: {
      charset: {
        enum: ["utf-8"]
      },
      content: {
        allowed: allowedIfAttributeIsPresent2("name", "http-equiv", "itemprop", "property")
      },
      itemprop: {
        allowed: allowedIfAttributeIsAbsent2("http-equiv", "name")
      },
      name: {
        allowed: allowedIfAttributeIsAbsent2("http-equiv", "itemprop")
      },
      "http-equiv": {
        allowed: allowedIfAttributeIsAbsent2("name", "itemprop")
      },
      scheme: {
        deprecated: true
      }
    },
    aria: {
      naming: "prohibited"
    }
  },
  meter: {
    flow: true,
    phrasing: true,
    labelable: true,
    aria: {
      implicitRole: "meter"
    },
    permittedContent: ["@phrasing"],
    permittedDescendants: [{ exclude: "meter" }]
  },
  multicol: {
    deprecated: {
      message: "use CSS instead",
      documentation: "Use CSS columns instead.",
      source: "html5"
    }
  },
  nav: {
    flow: true,
    sectioning: true,
    aria: {
      implicitRole: "navigation"
    },
    permittedContent: ["@flow"],
    permittedDescendants: [{ exclude: "main" }]
  },
  nextid: {
    deprecated: {
      source: "html32"
    }
  },
  nobr: {
    deprecated: {
      message: "use CSS instead",
      documentation: "Use CSS `white-space` property instead.",
      source: "non-standard"
    }
  },
  noembed: {
    deprecated: {
      source: "non-standard"
    }
  },
  noframes: {
    deprecated: {
      source: "html5"
    }
  },
  noscript: {
    metadata: true,
    flow: true,
    phrasing: true,
    transparent: true,
    permittedDescendants: [{ exclude: "noscript" }],
    aria: {
      naming: "prohibited"
    }
  },
  object: {
    flow: true,
    phrasing: true,
    embedded: true,
    interactive(node) {
      return node.hasAttribute("usemap");
    },
    transparent: true,
    formAssociated: {
      disablable: false,
      listed: true
    },
    attributes: {
      align: {
        deprecated: true
      },
      archive: {
        deprecated: true
      },
      blocking: {
        list: true,
        enum: ["render"]
      },
      border: {
        deprecated: true
      },
      classid: {
        deprecated: true
      },
      code: {
        deprecated: true
      },
      codebase: {
        deprecated: true
      },
      codetype: {
        deprecated: true
      },
      data: {
        enum: ["/.+/"],
        required: true
      },
      datafld: {
        deprecated: true
      },
      dataformatas: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      },
      declare: {
        deprecated: true
      },
      height: {
        enum: ["/\\d+/"]
      },
      hspace: {
        deprecated: true
      },
      name: {
        enum: ["/[^_].*/"]
      },
      standby: {
        deprecated: true
      },
      vspace: {
        deprecated: true
      },
      width: {
        enum: ["/\\d+/"]
      }
    },
    permittedContent: ["param", "@flow"],
    permittedOrder: ["param", "@flow"]
  },
  ol: {
    flow: true,
    attributes: {
      compact: {
        deprecated: true
      },
      reversed: {
        boolean: true
      },
      type: {
        enum: ["a", "A", "i", "I", "1"]
      }
    },
    aria: {
      implicitRole: "list"
    },
    permittedContent: ["@script", "li"]
  },
  optgroup: {
    implicitClosed: ["optgroup"],
    attributes: {
      disabled: {
        boolean: true
      }
    },
    aria: {
      implicitRole: "group"
    },
    permittedContent: ["@script", "option"]
  },
  option: {
    implicitClosed: ["option"],
    attributes: {
      dataformatas: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      },
      disabled: {
        boolean: true
      },
      name: {
        deprecated: true
      },
      selected: {
        boolean: true
      }
    },
    aria: {
      implicitRole: "option"
    },
    permittedContent: []
  },
  output: {
    flow: true,
    phrasing: true,
    formAssociated: {
      disablable: false,
      listed: true
    },
    labelable: true,
    aria: {
      implicitRole: "status"
    },
    permittedContent: ["@phrasing"]
  },
  p: {
    flow: true,
    implicitClosed: [
      "address",
      "article",
      "aside",
      "blockquote",
      "div",
      "dl",
      "fieldset",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "hr",
      "main",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "table",
      "ul"
    ],
    permittedContent: ["@phrasing"],
    attributes: {
      align: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "paragraph",
      naming: "prohibited"
    }
  },
  param: {
    void: true,
    attributes: {
      datafld: {
        deprecated: true
      },
      type: {
        deprecated: true
      },
      valuetype: {
        deprecated: true
      }
    },
    aria: {
      naming: "prohibited"
    }
  },
  picture: {
    flow: true,
    phrasing: true,
    embedded: true,
    permittedContent: ["@script", "source", "img"],
    permittedOrder: ["source", "img"],
    aria: {
      naming: "prohibited"
    }
  },
  plaintext: {
    deprecated: {
      message: "use <pre> or CSS instead",
      documentation: "Use the `<pre>` element or use CSS to set a monospace font.",
      source: "html2"
    }
  },
  pre: {
    flow: true,
    permittedContent: ["@phrasing"],
    attributes: {
      width: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "generic",
      naming: "prohibited"
    }
  },
  progress: {
    flow: true,
    phrasing: true,
    labelable: true,
    aria: {
      implicitRole: "progressbar"
    },
    permittedContent: ["@phrasing"],
    permittedDescendants: [{ exclude: "progress" }]
  },
  q: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "generic",
      naming: "prohibited"
    }
  },
  rb: {
    implicitClosed: ["rb", "rt", "rtc", "rp"],
    permittedContent: ["@phrasing"]
  },
  rp: {
    implicitClosed: ["rb", "rt", "rtc", "rp"],
    permittedContent: ["@phrasing"],
    aria: {
      naming: "prohibited"
    }
  },
  rt: {
    implicitClosed: ["rb", "rt", "rtc", "rp"],
    permittedContent: ["@phrasing"],
    aria: {
      naming: "prohibited"
    }
  },
  rtc: {
    implicitClosed: ["rb", "rtc", "rp"],
    permittedContent: ["@phrasing", "rt"]
  },
  ruby: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing", "rb", "rp", "rt", "rtc"]
  },
  s: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "deletion",
      naming: "prohibited"
    }
  },
  samp: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "generic",
      naming: "prohibited"
    }
  },
  script: {
    metadata: true,
    flow: true,
    phrasing: true,
    scriptSupporting: true,
    attributes: {
      async: {
        boolean: true
      },
      crossorigin: {
        omit: true,
        enum: ["anonymous", "use-credentials"]
      },
      defer: {
        boolean: true
      },
      event: {
        deprecated: true
      },
      for: {
        deprecated: true
      },
      integrity: {
        allowed: allowedIfAttributeIsPresent2("src"),
        enum: ["/.+/"]
      },
      language: {
        deprecated: true
      },
      nomodule: {
        boolean: true
      },
      referrerpolicy: {
        enum: ReferrerPolicy
      },
      src: {
        enum: ["/.+/"]
      }
    },
    aria: {
      naming: "prohibited"
    }
  },
  search: {
    flow: true,
    aria: {
      implicitRole: "search"
    }
  },
  section: {
    flow: true,
    sectioning: true,
    aria: {
      implicitRole(node) {
        const name = node.hasAttribute("aria-label") || node.hasAttribute("aria-labelledby");
        return name ? "region" : "generic";
      }
    },
    permittedContent: ["@flow"]
  },
  select: {
    flow: true,
    focusable: true,
    phrasing: true,
    interactive: true,
    formAssociated: {
      disablable: true,
      listed: true
    },
    labelable: true,
    attributes: {
      autofocus: {
        boolean: true
      },
      disabled: {
        boolean: true
      },
      multiple: {
        boolean: true
      },
      required: {
        boolean: true
      },
      size: {
        enum: ["/\\d+/"]
      }
    },
    aria: {
      implicitRole(node) {
        const multiple = node.hasAttribute("multiple");
        if (multiple) {
          return "listbox";
        }
        const size = node.getAttribute("size");
        if (typeof size === "string") {
          const parsed = parseInt(size, 10);
          if (parsed > 1) {
            return "listbox";
          }
        }
        return "combobox";
      }
    },
    permittedContent: ["@script", "datasrc", "datafld", "dataformatas", "option", "optgroup"]
  },
  slot: {
    flow: true,
    phrasing: true,
    transparent: true,
    aria: {
      naming: "prohibited"
    }
  },
  small: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "generic",
      naming: "prohibited"
    }
  },
  source: {
    void: true,
    attributes: {
      type: {},
      media: {},
      src: {
        allowed: allowedIfParentIsPresent2("audio", "video")
      },
      srcset: {
        allowed: allowedIfParentIsPresent2("picture")
      },
      sizes: {
        allowed: allowedIfParentIsPresent2("picture")
      },
      width: {
        allowed: allowedIfParentIsPresent2("picture"),
        enum: ["/\\d+/"]
      },
      height: {
        allowed: allowedIfParentIsPresent2("picture"),
        enum: ["/\\d+/"]
      }
    },
    aria: {
      naming: "prohibited"
    }
  },
  spacer: {
    deprecated: {
      message: "use CSS instead",
      documentation: "Use CSS margin or padding instead.",
      source: "non-standard"
    }
  },
  span: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    attributes: {
      datafld: {
        deprecated: true
      },
      dataformatas: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "generic",
      naming: "prohibited"
    }
  },
  strike: {
    deprecated: {
      message: "use <del> or <s> instead",
      documentation: "Use the `<del>` or `<s>` element instead.",
      source: "html5"
    }
  },
  strong: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "strong",
      naming: "prohibited"
    }
  },
  style: {
    metadata: true,
    aria: {
      naming: "prohibited"
    }
  },
  sub: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "subscript",
      naming: "prohibited"
    }
  },
  summary: {
    permittedContent: ["@phrasing", "@heading"],
    focusable(node) {
      return Boolean(node.closest("details"));
    },
    aria: {
      implicitRole: "button"
    }
  },
  sup: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "superscript",
      naming: "prohibited"
    }
  },
  svg: {
    flow: true,
    foreign: true,
    phrasing: true,
    embedded: true,
    aria: {
      implicitRole: "graphics-document"
    }
  },
  /* while not part of HTML 5 specification these two elements are handled as
   * special cases to allow them as accessible text and to avoid issues with
   * "no-unknown-elements" they are added here */
  "svg:desc": {},
  "svg:title": {},
  table: {
    flow: true,
    permittedContent: ["@script", "caption?", "colgroup", "tbody", "tfoot?", "thead?", "tr"],
    permittedOrder: ["caption", "colgroup", "thead", "tbody", "tr", "tfoot"],
    attributes: {
      align: {
        deprecated: true
      },
      background: {
        deprecated: true
      },
      bgcolor: {
        deprecated: true
      },
      bordercolor: {
        deprecated: true
      },
      cellpadding: {
        deprecated: true
      },
      cellspacing: {
        deprecated: true
      },
      dataformatas: {
        deprecated: true
      },
      datapagesize: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      },
      frame: {
        deprecated: true
      },
      rules: {
        deprecated: true
      },
      summary: {
        deprecated: true
      },
      width: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "table"
    }
  },
  tbody: {
    implicitClosed: ["tbody", "tfoot"],
    permittedContent: ["@script", "tr"],
    attributes: {
      align: {
        deprecated: true
      },
      background: {
        deprecated: true
      },
      char: {
        deprecated: true
      },
      charoff: {
        deprecated: true
      },
      valign: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "rowgroup"
    }
  },
  td: {
    flow: true,
    implicitClosed: ["td", "th"],
    attributes: {
      align: {
        deprecated: true
      },
      axis: {
        deprecated: true
      },
      background: {
        deprecated: true
      },
      bgcolor: {
        deprecated: true
      },
      char: {
        deprecated: true
      },
      charoff: {
        deprecated: true
      },
      colspan: {
        enum: ["/\\d+/"]
      },
      height: {
        deprecated: true
      },
      nowrap: {
        deprecated: true
      },
      rowspan: {
        enum: ["/\\d+/"]
      },
      scope: {
        deprecated: true
      },
      valign: {
        deprecated: true
      },
      width: {
        deprecated: true
      }
    },
    aria: {
      implicitRole(node) {
        const table2 = node.closest("table");
        const tableRole = table2?.getAttribute("role") ?? "table";
        switch (tableRole) {
          case "table":
            return "cell";
          case "grid":
          case "treegrid":
            return "gridcell";
          default:
            return null;
        }
      }
    },
    permittedContent: ["@flow"]
  },
  template: {
    metadata: true,
    flow: true,
    phrasing: true,
    scriptSupporting: true,
    templateRoot: true,
    aria: {
      naming: "prohibited"
    }
  },
  textarea: {
    flow: true,
    focusable: true,
    phrasing: true,
    interactive: true,
    formAssociated: {
      disablable: true,
      listed: true
    },
    labelable: true,
    attributes: {
      autocomplete: {},
      autofocus: {
        boolean: true
      },
      cols: {
        enum: ["/\\d+/"]
      },
      datafld: {
        deprecated: true
      },
      datasrc: {
        deprecated: true
      },
      disabled: {
        boolean: true
      },
      maxlength: {
        enum: ["/\\d+/"]
      },
      minlength: {
        enum: ["/\\d+/"]
      },
      readonly: {
        boolean: true
      },
      required: {
        boolean: true
      },
      rows: {
        enum: ["/\\d+/"]
      },
      wrap: {
        enum: ["hard", "soft"]
      }
    },
    aria: {
      implicitRole: "textbox"
    },
    permittedContent: []
  },
  tfoot: {
    implicitClosed: ["tbody"],
    permittedContent: ["@script", "tr"],
    attributes: {
      align: {
        deprecated: true
      },
      background: {
        deprecated: true
      },
      char: {
        deprecated: true
      },
      charoff: {
        deprecated: true
      },
      valign: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "rowgroup"
    }
  },
  th: {
    flow: true,
    implicitClosed: ["td", "th"],
    attributes: {
      align: {
        deprecated: true
      },
      axis: {
        deprecated: true
      },
      background: {
        deprecated: true
      },
      bgcolor: {
        deprecated: true
      },
      char: {
        deprecated: true
      },
      charoff: {
        deprecated: true
      },
      colspan: {
        enum: ["/\\d+/"]
      },
      height: {
        deprecated: true
      },
      nowrap: {
        deprecated: true
      },
      rowspan: {
        enum: ["/\\d+/"]
      },
      scope: {
        enum: ["row", "col", "rowgroup", "colgroup"]
      },
      valign: {
        deprecated: true
      },
      width: {
        deprecated: true
      }
    },
    aria: {
      implicitRole(node) {
        const table2 = node.closest("table");
        const tableRole = table2?.getAttribute("role") ?? "table";
        if (typeof tableRole !== "string" || !["table", "grid", "treegrid"].includes(tableRole)) {
          return null;
        }
        const scope2 = node.getAttribute("scope");
        switch (scope2) {
          case "col":
            return "columnheader";
          case "row":
            return "rowheader";
          default:
            return tableRole === "table" ? "cell" : "gridcell";
        }
      }
    },
    permittedContent: ["@flow"],
    permittedDescendants: [{ exclude: ["header", "footer", "@sectioning", "@heading"] }]
  },
  thead: {
    implicitClosed: ["tbody", "tfoot"],
    permittedContent: ["@script", "tr"],
    attributes: {
      align: {
        deprecated: true
      },
      background: {
        deprecated: true
      },
      char: {
        deprecated: true
      },
      charoff: {
        deprecated: true
      },
      valign: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "rowgroup"
    }
  },
  time: {
    flow: true,
    phrasing: true,
    aria: {
      implicitRole: "time",
      naming: "prohibited"
    },
    permittedContent: ["@phrasing"]
  },
  title: {
    metadata: true,
    permittedContent: [],
    permittedParent: ["head"],
    aria: {
      naming: "prohibited"
    }
  },
  tr: {
    implicitClosed: ["tr"],
    permittedContent: ["@script", "td", "th"],
    attributes: {
      align: {
        deprecated: true
      },
      background: {
        deprecated: true
      },
      bgcolor: {
        deprecated: true
      },
      char: {
        deprecated: true
      },
      charoff: {
        deprecated: true
      },
      valign: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "row"
    }
  },
  track: {
    void: true,
    aria: {
      naming: "prohibited"
    }
  },
  tt: {
    deprecated: {
      documentation: "Use a more semantically correct element such as `<code>`, `<var>` or `<pre>`.",
      source: "html4"
    }
  },
  u: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      implicitRole: "generic",
      naming: "prohibited"
    }
  },
  ul: {
    flow: true,
    permittedContent: ["@script", "li"],
    attributes: {
      compact: {
        deprecated: true
      },
      type: {
        deprecated: true
      }
    },
    aria: {
      implicitRole: "list"
    }
  },
  var: {
    flow: true,
    phrasing: true,
    permittedContent: ["@phrasing"],
    aria: {
      naming: "prohibited"
    }
  },
  video: {
    flow: true,
    focusable(node) {
      return node.hasAttribute("controls");
    },
    phrasing: true,
    embedded: true,
    interactive(node) {
      return node.hasAttribute("controls");
    },
    transparent: ["@flow"],
    attributes: {
      crossorigin: {
        omit: true,
        enum: ["anonymous", "use-credentials"]
      },
      height: {
        enum: ["/\\d+/"]
      },
      itemprop: {
        allowed: allowedIfAttributeIsPresent2("src")
      },
      preload: {
        omit: true,
        enum: ["none", "metadata", "auto"]
      },
      width: {
        enum: ["/\\d+/"]
      }
    },
    permittedContent: ["@flow", "track", "source"],
    permittedDescendants: [{ exclude: ["audio", "video"] }],
    permittedOrder: ["source", "track", "@flow"]
  },
  wbr: {
    flow: true,
    phrasing: true,
    void: true,
    aria: {
      naming: "prohibited"
    }
  },
  xmp: {
    deprecated: {
      documentation: "Use `<pre>` or `<code>` and escape content using HTML entities instead.",
      source: "html32"
    }
  }
});
var bundledElements = {
  html5
};
var entities = [
  "&Aacute",
  "&aacute",
  "&Aacute;",
  "&aacute;",
  "&Abreve;",
  "&abreve;",
  "&ac;",
  "&acd;",
  "&acE;",
  "&Acirc",
  "&acirc",
  "&Acirc;",
  "&acirc;",
  "&acute",
  "&acute;",
  "&Acy;",
  "&acy;",
  "&AElig",
  "&aelig",
  "&AElig;",
  "&aelig;",
  "&af;",
  "&Afr;",
  "&afr;",
  "&Agrave",
  "&agrave",
  "&Agrave;",
  "&agrave;",
  "&alefsym;",
  "&aleph;",
  "&Alpha;",
  "&alpha;",
  "&Amacr;",
  "&amacr;",
  "&amalg;",
  "&AMP",
  "&amp",
  "&AMP;",
  "&amp;",
  "&And;",
  "&and;",
  "&andand;",
  "&andd;",
  "&andslope;",
  "&andv;",
  "&ang;",
  "&ange;",
  "&angle;",
  "&angmsd;",
  "&angmsdaa;",
  "&angmsdab;",
  "&angmsdac;",
  "&angmsdad;",
  "&angmsdae;",
  "&angmsdaf;",
  "&angmsdag;",
  "&angmsdah;",
  "&angrt;",
  "&angrtvb;",
  "&angrtvbd;",
  "&angsph;",
  "&angst;",
  "&angzarr;",
  "&Aogon;",
  "&aogon;",
  "&Aopf;",
  "&aopf;",
  "&ap;",
  "&apacir;",
  "&apE;",
  "&ape;",
  "&apid;",
  "&apos;",
  "&ApplyFunction;",
  "&approx;",
  "&approxeq;",
  "&Aring",
  "&aring",
  "&Aring;",
  "&aring;",
  "&Ascr;",
  "&ascr;",
  "&Assign;",
  "&ast;",
  "&asymp;",
  "&asympeq;",
  "&Atilde",
  "&atilde",
  "&Atilde;",
  "&atilde;",
  "&Auml",
  "&auml",
  "&Auml;",
  "&auml;",
  "&awconint;",
  "&awint;",
  "&backcong;",
  "&backepsilon;",
  "&backprime;",
  "&backsim;",
  "&backsimeq;",
  "&Backslash;",
  "&Barv;",
  "&barvee;",
  "&Barwed;",
  "&barwed;",
  "&barwedge;",
  "&bbrk;",
  "&bbrktbrk;",
  "&bcong;",
  "&Bcy;",
  "&bcy;",
  "&bdquo;",
  "&becaus;",
  "&Because;",
  "&because;",
  "&bemptyv;",
  "&bepsi;",
  "&bernou;",
  "&Bernoullis;",
  "&Beta;",
  "&beta;",
  "&beth;",
  "&between;",
  "&Bfr;",
  "&bfr;",
  "&bigcap;",
  "&bigcirc;",
  "&bigcup;",
  "&bigodot;",
  "&bigoplus;",
  "&bigotimes;",
  "&bigsqcup;",
  "&bigstar;",
  "&bigtriangledown;",
  "&bigtriangleup;",
  "&biguplus;",
  "&bigvee;",
  "&bigwedge;",
  "&bkarow;",
  "&blacklozenge;",
  "&blacksquare;",
  "&blacktriangle;",
  "&blacktriangledown;",
  "&blacktriangleleft;",
  "&blacktriangleright;",
  "&blank;",
  "&blk12;",
  "&blk14;",
  "&blk34;",
  "&block;",
  "&bne;",
  "&bnequiv;",
  "&bNot;",
  "&bnot;",
  "&Bopf;",
  "&bopf;",
  "&bot;",
  "&bottom;",
  "&bowtie;",
  "&boxbox;",
  "&boxDL;",
  "&boxDl;",
  "&boxdL;",
  "&boxdl;",
  "&boxDR;",
  "&boxDr;",
  "&boxdR;",
  "&boxdr;",
  "&boxH;",
  "&boxh;",
  "&boxHD;",
  "&boxHd;",
  "&boxhD;",
  "&boxhd;",
  "&boxHU;",
  "&boxHu;",
  "&boxhU;",
  "&boxhu;",
  "&boxminus;",
  "&boxplus;",
  "&boxtimes;",
  "&boxUL;",
  "&boxUl;",
  "&boxuL;",
  "&boxul;",
  "&boxUR;",
  "&boxUr;",
  "&boxuR;",
  "&boxur;",
  "&boxV;",
  "&boxv;",
  "&boxVH;",
  "&boxVh;",
  "&boxvH;",
  "&boxvh;",
  "&boxVL;",
  "&boxVl;",
  "&boxvL;",
  "&boxvl;",
  "&boxVR;",
  "&boxVr;",
  "&boxvR;",
  "&boxvr;",
  "&bprime;",
  "&Breve;",
  "&breve;",
  "&brvbar",
  "&brvbar;",
  "&Bscr;",
  "&bscr;",
  "&bsemi;",
  "&bsim;",
  "&bsime;",
  "&bsol;",
  "&bsolb;",
  "&bsolhsub;",
  "&bull;",
  "&bullet;",
  "&bump;",
  "&bumpE;",
  "&bumpe;",
  "&Bumpeq;",
  "&bumpeq;",
  "&Cacute;",
  "&cacute;",
  "&Cap;",
  "&cap;",
  "&capand;",
  "&capbrcup;",
  "&capcap;",
  "&capcup;",
  "&capdot;",
  "&CapitalDifferentialD;",
  "&caps;",
  "&caret;",
  "&caron;",
  "&Cayleys;",
  "&ccaps;",
  "&Ccaron;",
  "&ccaron;",
  "&Ccedil",
  "&ccedil",
  "&Ccedil;",
  "&ccedil;",
  "&Ccirc;",
  "&ccirc;",
  "&Cconint;",
  "&ccups;",
  "&ccupssm;",
  "&Cdot;",
  "&cdot;",
  "&cedil",
  "&cedil;",
  "&Cedilla;",
  "&cemptyv;",
  "&cent",
  "&cent;",
  "&CenterDot;",
  "&centerdot;",
  "&Cfr;",
  "&cfr;",
  "&CHcy;",
  "&chcy;",
  "&check;",
  "&checkmark;",
  "&Chi;",
  "&chi;",
  "&cir;",
  "&circ;",
  "&circeq;",
  "&circlearrowleft;",
  "&circlearrowright;",
  "&circledast;",
  "&circledcirc;",
  "&circleddash;",
  "&CircleDot;",
  "&circledR;",
  "&circledS;",
  "&CircleMinus;",
  "&CirclePlus;",
  "&CircleTimes;",
  "&cirE;",
  "&cire;",
  "&cirfnint;",
  "&cirmid;",
  "&cirscir;",
  "&ClockwiseContourIntegral;",
  "&CloseCurlyDoubleQuote;",
  "&CloseCurlyQuote;",
  "&clubs;",
  "&clubsuit;",
  "&Colon;",
  "&colon;",
  "&Colone;",
  "&colone;",
  "&coloneq;",
  "&comma;",
  "&commat;",
  "&comp;",
  "&compfn;",
  "&complement;",
  "&complexes;",
  "&cong;",
  "&congdot;",
  "&Congruent;",
  "&Conint;",
  "&conint;",
  "&ContourIntegral;",
  "&Copf;",
  "&copf;",
  "&coprod;",
  "&Coproduct;",
  "&COPY",
  "&copy",
  "&COPY;",
  "&copy;",
  "&copysr;",
  "&CounterClockwiseContourIntegral;",
  "&crarr;",
  "&Cross;",
  "&cross;",
  "&Cscr;",
  "&cscr;",
  "&csub;",
  "&csube;",
  "&csup;",
  "&csupe;",
  "&ctdot;",
  "&cudarrl;",
  "&cudarrr;",
  "&cuepr;",
  "&cuesc;",
  "&cularr;",
  "&cularrp;",
  "&Cup;",
  "&cup;",
  "&cupbrcap;",
  "&CupCap;",
  "&cupcap;",
  "&cupcup;",
  "&cupdot;",
  "&cupor;",
  "&cups;",
  "&curarr;",
  "&curarrm;",
  "&curlyeqprec;",
  "&curlyeqsucc;",
  "&curlyvee;",
  "&curlywedge;",
  "&curren",
  "&curren;",
  "&curvearrowleft;",
  "&curvearrowright;",
  "&cuvee;",
  "&cuwed;",
  "&cwconint;",
  "&cwint;",
  "&cylcty;",
  "&Dagger;",
  "&dagger;",
  "&daleth;",
  "&Darr;",
  "&dArr;",
  "&darr;",
  "&dash;",
  "&Dashv;",
  "&dashv;",
  "&dbkarow;",
  "&dblac;",
  "&Dcaron;",
  "&dcaron;",
  "&Dcy;",
  "&dcy;",
  "&DD;",
  "&dd;",
  "&ddagger;",
  "&ddarr;",
  "&DDotrahd;",
  "&ddotseq;",
  "&deg",
  "&deg;",
  "&Del;",
  "&Delta;",
  "&delta;",
  "&demptyv;",
  "&dfisht;",
  "&Dfr;",
  "&dfr;",
  "&dHar;",
  "&dharl;",
  "&dharr;",
  "&DiacriticalAcute;",
  "&DiacriticalDot;",
  "&DiacriticalDoubleAcute;",
  "&DiacriticalGrave;",
  "&DiacriticalTilde;",
  "&diam;",
  "&Diamond;",
  "&diamond;",
  "&diamondsuit;",
  "&diams;",
  "&die;",
  "&DifferentialD;",
  "&digamma;",
  "&disin;",
  "&div;",
  "&divide",
  "&divide;",
  "&divideontimes;",
  "&divonx;",
  "&DJcy;",
  "&djcy;",
  "&dlcorn;",
  "&dlcrop;",
  "&dollar;",
  "&Dopf;",
  "&dopf;",
  "&Dot;",
  "&dot;",
  "&DotDot;",
  "&doteq;",
  "&doteqdot;",
  "&DotEqual;",
  "&dotminus;",
  "&dotplus;",
  "&dotsquare;",
  "&doublebarwedge;",
  "&DoubleContourIntegral;",
  "&DoubleDot;",
  "&DoubleDownArrow;",
  "&DoubleLeftArrow;",
  "&DoubleLeftRightArrow;",
  "&DoubleLeftTee;",
  "&DoubleLongLeftArrow;",
  "&DoubleLongLeftRightArrow;",
  "&DoubleLongRightArrow;",
  "&DoubleRightArrow;",
  "&DoubleRightTee;",
  "&DoubleUpArrow;",
  "&DoubleUpDownArrow;",
  "&DoubleVerticalBar;",
  "&DownArrow;",
  "&Downarrow;",
  "&downarrow;",
  "&DownArrowBar;",
  "&DownArrowUpArrow;",
  "&DownBreve;",
  "&downdownarrows;",
  "&downharpoonleft;",
  "&downharpoonright;",
  "&DownLeftRightVector;",
  "&DownLeftTeeVector;",
  "&DownLeftVector;",
  "&DownLeftVectorBar;",
  "&DownRightTeeVector;",
  "&DownRightVector;",
  "&DownRightVectorBar;",
  "&DownTee;",
  "&DownTeeArrow;",
  "&drbkarow;",
  "&drcorn;",
  "&drcrop;",
  "&Dscr;",
  "&dscr;",
  "&DScy;",
  "&dscy;",
  "&dsol;",
  "&Dstrok;",
  "&dstrok;",
  "&dtdot;",
  "&dtri;",
  "&dtrif;",
  "&duarr;",
  "&duhar;",
  "&dwangle;",
  "&DZcy;",
  "&dzcy;",
  "&dzigrarr;",
  "&Eacute",
  "&eacute",
  "&Eacute;",
  "&eacute;",
  "&easter;",
  "&Ecaron;",
  "&ecaron;",
  "&ecir;",
  "&Ecirc",
  "&ecirc",
  "&Ecirc;",
  "&ecirc;",
  "&ecolon;",
  "&Ecy;",
  "&ecy;",
  "&eDDot;",
  "&Edot;",
  "&eDot;",
  "&edot;",
  "&ee;",
  "&efDot;",
  "&Efr;",
  "&efr;",
  "&eg;",
  "&Egrave",
  "&egrave",
  "&Egrave;",
  "&egrave;",
  "&egs;",
  "&egsdot;",
  "&el;",
  "&Element;",
  "&elinters;",
  "&ell;",
  "&els;",
  "&elsdot;",
  "&Emacr;",
  "&emacr;",
  "&empty;",
  "&emptyset;",
  "&EmptySmallSquare;",
  "&emptyv;",
  "&EmptyVerySmallSquare;",
  "&emsp13;",
  "&emsp14;",
  "&emsp;",
  "&ENG;",
  "&eng;",
  "&ensp;",
  "&Eogon;",
  "&eogon;",
  "&Eopf;",
  "&eopf;",
  "&epar;",
  "&eparsl;",
  "&eplus;",
  "&epsi;",
  "&Epsilon;",
  "&epsilon;",
  "&epsiv;",
  "&eqcirc;",
  "&eqcolon;",
  "&eqsim;",
  "&eqslantgtr;",
  "&eqslantless;",
  "&Equal;",
  "&equals;",
  "&EqualTilde;",
  "&equest;",
  "&Equilibrium;",
  "&equiv;",
  "&equivDD;",
  "&eqvparsl;",
  "&erarr;",
  "&erDot;",
  "&Escr;",
  "&escr;",
  "&esdot;",
  "&Esim;",
  "&esim;",
  "&Eta;",
  "&eta;",
  "&ETH",
  "&eth",
  "&ETH;",
  "&eth;",
  "&Euml",
  "&euml",
  "&Euml;",
  "&euml;",
  "&euro;",
  "&excl;",
  "&exist;",
  "&Exists;",
  "&expectation;",
  "&ExponentialE;",
  "&exponentiale;",
  "&fallingdotseq;",
  "&Fcy;",
  "&fcy;",
  "&female;",
  "&ffilig;",
  "&fflig;",
  "&ffllig;",
  "&Ffr;",
  "&ffr;",
  "&filig;",
  "&FilledSmallSquare;",
  "&FilledVerySmallSquare;",
  "&fjlig;",
  "&flat;",
  "&fllig;",
  "&fltns;",
  "&fnof;",
  "&Fopf;",
  "&fopf;",
  "&ForAll;",
  "&forall;",
  "&fork;",
  "&forkv;",
  "&Fouriertrf;",
  "&fpartint;",
  "&frac12",
  "&frac12;",
  "&frac13;",
  "&frac14",
  "&frac14;",
  "&frac15;",
  "&frac16;",
  "&frac18;",
  "&frac23;",
  "&frac25;",
  "&frac34",
  "&frac34;",
  "&frac35;",
  "&frac38;",
  "&frac45;",
  "&frac56;",
  "&frac58;",
  "&frac78;",
  "&frasl;",
  "&frown;",
  "&Fscr;",
  "&fscr;",
  "&gacute;",
  "&Gamma;",
  "&gamma;",
  "&Gammad;",
  "&gammad;",
  "&gap;",
  "&Gbreve;",
  "&gbreve;",
  "&Gcedil;",
  "&Gcirc;",
  "&gcirc;",
  "&Gcy;",
  "&gcy;",
  "&Gdot;",
  "&gdot;",
  "&gE;",
  "&ge;",
  "&gEl;",
  "&gel;",
  "&geq;",
  "&geqq;",
  "&geqslant;",
  "&ges;",
  "&gescc;",
  "&gesdot;",
  "&gesdoto;",
  "&gesdotol;",
  "&gesl;",
  "&gesles;",
  "&Gfr;",
  "&gfr;",
  "&Gg;",
  "&gg;",
  "&ggg;",
  "&gimel;",
  "&GJcy;",
  "&gjcy;",
  "&gl;",
  "&gla;",
  "&glE;",
  "&glj;",
  "&gnap;",
  "&gnapprox;",
  "&gnE;",
  "&gne;",
  "&gneq;",
  "&gneqq;",
  "&gnsim;",
  "&Gopf;",
  "&gopf;",
  "&grave;",
  "&GreaterEqual;",
  "&GreaterEqualLess;",
  "&GreaterFullEqual;",
  "&GreaterGreater;",
  "&GreaterLess;",
  "&GreaterSlantEqual;",
  "&GreaterTilde;",
  "&Gscr;",
  "&gscr;",
  "&gsim;",
  "&gsime;",
  "&gsiml;",
  "&GT",
  "&gt",
  "&GT;",
  "&Gt;",
  "&gt;",
  "&gtcc;",
  "&gtcir;",
  "&gtdot;",
  "&gtlPar;",
  "&gtquest;",
  "&gtrapprox;",
  "&gtrarr;",
  "&gtrdot;",
  "&gtreqless;",
  "&gtreqqless;",
  "&gtrless;",
  "&gtrsim;",
  "&gvertneqq;",
  "&gvnE;",
  "&Hacek;",
  "&hairsp;",
  "&half;",
  "&hamilt;",
  "&HARDcy;",
  "&hardcy;",
  "&hArr;",
  "&harr;",
  "&harrcir;",
  "&harrw;",
  "&Hat;",
  "&hbar;",
  "&Hcirc;",
  "&hcirc;",
  "&hearts;",
  "&heartsuit;",
  "&hellip;",
  "&hercon;",
  "&Hfr;",
  "&hfr;",
  "&HilbertSpace;",
  "&hksearow;",
  "&hkswarow;",
  "&hoarr;",
  "&homtht;",
  "&hookleftarrow;",
  "&hookrightarrow;",
  "&Hopf;",
  "&hopf;",
  "&horbar;",
  "&HorizontalLine;",
  "&Hscr;",
  "&hscr;",
  "&hslash;",
  "&Hstrok;",
  "&hstrok;",
  "&HumpDownHump;",
  "&HumpEqual;",
  "&hybull;",
  "&hyphen;",
  "&Iacute",
  "&iacute",
  "&Iacute;",
  "&iacute;",
  "&ic;",
  "&Icirc",
  "&icirc",
  "&Icirc;",
  "&icirc;",
  "&Icy;",
  "&icy;",
  "&Idot;",
  "&IEcy;",
  "&iecy;",
  "&iexcl",
  "&iexcl;",
  "&iff;",
  "&Ifr;",
  "&ifr;",
  "&Igrave",
  "&igrave",
  "&Igrave;",
  "&igrave;",
  "&ii;",
  "&iiiint;",
  "&iiint;",
  "&iinfin;",
  "&iiota;",
  "&IJlig;",
  "&ijlig;",
  "&Im;",
  "&Imacr;",
  "&imacr;",
  "&image;",
  "&ImaginaryI;",
  "&imagline;",
  "&imagpart;",
  "&imath;",
  "&imof;",
  "&imped;",
  "&Implies;",
  "&in;",
  "&incare;",
  "&infin;",
  "&infintie;",
  "&inodot;",
  "&Int;",
  "&int;",
  "&intcal;",
  "&integers;",
  "&Integral;",
  "&intercal;",
  "&Intersection;",
  "&intlarhk;",
  "&intprod;",
  "&InvisibleComma;",
  "&InvisibleTimes;",
  "&IOcy;",
  "&iocy;",
  "&Iogon;",
  "&iogon;",
  "&Iopf;",
  "&iopf;",
  "&Iota;",
  "&iota;",
  "&iprod;",
  "&iquest",
  "&iquest;",
  "&Iscr;",
  "&iscr;",
  "&isin;",
  "&isindot;",
  "&isinE;",
  "&isins;",
  "&isinsv;",
  "&isinv;",
  "&it;",
  "&Itilde;",
  "&itilde;",
  "&Iukcy;",
  "&iukcy;",
  "&Iuml",
  "&iuml",
  "&Iuml;",
  "&iuml;",
  "&Jcirc;",
  "&jcirc;",
  "&Jcy;",
  "&jcy;",
  "&Jfr;",
  "&jfr;",
  "&jmath;",
  "&Jopf;",
  "&jopf;",
  "&Jscr;",
  "&jscr;",
  "&Jsercy;",
  "&jsercy;",
  "&Jukcy;",
  "&jukcy;",
  "&Kappa;",
  "&kappa;",
  "&kappav;",
  "&Kcedil;",
  "&kcedil;",
  "&Kcy;",
  "&kcy;",
  "&Kfr;",
  "&kfr;",
  "&kgreen;",
  "&KHcy;",
  "&khcy;",
  "&KJcy;",
  "&kjcy;",
  "&Kopf;",
  "&kopf;",
  "&Kscr;",
  "&kscr;",
  "&lAarr;",
  "&Lacute;",
  "&lacute;",
  "&laemptyv;",
  "&lagran;",
  "&Lambda;",
  "&lambda;",
  "&Lang;",
  "&lang;",
  "&langd;",
  "&langle;",
  "&lap;",
  "&Laplacetrf;",
  "&laquo",
  "&laquo;",
  "&Larr;",
  "&lArr;",
  "&larr;",
  "&larrb;",
  "&larrbfs;",
  "&larrfs;",
  "&larrhk;",
  "&larrlp;",
  "&larrpl;",
  "&larrsim;",
  "&larrtl;",
  "&lat;",
  "&lAtail;",
  "&latail;",
  "&late;",
  "&lates;",
  "&lBarr;",
  "&lbarr;",
  "&lbbrk;",
  "&lbrace;",
  "&lbrack;",
  "&lbrke;",
  "&lbrksld;",
  "&lbrkslu;",
  "&Lcaron;",
  "&lcaron;",
  "&Lcedil;",
  "&lcedil;",
  "&lceil;",
  "&lcub;",
  "&Lcy;",
  "&lcy;",
  "&ldca;",
  "&ldquo;",
  "&ldquor;",
  "&ldrdhar;",
  "&ldrushar;",
  "&ldsh;",
  "&lE;",
  "&le;",
  "&LeftAngleBracket;",
  "&LeftArrow;",
  "&Leftarrow;",
  "&leftarrow;",
  "&LeftArrowBar;",
  "&LeftArrowRightArrow;",
  "&leftarrowtail;",
  "&LeftCeiling;",
  "&LeftDoubleBracket;",
  "&LeftDownTeeVector;",
  "&LeftDownVector;",
  "&LeftDownVectorBar;",
  "&LeftFloor;",
  "&leftharpoondown;",
  "&leftharpoonup;",
  "&leftleftarrows;",
  "&LeftRightArrow;",
  "&Leftrightarrow;",
  "&leftrightarrow;",
  "&leftrightarrows;",
  "&leftrightharpoons;",
  "&leftrightsquigarrow;",
  "&LeftRightVector;",
  "&LeftTee;",
  "&LeftTeeArrow;",
  "&LeftTeeVector;",
  "&leftthreetimes;",
  "&LeftTriangle;",
  "&LeftTriangleBar;",
  "&LeftTriangleEqual;",
  "&LeftUpDownVector;",
  "&LeftUpTeeVector;",
  "&LeftUpVector;",
  "&LeftUpVectorBar;",
  "&LeftVector;",
  "&LeftVectorBar;",
  "&lEg;",
  "&leg;",
  "&leq;",
  "&leqq;",
  "&leqslant;",
  "&les;",
  "&lescc;",
  "&lesdot;",
  "&lesdoto;",
  "&lesdotor;",
  "&lesg;",
  "&lesges;",
  "&lessapprox;",
  "&lessdot;",
  "&lesseqgtr;",
  "&lesseqqgtr;",
  "&LessEqualGreater;",
  "&LessFullEqual;",
  "&LessGreater;",
  "&lessgtr;",
  "&LessLess;",
  "&lesssim;",
  "&LessSlantEqual;",
  "&LessTilde;",
  "&lfisht;",
  "&lfloor;",
  "&Lfr;",
  "&lfr;",
  "&lg;",
  "&lgE;",
  "&lHar;",
  "&lhard;",
  "&lharu;",
  "&lharul;",
  "&lhblk;",
  "&LJcy;",
  "&ljcy;",
  "&Ll;",
  "&ll;",
  "&llarr;",
  "&llcorner;",
  "&Lleftarrow;",
  "&llhard;",
  "&lltri;",
  "&Lmidot;",
  "&lmidot;",
  "&lmoust;",
  "&lmoustache;",
  "&lnap;",
  "&lnapprox;",
  "&lnE;",
  "&lne;",
  "&lneq;",
  "&lneqq;",
  "&lnsim;",
  "&loang;",
  "&loarr;",
  "&lobrk;",
  "&LongLeftArrow;",
  "&Longleftarrow;",
  "&longleftarrow;",
  "&LongLeftRightArrow;",
  "&Longleftrightarrow;",
  "&longleftrightarrow;",
  "&longmapsto;",
  "&LongRightArrow;",
  "&Longrightarrow;",
  "&longrightarrow;",
  "&looparrowleft;",
  "&looparrowright;",
  "&lopar;",
  "&Lopf;",
  "&lopf;",
  "&loplus;",
  "&lotimes;",
  "&lowast;",
  "&lowbar;",
  "&LowerLeftArrow;",
  "&LowerRightArrow;",
  "&loz;",
  "&lozenge;",
  "&lozf;",
  "&lpar;",
  "&lparlt;",
  "&lrarr;",
  "&lrcorner;",
  "&lrhar;",
  "&lrhard;",
  "&lrm;",
  "&lrtri;",
  "&lsaquo;",
  "&Lscr;",
  "&lscr;",
  "&Lsh;",
  "&lsh;",
  "&lsim;",
  "&lsime;",
  "&lsimg;",
  "&lsqb;",
  "&lsquo;",
  "&lsquor;",
  "&Lstrok;",
  "&lstrok;",
  "&LT",
  "&lt",
  "&LT;",
  "&Lt;",
  "&lt;",
  "&ltcc;",
  "&ltcir;",
  "&ltdot;",
  "&lthree;",
  "&ltimes;",
  "&ltlarr;",
  "&ltquest;",
  "&ltri;",
  "&ltrie;",
  "&ltrif;",
  "&ltrPar;",
  "&lurdshar;",
  "&luruhar;",
  "&lvertneqq;",
  "&lvnE;",
  "&macr",
  "&macr;",
  "&male;",
  "&malt;",
  "&maltese;",
  "&Map;",
  "&map;",
  "&mapsto;",
  "&mapstodown;",
  "&mapstoleft;",
  "&mapstoup;",
  "&marker;",
  "&mcomma;",
  "&Mcy;",
  "&mcy;",
  "&mdash;",
  "&mDDot;",
  "&measuredangle;",
  "&MediumSpace;",
  "&Mellintrf;",
  "&Mfr;",
  "&mfr;",
  "&mho;",
  "&micro",
  "&micro;",
  "&mid;",
  "&midast;",
  "&midcir;",
  "&middot",
  "&middot;",
  "&minus;",
  "&minusb;",
  "&minusd;",
  "&minusdu;",
  "&MinusPlus;",
  "&mlcp;",
  "&mldr;",
  "&mnplus;",
  "&models;",
  "&Mopf;",
  "&mopf;",
  "&mp;",
  "&Mscr;",
  "&mscr;",
  "&mstpos;",
  "&Mu;",
  "&mu;",
  "&multimap;",
  "&mumap;",
  "&nabla;",
  "&Nacute;",
  "&nacute;",
  "&nang;",
  "&nap;",
  "&napE;",
  "&napid;",
  "&napos;",
  "&napprox;",
  "&natur;",
  "&natural;",
  "&naturals;",
  "&nbsp",
  "&nbsp;",
  "&nbump;",
  "&nbumpe;",
  "&ncap;",
  "&Ncaron;",
  "&ncaron;",
  "&Ncedil;",
  "&ncedil;",
  "&ncong;",
  "&ncongdot;",
  "&ncup;",
  "&Ncy;",
  "&ncy;",
  "&ndash;",
  "&ne;",
  "&nearhk;",
  "&neArr;",
  "&nearr;",
  "&nearrow;",
  "&nedot;",
  "&NegativeMediumSpace;",
  "&NegativeThickSpace;",
  "&NegativeThinSpace;",
  "&NegativeVeryThinSpace;",
  "&nequiv;",
  "&nesear;",
  "&nesim;",
  "&NestedGreaterGreater;",
  "&NestedLessLess;",
  "&NewLine;",
  "&nexist;",
  "&nexists;",
  "&Nfr;",
  "&nfr;",
  "&ngE;",
  "&nge;",
  "&ngeq;",
  "&ngeqq;",
  "&ngeqslant;",
  "&nges;",
  "&nGg;",
  "&ngsim;",
  "&nGt;",
  "&ngt;",
  "&ngtr;",
  "&nGtv;",
  "&nhArr;",
  "&nharr;",
  "&nhpar;",
  "&ni;",
  "&nis;",
  "&nisd;",
  "&niv;",
  "&NJcy;",
  "&njcy;",
  "&nlArr;",
  "&nlarr;",
  "&nldr;",
  "&nlE;",
  "&nle;",
  "&nLeftarrow;",
  "&nleftarrow;",
  "&nLeftrightarrow;",
  "&nleftrightarrow;",
  "&nleq;",
  "&nleqq;",
  "&nleqslant;",
  "&nles;",
  "&nless;",
  "&nLl;",
  "&nlsim;",
  "&nLt;",
  "&nlt;",
  "&nltri;",
  "&nltrie;",
  "&nLtv;",
  "&nmid;",
  "&NoBreak;",
  "&NonBreakingSpace;",
  "&Nopf;",
  "&nopf;",
  "&not",
  "&Not;",
  "&not;",
  "&NotCongruent;",
  "&NotCupCap;",
  "&NotDoubleVerticalBar;",
  "&NotElement;",
  "&NotEqual;",
  "&NotEqualTilde;",
  "&NotExists;",
  "&NotGreater;",
  "&NotGreaterEqual;",
  "&NotGreaterFullEqual;",
  "&NotGreaterGreater;",
  "&NotGreaterLess;",
  "&NotGreaterSlantEqual;",
  "&NotGreaterTilde;",
  "&NotHumpDownHump;",
  "&NotHumpEqual;",
  "&notin;",
  "&notindot;",
  "&notinE;",
  "&notinva;",
  "&notinvb;",
  "&notinvc;",
  "&NotLeftTriangle;",
  "&NotLeftTriangleBar;",
  "&NotLeftTriangleEqual;",
  "&NotLess;",
  "&NotLessEqual;",
  "&NotLessGreater;",
  "&NotLessLess;",
  "&NotLessSlantEqual;",
  "&NotLessTilde;",
  "&NotNestedGreaterGreater;",
  "&NotNestedLessLess;",
  "&notni;",
  "&notniva;",
  "&notnivb;",
  "&notnivc;",
  "&NotPrecedes;",
  "&NotPrecedesEqual;",
  "&NotPrecedesSlantEqual;",
  "&NotReverseElement;",
  "&NotRightTriangle;",
  "&NotRightTriangleBar;",
  "&NotRightTriangleEqual;",
  "&NotSquareSubset;",
  "&NotSquareSubsetEqual;",
  "&NotSquareSuperset;",
  "&NotSquareSupersetEqual;",
  "&NotSubset;",
  "&NotSubsetEqual;",
  "&NotSucceeds;",
  "&NotSucceedsEqual;",
  "&NotSucceedsSlantEqual;",
  "&NotSucceedsTilde;",
  "&NotSuperset;",
  "&NotSupersetEqual;",
  "&NotTilde;",
  "&NotTildeEqual;",
  "&NotTildeFullEqual;",
  "&NotTildeTilde;",
  "&NotVerticalBar;",
  "&npar;",
  "&nparallel;",
  "&nparsl;",
  "&npart;",
  "&npolint;",
  "&npr;",
  "&nprcue;",
  "&npre;",
  "&nprec;",
  "&npreceq;",
  "&nrArr;",
  "&nrarr;",
  "&nrarrc;",
  "&nrarrw;",
  "&nRightarrow;",
  "&nrightarrow;",
  "&nrtri;",
  "&nrtrie;",
  "&nsc;",
  "&nsccue;",
  "&nsce;",
  "&Nscr;",
  "&nscr;",
  "&nshortmid;",
  "&nshortparallel;",
  "&nsim;",
  "&nsime;",
  "&nsimeq;",
  "&nsmid;",
  "&nspar;",
  "&nsqsube;",
  "&nsqsupe;",
  "&nsub;",
  "&nsubE;",
  "&nsube;",
  "&nsubset;",
  "&nsubseteq;",
  "&nsubseteqq;",
  "&nsucc;",
  "&nsucceq;",
  "&nsup;",
  "&nsupE;",
  "&nsupe;",
  "&nsupset;",
  "&nsupseteq;",
  "&nsupseteqq;",
  "&ntgl;",
  "&Ntilde",
  "&ntilde",
  "&Ntilde;",
  "&ntilde;",
  "&ntlg;",
  "&ntriangleleft;",
  "&ntrianglelefteq;",
  "&ntriangleright;",
  "&ntrianglerighteq;",
  "&Nu;",
  "&nu;",
  "&num;",
  "&numero;",
  "&numsp;",
  "&nvap;",
  "&nVDash;",
  "&nVdash;",
  "&nvDash;",
  "&nvdash;",
  "&nvge;",
  "&nvgt;",
  "&nvHarr;",
  "&nvinfin;",
  "&nvlArr;",
  "&nvle;",
  "&nvlt;",
  "&nvltrie;",
  "&nvrArr;",
  "&nvrtrie;",
  "&nvsim;",
  "&nwarhk;",
  "&nwArr;",
  "&nwarr;",
  "&nwarrow;",
  "&nwnear;",
  "&Oacute",
  "&oacute",
  "&Oacute;",
  "&oacute;",
  "&oast;",
  "&ocir;",
  "&Ocirc",
  "&ocirc",
  "&Ocirc;",
  "&ocirc;",
  "&Ocy;",
  "&ocy;",
  "&odash;",
  "&Odblac;",
  "&odblac;",
  "&odiv;",
  "&odot;",
  "&odsold;",
  "&OElig;",
  "&oelig;",
  "&ofcir;",
  "&Ofr;",
  "&ofr;",
  "&ogon;",
  "&Ograve",
  "&ograve",
  "&Ograve;",
  "&ograve;",
  "&ogt;",
  "&ohbar;",
  "&ohm;",
  "&oint;",
  "&olarr;",
  "&olcir;",
  "&olcross;",
  "&oline;",
  "&olt;",
  "&Omacr;",
  "&omacr;",
  "&Omega;",
  "&omega;",
  "&Omicron;",
  "&omicron;",
  "&omid;",
  "&ominus;",
  "&Oopf;",
  "&oopf;",
  "&opar;",
  "&OpenCurlyDoubleQuote;",
  "&OpenCurlyQuote;",
  "&operp;",
  "&oplus;",
  "&Or;",
  "&or;",
  "&orarr;",
  "&ord;",
  "&order;",
  "&orderof;",
  "&ordf",
  "&ordf;",
  "&ordm",
  "&ordm;",
  "&origof;",
  "&oror;",
  "&orslope;",
  "&orv;",
  "&oS;",
  "&Oscr;",
  "&oscr;",
  "&Oslash",
  "&oslash",
  "&Oslash;",
  "&oslash;",
  "&osol;",
  "&Otilde",
  "&otilde",
  "&Otilde;",
  "&otilde;",
  "&Otimes;",
  "&otimes;",
  "&otimesas;",
  "&Ouml",
  "&ouml",
  "&Ouml;",
  "&ouml;",
  "&ovbar;",
  "&OverBar;",
  "&OverBrace;",
  "&OverBracket;",
  "&OverParenthesis;",
  "&par;",
  "&para",
  "&para;",
  "&parallel;",
  "&parsim;",
  "&parsl;",
  "&part;",
  "&PartialD;",
  "&Pcy;",
  "&pcy;",
  "&percnt;",
  "&period;",
  "&permil;",
  "&perp;",
  "&pertenk;",
  "&Pfr;",
  "&pfr;",
  "&Phi;",
  "&phi;",
  "&phiv;",
  "&phmmat;",
  "&phone;",
  "&Pi;",
  "&pi;",
  "&pitchfork;",
  "&piv;",
  "&planck;",
  "&planckh;",
  "&plankv;",
  "&plus;",
  "&plusacir;",
  "&plusb;",
  "&pluscir;",
  "&plusdo;",
  "&plusdu;",
  "&pluse;",
  "&PlusMinus;",
  "&plusmn",
  "&plusmn;",
  "&plussim;",
  "&plustwo;",
  "&pm;",
  "&Poincareplane;",
  "&pointint;",
  "&Popf;",
  "&popf;",
  "&pound",
  "&pound;",
  "&Pr;",
  "&pr;",
  "&prap;",
  "&prcue;",
  "&prE;",
  "&pre;",
  "&prec;",
  "&precapprox;",
  "&preccurlyeq;",
  "&Precedes;",
  "&PrecedesEqual;",
  "&PrecedesSlantEqual;",
  "&PrecedesTilde;",
  "&preceq;",
  "&precnapprox;",
  "&precneqq;",
  "&precnsim;",
  "&precsim;",
  "&Prime;",
  "&prime;",
  "&primes;",
  "&prnap;",
  "&prnE;",
  "&prnsim;",
  "&prod;",
  "&Product;",
  "&profalar;",
  "&profline;",
  "&profsurf;",
  "&prop;",
  "&Proportion;",
  "&Proportional;",
  "&propto;",
  "&prsim;",
  "&prurel;",
  "&Pscr;",
  "&pscr;",
  "&Psi;",
  "&psi;",
  "&puncsp;",
  "&Qfr;",
  "&qfr;",
  "&qint;",
  "&Qopf;",
  "&qopf;",
  "&qprime;",
  "&Qscr;",
  "&qscr;",
  "&quaternions;",
  "&quatint;",
  "&quest;",
  "&questeq;",
  "&QUOT",
  "&quot",
  "&QUOT;",
  "&quot;",
  "&rAarr;",
  "&race;",
  "&Racute;",
  "&racute;",
  "&radic;",
  "&raemptyv;",
  "&Rang;",
  "&rang;",
  "&rangd;",
  "&range;",
  "&rangle;",
  "&raquo",
  "&raquo;",
  "&Rarr;",
  "&rArr;",
  "&rarr;",
  "&rarrap;",
  "&rarrb;",
  "&rarrbfs;",
  "&rarrc;",
  "&rarrfs;",
  "&rarrhk;",
  "&rarrlp;",
  "&rarrpl;",
  "&rarrsim;",
  "&Rarrtl;",
  "&rarrtl;",
  "&rarrw;",
  "&rAtail;",
  "&ratail;",
  "&ratio;",
  "&rationals;",
  "&RBarr;",
  "&rBarr;",
  "&rbarr;",
  "&rbbrk;",
  "&rbrace;",
  "&rbrack;",
  "&rbrke;",
  "&rbrksld;",
  "&rbrkslu;",
  "&Rcaron;",
  "&rcaron;",
  "&Rcedil;",
  "&rcedil;",
  "&rceil;",
  "&rcub;",
  "&Rcy;",
  "&rcy;",
  "&rdca;",
  "&rdldhar;",
  "&rdquo;",
  "&rdquor;",
  "&rdsh;",
  "&Re;",
  "&real;",
  "&realine;",
  "&realpart;",
  "&reals;",
  "&rect;",
  "&REG",
  "&reg",
  "&REG;",
  "&reg;",
  "&ReverseElement;",
  "&ReverseEquilibrium;",
  "&ReverseUpEquilibrium;",
  "&rfisht;",
  "&rfloor;",
  "&Rfr;",
  "&rfr;",
  "&rHar;",
  "&rhard;",
  "&rharu;",
  "&rharul;",
  "&Rho;",
  "&rho;",
  "&rhov;",
  "&RightAngleBracket;",
  "&RightArrow;",
  "&Rightarrow;",
  "&rightarrow;",
  "&RightArrowBar;",
  "&RightArrowLeftArrow;",
  "&rightarrowtail;",
  "&RightCeiling;",
  "&RightDoubleBracket;",
  "&RightDownTeeVector;",
  "&RightDownVector;",
  "&RightDownVectorBar;",
  "&RightFloor;",
  "&rightharpoondown;",
  "&rightharpoonup;",
  "&rightleftarrows;",
  "&rightleftharpoons;",
  "&rightrightarrows;",
  "&rightsquigarrow;",
  "&RightTee;",
  "&RightTeeArrow;",
  "&RightTeeVector;",
  "&rightthreetimes;",
  "&RightTriangle;",
  "&RightTriangleBar;",
  "&RightTriangleEqual;",
  "&RightUpDownVector;",
  "&RightUpTeeVector;",
  "&RightUpVector;",
  "&RightUpVectorBar;",
  "&RightVector;",
  "&RightVectorBar;",
  "&ring;",
  "&risingdotseq;",
  "&rlarr;",
  "&rlhar;",
  "&rlm;",
  "&rmoust;",
  "&rmoustache;",
  "&rnmid;",
  "&roang;",
  "&roarr;",
  "&robrk;",
  "&ropar;",
  "&Ropf;",
  "&ropf;",
  "&roplus;",
  "&rotimes;",
  "&RoundImplies;",
  "&rpar;",
  "&rpargt;",
  "&rppolint;",
  "&rrarr;",
  "&Rrightarrow;",
  "&rsaquo;",
  "&Rscr;",
  "&rscr;",
  "&Rsh;",
  "&rsh;",
  "&rsqb;",
  "&rsquo;",
  "&rsquor;",
  "&rthree;",
  "&rtimes;",
  "&rtri;",
  "&rtrie;",
  "&rtrif;",
  "&rtriltri;",
  "&RuleDelayed;",
  "&ruluhar;",
  "&rx;",
  "&Sacute;",
  "&sacute;",
  "&sbquo;",
  "&Sc;",
  "&sc;",
  "&scap;",
  "&Scaron;",
  "&scaron;",
  "&sccue;",
  "&scE;",
  "&sce;",
  "&Scedil;",
  "&scedil;",
  "&Scirc;",
  "&scirc;",
  "&scnap;",
  "&scnE;",
  "&scnsim;",
  "&scpolint;",
  "&scsim;",
  "&Scy;",
  "&scy;",
  "&sdot;",
  "&sdotb;",
  "&sdote;",
  "&searhk;",
  "&seArr;",
  "&searr;",
  "&searrow;",
  "&sect",
  "&sect;",
  "&semi;",
  "&seswar;",
  "&setminus;",
  "&setmn;",
  "&sext;",
  "&Sfr;",
  "&sfr;",
  "&sfrown;",
  "&sharp;",
  "&SHCHcy;",
  "&shchcy;",
  "&SHcy;",
  "&shcy;",
  "&ShortDownArrow;",
  "&ShortLeftArrow;",
  "&shortmid;",
  "&shortparallel;",
  "&ShortRightArrow;",
  "&ShortUpArrow;",
  "&shy",
  "&shy;",
  "&Sigma;",
  "&sigma;",
  "&sigmaf;",
  "&sigmav;",
  "&sim;",
  "&simdot;",
  "&sime;",
  "&simeq;",
  "&simg;",
  "&simgE;",
  "&siml;",
  "&simlE;",
  "&simne;",
  "&simplus;",
  "&simrarr;",
  "&slarr;",
  "&SmallCircle;",
  "&smallsetminus;",
  "&smashp;",
  "&smeparsl;",
  "&smid;",
  "&smile;",
  "&smt;",
  "&smte;",
  "&smtes;",
  "&SOFTcy;",
  "&softcy;",
  "&sol;",
  "&solb;",
  "&solbar;",
  "&Sopf;",
  "&sopf;",
  "&spades;",
  "&spadesuit;",
  "&spar;",
  "&sqcap;",
  "&sqcaps;",
  "&sqcup;",
  "&sqcups;",
  "&Sqrt;",
  "&sqsub;",
  "&sqsube;",
  "&sqsubset;",
  "&sqsubseteq;",
  "&sqsup;",
  "&sqsupe;",
  "&sqsupset;",
  "&sqsupseteq;",
  "&squ;",
  "&Square;",
  "&square;",
  "&SquareIntersection;",
  "&SquareSubset;",
  "&SquareSubsetEqual;",
  "&SquareSuperset;",
  "&SquareSupersetEqual;",
  "&SquareUnion;",
  "&squarf;",
  "&squf;",
  "&srarr;",
  "&Sscr;",
  "&sscr;",
  "&ssetmn;",
  "&ssmile;",
  "&sstarf;",
  "&Star;",
  "&star;",
  "&starf;",
  "&straightepsilon;",
  "&straightphi;",
  "&strns;",
  "&Sub;",
  "&sub;",
  "&subdot;",
  "&subE;",
  "&sube;",
  "&subedot;",
  "&submult;",
  "&subnE;",
  "&subne;",
  "&subplus;",
  "&subrarr;",
  "&Subset;",
  "&subset;",
  "&subseteq;",
  "&subseteqq;",
  "&SubsetEqual;",
  "&subsetneq;",
  "&subsetneqq;",
  "&subsim;",
  "&subsub;",
  "&subsup;",
  "&succ;",
  "&succapprox;",
  "&succcurlyeq;",
  "&Succeeds;",
  "&SucceedsEqual;",
  "&SucceedsSlantEqual;",
  "&SucceedsTilde;",
  "&succeq;",
  "&succnapprox;",
  "&succneqq;",
  "&succnsim;",
  "&succsim;",
  "&SuchThat;",
  "&Sum;",
  "&sum;",
  "&sung;",
  "&sup1",
  "&sup1;",
  "&sup2",
  "&sup2;",
  "&sup3",
  "&sup3;",
  "&Sup;",
  "&sup;",
  "&supdot;",
  "&supdsub;",
  "&supE;",
  "&supe;",
  "&supedot;",
  "&Superset;",
  "&SupersetEqual;",
  "&suphsol;",
  "&suphsub;",
  "&suplarr;",
  "&supmult;",
  "&supnE;",
  "&supne;",
  "&supplus;",
  "&Supset;",
  "&supset;",
  "&supseteq;",
  "&supseteqq;",
  "&supsetneq;",
  "&supsetneqq;",
  "&supsim;",
  "&supsub;",
  "&supsup;",
  "&swarhk;",
  "&swArr;",
  "&swarr;",
  "&swarrow;",
  "&swnwar;",
  "&szlig",
  "&szlig;",
  "&Tab;",
  "&target;",
  "&Tau;",
  "&tau;",
  "&tbrk;",
  "&Tcaron;",
  "&tcaron;",
  "&Tcedil;",
  "&tcedil;",
  "&Tcy;",
  "&tcy;",
  "&tdot;",
  "&telrec;",
  "&Tfr;",
  "&tfr;",
  "&there4;",
  "&Therefore;",
  "&therefore;",
  "&Theta;",
  "&theta;",
  "&thetasym;",
  "&thetav;",
  "&thickapprox;",
  "&thicksim;",
  "&ThickSpace;",
  "&thinsp;",
  "&ThinSpace;",
  "&thkap;",
  "&thksim;",
  "&THORN",
  "&thorn",
  "&THORN;",
  "&thorn;",
  "&Tilde;",
  "&tilde;",
  "&TildeEqual;",
  "&TildeFullEqual;",
  "&TildeTilde;",
  "&times",
  "&times;",
  "&timesb;",
  "&timesbar;",
  "&timesd;",
  "&tint;",
  "&toea;",
  "&top;",
  "&topbot;",
  "&topcir;",
  "&Topf;",
  "&topf;",
  "&topfork;",
  "&tosa;",
  "&tprime;",
  "&TRADE;",
  "&trade;",
  "&triangle;",
  "&triangledown;",
  "&triangleleft;",
  "&trianglelefteq;",
  "&triangleq;",
  "&triangleright;",
  "&trianglerighteq;",
  "&tridot;",
  "&trie;",
  "&triminus;",
  "&TripleDot;",
  "&triplus;",
  "&trisb;",
  "&tritime;",
  "&trpezium;",
  "&Tscr;",
  "&tscr;",
  "&TScy;",
  "&tscy;",
  "&TSHcy;",
  "&tshcy;",
  "&Tstrok;",
  "&tstrok;",
  "&twixt;",
  "&twoheadleftarrow;",
  "&twoheadrightarrow;",
  "&Uacute",
  "&uacute",
  "&Uacute;",
  "&uacute;",
  "&Uarr;",
  "&uArr;",
  "&uarr;",
  "&Uarrocir;",
  "&Ubrcy;",
  "&ubrcy;",
  "&Ubreve;",
  "&ubreve;",
  "&Ucirc",
  "&ucirc",
  "&Ucirc;",
  "&ucirc;",
  "&Ucy;",
  "&ucy;",
  "&udarr;",
  "&Udblac;",
  "&udblac;",
  "&udhar;",
  "&ufisht;",
  "&Ufr;",
  "&ufr;",
  "&Ugrave",
  "&ugrave",
  "&Ugrave;",
  "&ugrave;",
  "&uHar;",
  "&uharl;",
  "&uharr;",
  "&uhblk;",
  "&ulcorn;",
  "&ulcorner;",
  "&ulcrop;",
  "&ultri;",
  "&Umacr;",
  "&umacr;",
  "&uml",
  "&uml;",
  "&UnderBar;",
  "&UnderBrace;",
  "&UnderBracket;",
  "&UnderParenthesis;",
  "&Union;",
  "&UnionPlus;",
  "&Uogon;",
  "&uogon;",
  "&Uopf;",
  "&uopf;",
  "&UpArrow;",
  "&Uparrow;",
  "&uparrow;",
  "&UpArrowBar;",
  "&UpArrowDownArrow;",
  "&UpDownArrow;",
  "&Updownarrow;",
  "&updownarrow;",
  "&UpEquilibrium;",
  "&upharpoonleft;",
  "&upharpoonright;",
  "&uplus;",
  "&UpperLeftArrow;",
  "&UpperRightArrow;",
  "&Upsi;",
  "&upsi;",
  "&upsih;",
  "&Upsilon;",
  "&upsilon;",
  "&UpTee;",
  "&UpTeeArrow;",
  "&upuparrows;",
  "&urcorn;",
  "&urcorner;",
  "&urcrop;",
  "&Uring;",
  "&uring;",
  "&urtri;",
  "&Uscr;",
  "&uscr;",
  "&utdot;",
  "&Utilde;",
  "&utilde;",
  "&utri;",
  "&utrif;",
  "&uuarr;",
  "&Uuml",
  "&uuml",
  "&Uuml;",
  "&uuml;",
  "&uwangle;",
  "&vangrt;",
  "&varepsilon;",
  "&varkappa;",
  "&varnothing;",
  "&varphi;",
  "&varpi;",
  "&varpropto;",
  "&vArr;",
  "&varr;",
  "&varrho;",
  "&varsigma;",
  "&varsubsetneq;",
  "&varsubsetneqq;",
  "&varsupsetneq;",
  "&varsupsetneqq;",
  "&vartheta;",
  "&vartriangleleft;",
  "&vartriangleright;",
  "&Vbar;",
  "&vBar;",
  "&vBarv;",
  "&Vcy;",
  "&vcy;",
  "&VDash;",
  "&Vdash;",
  "&vDash;",
  "&vdash;",
  "&Vdashl;",
  "&Vee;",
  "&vee;",
  "&veebar;",
  "&veeeq;",
  "&vellip;",
  "&Verbar;",
  "&verbar;",
  "&Vert;",
  "&vert;",
  "&VerticalBar;",
  "&VerticalLine;",
  "&VerticalSeparator;",
  "&VerticalTilde;",
  "&VeryThinSpace;",
  "&Vfr;",
  "&vfr;",
  "&vltri;",
  "&vnsub;",
  "&vnsup;",
  "&Vopf;",
  "&vopf;",
  "&vprop;",
  "&vrtri;",
  "&Vscr;",
  "&vscr;",
  "&vsubnE;",
  "&vsubne;",
  "&vsupnE;",
  "&vsupne;",
  "&Vvdash;",
  "&vzigzag;",
  "&Wcirc;",
  "&wcirc;",
  "&wedbar;",
  "&Wedge;",
  "&wedge;",
  "&wedgeq;",
  "&weierp;",
  "&Wfr;",
  "&wfr;",
  "&Wopf;",
  "&wopf;",
  "&wp;",
  "&wr;",
  "&wreath;",
  "&Wscr;",
  "&wscr;",
  "&xcap;",
  "&xcirc;",
  "&xcup;",
  "&xdtri;",
  "&Xfr;",
  "&xfr;",
  "&xhArr;",
  "&xharr;",
  "&Xi;",
  "&xi;",
  "&xlArr;",
  "&xlarr;",
  "&xmap;",
  "&xnis;",
  "&xodot;",
  "&Xopf;",
  "&xopf;",
  "&xoplus;",
  "&xotime;",
  "&xrArr;",
  "&xrarr;",
  "&Xscr;",
  "&xscr;",
  "&xsqcup;",
  "&xuplus;",
  "&xutri;",
  "&xvee;",
  "&xwedge;",
  "&Yacute",
  "&yacute",
  "&Yacute;",
  "&yacute;",
  "&YAcy;",
  "&yacy;",
  "&Ycirc;",
  "&ycirc;",
  "&Ycy;",
  "&ycy;",
  "&yen",
  "&yen;",
  "&Yfr;",
  "&yfr;",
  "&YIcy;",
  "&yicy;",
  "&Yopf;",
  "&yopf;",
  "&Yscr;",
  "&yscr;",
  "&YUcy;",
  "&yucy;",
  "&yuml",
  "&Yuml;",
  "&yuml;",
  "&Zacute;",
  "&zacute;",
  "&Zcaron;",
  "&zcaron;",
  "&Zcy;",
  "&zcy;",
  "&Zdot;",
  "&zdot;",
  "&zeetrf;",
  "&ZeroWidthSpace;",
  "&Zeta;",
  "&zeta;",
  "&Zfr;",
  "&zfr;",
  "&ZHcy;",
  "&zhcy;",
  "&zigrarr;",
  "&Zopf;",
  "&zopf;",
  "&Zscr;",
  "&zscr;",
  "&zwj;",
  "&zwnj;"
];

// node_modules/kleur/colors.mjs
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
var $ = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY)
};
function init(x, y) {
  let rgx = new RegExp(`\\x1b\\[${y}m`, "g");
  let open = `\x1B[${x}m`, close = `\x1B[${y}m`;
  return function(txt) {
    if (!$.enabled || txt == null) return txt;
    return open + (!!~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
  };
}
var reset = init(0, 0);
var bold = init(1, 22);
var dim = init(2, 22);
var italic = init(3, 23);
var underline = init(4, 24);
var inverse = init(7, 27);
var hidden = init(8, 28);
var strikethrough = init(9, 29);
var black = init(30, 39);
var red = init(31, 39);
var green = init(32, 39);
var yellow = init(33, 39);
var blue = init(34, 39);
var magenta = init(35, 39);
var cyan = init(36, 39);
var white = init(37, 39);
var gray = init(90, 39);
var grey = init(90, 39);
var bgBlack = init(40, 49);
var bgRed = init(41, 49);
var bgGreen = init(42, 49);
var bgYellow = init(43, 49);
var bgBlue = init(44, 49);
var bgMagenta = init(45, 49);
var bgCyan = init(46, 49);
var bgWhite = init(47, 49);

// node_modules/@sidvind/better-ajv-errors/lib/esm/index.mjs
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_leven = __commonJS2({
  "node_modules/leven/index.js"(exports2, module2) {
    "use strict";
    var array = [];
    var charCodeCache = [];
    var leven2 = (left, right) => {
      if (left === right) {
        return 0;
      }
      const swap = left;
      if (left.length > right.length) {
        left = right;
        right = swap;
      }
      let leftLength = left.length;
      let rightLength = right.length;
      while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {
        leftLength--;
        rightLength--;
      }
      let start = 0;
      while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
        start++;
      }
      leftLength -= start;
      rightLength -= start;
      if (leftLength === 0) {
        return rightLength;
      }
      let bCharCode;
      let result;
      let temp;
      let temp2;
      let i = 0;
      let j = 0;
      while (i < leftLength) {
        charCodeCache[i] = left.charCodeAt(start + i);
        array[i] = ++i;
      }
      while (j < rightLength) {
        bCharCode = right.charCodeAt(start + j);
        temp = j++;
        result = j;
        for (i = 0; i < leftLength; i++) {
          temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1;
          temp = array[i];
          result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
        }
      }
      return result;
    };
    module2.exports = leven2;
    module2.exports.default = leven2;
  }
});
var require_jsonpointer = __commonJS2({
  "node_modules/jsonpointer/jsonpointer.js"(exports2) {
    var hasExcape = /~/;
    var escapeMatcher = /~[01]/g;
    function escapeReplacer(m) {
      switch (m) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + m);
    }
    function untilde(str) {
      if (!hasExcape.test(str)) return str;
      return str.replace(escapeMatcher, escapeReplacer);
    }
    function setter(obj, pointer2, value) {
      var part;
      var hasNextPart;
      for (var p = 1, len = pointer2.length; p < len; ) {
        if (pointer2[p] === "constructor" || pointer2[p] === "prototype" || pointer2[p] === "__proto__") return obj;
        part = untilde(pointer2[p++]);
        hasNextPart = len > p;
        if (typeof obj[part] === "undefined") {
          if (Array.isArray(obj) && part === "-") {
            part = obj.length;
          }
          if (hasNextPart) {
            if (pointer2[p] !== "" && pointer2[p] < Infinity || pointer2[p] === "-") obj[part] = [];
            else obj[part] = {};
          }
        }
        if (!hasNextPart) break;
        obj = obj[part];
      }
      var oldValue = obj[part];
      if (value === void 0) delete obj[part];
      else obj[part] = value;
      return oldValue;
    }
    function compilePointer(pointer2) {
      if (typeof pointer2 === "string") {
        pointer2 = pointer2.split("/");
        if (pointer2[0] === "") return pointer2;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(pointer2)) {
        for (const part of pointer2) {
          if (typeof part !== "string" && typeof part !== "number") {
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
          }
        }
        return pointer2;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function get(obj, pointer2) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer2 = compilePointer(pointer2);
      var len = pointer2.length;
      if (len === 1) return obj;
      for (var p = 1; p < len; ) {
        obj = obj[untilde(pointer2[p++])];
        if (len === p) return obj;
        if (typeof obj !== "object" || obj === null) return void 0;
      }
    }
    function set(obj, pointer2, value) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer2 = compilePointer(pointer2);
      if (pointer2.length === 0) throw new Error("Invalid JSON pointer for set.");
      return setter(obj, pointer2, value);
    }
    function compile(pointer2) {
      var compiled = compilePointer(pointer2);
      return {
        get: function(object) {
          return get(object, compiled);
        },
        set: function(object, value) {
          return set(object, compiled, value);
        }
      };
    }
    exports2.get = get;
    exports2.set = set;
    exports2.compile = compile;
  }
});
var CHAR_0 = 48;
var CHAR_1 = 49;
var CHAR_9 = 57;
var CHAR_BACKSLASH = 92;
var CHAR_DOLLAR = 36;
var CHAR_DOT = 46;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_LOWER_A = 97;
var CHAR_LOWER_E = 101;
var CHAR_LOWER_F = 102;
var CHAR_LOWER_N = 110;
var CHAR_LOWER_T = 116;
var CHAR_LOWER_U = 117;
var CHAR_LOWER_X = 120;
var CHAR_LOWER_Z = 122;
var CHAR_MINUS = 45;
var CHAR_NEWLINE = 10;
var CHAR_PLUS = 43;
var CHAR_RETURN = 13;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_SLASH = 47;
var CHAR_SPACE = 32;
var CHAR_TAB = 9;
var CHAR_UNDERSCORE = 95;
var CHAR_UPPER_A = 65;
var CHAR_UPPER_E = 69;
var CHAR_UPPER_F = 70;
var CHAR_UPPER_N = 78;
var CHAR_UPPER_X = 88;
var CHAR_UPPER_Z = 90;
var CHAR_LOWER_B = 98;
var CHAR_LOWER_R = 114;
var CHAR_LOWER_V = 118;
var CHAR_LINE_SEPARATOR = 8232;
var CHAR_PARAGRAPH_SEPARATOR = 8233;
var CHAR_UPPER_I = 73;
var CHAR_STAR = 42;
var CHAR_VTAB = 11;
var CHAR_FORM_FEED = 12;
var CHAR_NBSP = 160;
var CHAR_BOM = 65279;
var CHAR_NON_BREAKING_SPACE = 160;
var CHAR_EN_QUAD = 8192;
var CHAR_EM_QUAD = 8193;
var CHAR_EN_SPACE = 8194;
var CHAR_EM_SPACE = 8195;
var CHAR_THREE_PER_EM_SPACE = 8196;
var CHAR_FOUR_PER_EM_SPACE = 8197;
var CHAR_SIX_PER_EM_SPACE = 8198;
var CHAR_FIGURE_SPACE = 8199;
var CHAR_PUNCTUATION_SPACE = 8200;
var CHAR_THIN_SPACE = 8201;
var CHAR_HAIR_SPACE = 8202;
var CHAR_NARROW_NO_BREAK_SPACE = 8239;
var CHAR_MEDIUM_MATHEMATICAL_SPACE = 8287;
var CHAR_IDEOGRAPHIC_SPACE = 12288;
var LBRACKET = "[";
var RBRACKET = "]";
var LBRACE = "{";
var RBRACE = "}";
var COLON = ":";
var COMMA = ",";
var TRUE = "true";
var FALSE = "false";
var NULL = "null";
var NAN$1 = "NaN";
var INFINITY$1 = "Infinity";
var QUOTE = '"';
var escapeToChar = /* @__PURE__ */ new Map([
  [CHAR_DOUBLE_QUOTE, QUOTE],
  [CHAR_BACKSLASH, "\\"],
  [CHAR_SLASH, "/"],
  [CHAR_LOWER_B, "\b"],
  [CHAR_LOWER_N, "\n"],
  [CHAR_LOWER_F, "\f"],
  [CHAR_LOWER_R, "\r"],
  [CHAR_LOWER_T, "	"]
]);
var json5EscapeToChar = new Map([
  ...escapeToChar,
  [CHAR_LOWER_V, "\v"],
  [CHAR_0, "\0"]
]);
var charToEscape = /* @__PURE__ */ new Map([
  [QUOTE, QUOTE],
  ["\\", "\\"],
  ["/", "/"],
  ["\b", "b"],
  ["\n", "n"],
  ["\f", "f"],
  ["\r", "r"],
  ["	", "t"]
]);
var json5CharToEscape = new Map([
  ...charToEscape,
  ["\v", "v"],
  ["\0", "0"],
  ["\u2028", "u2028"],
  ["\u2029", "u2029"]
]);
var knownTokenTypes = /* @__PURE__ */ new Map([
  [LBRACKET, "LBracket"],
  [RBRACKET, "RBracket"],
  [LBRACE, "LBrace"],
  [RBRACE, "RBrace"],
  [COLON, "Colon"],
  [COMMA, "Comma"],
  [TRUE, "Boolean"],
  [FALSE, "Boolean"],
  [NULL, "Null"]
]);
var knownJSON5TokenTypes = new Map([
  ...knownTokenTypes,
  [NAN$1, "Number"],
  [INFINITY$1, "Number"]
]);
var json5LineTerminators = /* @__PURE__ */ new Set([
  CHAR_NEWLINE,
  CHAR_RETURN,
  CHAR_LINE_SEPARATOR,
  CHAR_PARAGRAPH_SEPARATOR
]);
var ErrorWithLocation = class extends Error {
  /**
   * Creates a new instance.
   * @param {string} message The error message to report. 
   * @param {Location} loc The location information for the error.
   */
  constructor(message, { line, column, offset }) {
    super(`${message} (${line}:${column})`);
    this.line = line;
    this.column = column;
    this.offset = offset;
  }
};
var UnexpectedChar = class extends ErrorWithLocation {
  /**
   * Creates a new instance.
   * @param {number} unexpected The character that was found.
   * @param {Location} loc The location information for the found character.
   */
  constructor(unexpected, loc) {
    super(`Unexpected character '${String.fromCharCode(unexpected)}' found.`, loc);
  }
};
var UnexpectedIdentifier = class extends ErrorWithLocation {
  /**
   * Creates a new instance.
   * @param {string} unexpected The character that was found.
   * @param {Location} loc The location information for the found character.
   */
  constructor(unexpected, loc) {
    super(`Unexpected identifier '${unexpected}' found.`, loc);
  }
};
var UnexpectedToken = class extends ErrorWithLocation {
  /**
   * Creates a new instance.
   * @param {Token} token The token that was found. 
   */
  constructor(token) {
    super(`Unexpected token ${token.type} found.`, token.loc.start);
  }
};
var UnexpectedEOF = class extends ErrorWithLocation {
  /**
   * Creates a new instance.
   * @param {Location} loc The location information for the found character.
   */
  constructor(loc) {
    super("Unexpected end of input found.", loc);
  }
};
var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
var CHAR_CR = 13;
var CHAR_LF = 10;
var CharCodeReader = class {
  /**
   * The text to read from.
   * @type {string}
   */
  #text = "";
  /**
   * The current line number.
   * @type {number}
   */
  #line = 1;
  /**
   * The current column number.
   * @type {number}
   */
  #column = 0;
  /**
   * The current offset in the text.
   * @type {number}
   */
  #offset = -1;
  /**
   * Whether the last character read was a new line.
   * @type {boolean}
   */
  #newLine = false;
  /**
   * The last character code read.
   * @type {number}
   */
  #last = -1;
  /**
   * Whether the reader has ended.
   * @type {boolean}
   */
  #ended = false;
  /**
   * Creates a new instance.
   * @param {string} text The text to read from
   */
  constructor(text) {
    this.#text = text;
  }
  /**
   * Ends the reader.
   * @returns {void}
   */
  #end() {
    if (this.#ended) {
      return;
    }
    this.#column++;
    this.#offset++;
    this.#last = -1;
    this.#ended = true;
  }
  /**
   * Returns the current position of the reader.
   * @returns {Location} An object with line, column, and offset properties.
   */
  locate() {
    return {
      line: this.#line,
      column: this.#column,
      offset: this.#offset
    };
  }
  /**
   * Reads the next character code in the text.
   * @returns {number} The next character code, or -1 if there are no more characters.
   */
  next() {
    if (this.#offset >= this.#text.length - 1) {
      this.#end();
      return -1;
    }
    this.#offset++;
    const charCode = this.#text.charCodeAt(this.#offset);
    if (this.#newLine) {
      this.#line++;
      this.#column = 1;
      this.#newLine = false;
    } else {
      this.#column++;
    }
    if (charCode === CHAR_CR) {
      this.#newLine = true;
      if (this.peek() === CHAR_LF) {
        this.#offset++;
      }
    } else if (charCode === CHAR_LF) {
      this.#newLine = true;
    }
    this.#last = charCode;
    return charCode;
  }
  /**
   * Peeks at the next character code in the text.
   * @returns {number} The next character code, or -1 if there are no more characters.
   */
  peek() {
    if (this.#offset === this.#text.length - 1) {
      return -1;
    }
    return this.#text.charCodeAt(this.#offset + 1);
  }
  /**
   * Determines if the next character code in the text matches a specific character code.
   * @param {(number) => boolean} fn A function to call on the next character.
   * @returns {boolean} True if the next character code matches, false if not.
   */
  match(fn) {
    if (fn(this.peek())) {
      this.next();
      return true;
    }
    return false;
  }
  /**
   * Returns the last character code read.
   * @returns {number} The last character code read.
   */
  current() {
    return this.#last;
  }
};
var INFINITY = "Infinity";
var NAN = "NaN";
var keywordStarts = /* @__PURE__ */ new Set([CHAR_LOWER_T, CHAR_LOWER_F, CHAR_LOWER_N]);
var whitespace = /* @__PURE__ */ new Set([CHAR_SPACE, CHAR_TAB, CHAR_NEWLINE, CHAR_RETURN]);
var json5Whitespace = /* @__PURE__ */ new Set([
  ...whitespace,
  CHAR_VTAB,
  CHAR_FORM_FEED,
  CHAR_NBSP,
  CHAR_LINE_SEPARATOR,
  CHAR_PARAGRAPH_SEPARATOR,
  CHAR_BOM,
  CHAR_NON_BREAKING_SPACE,
  CHAR_EN_QUAD,
  CHAR_EM_QUAD,
  CHAR_EN_SPACE,
  CHAR_EM_SPACE,
  CHAR_THREE_PER_EM_SPACE,
  CHAR_FOUR_PER_EM_SPACE,
  CHAR_SIX_PER_EM_SPACE,
  CHAR_FIGURE_SPACE,
  CHAR_PUNCTUATION_SPACE,
  CHAR_THIN_SPACE,
  CHAR_HAIR_SPACE,
  CHAR_NARROW_NO_BREAK_SPACE,
  CHAR_MEDIUM_MATHEMATICAL_SPACE,
  CHAR_IDEOGRAPHIC_SPACE
]);
var DEFAULT_OPTIONS$1 = {
  mode: "json",
  ranges: false
};
var jsonKeywords = /* @__PURE__ */ new Set(["true", "false", "null"]);
var tt = {
  EOF: 0,
  Number: 1,
  String: 2,
  Boolean: 3,
  Null: 4,
  NaN: 5,
  Infinity: 6,
  Identifier: 7,
  Colon: 20,
  LBrace: 21,
  RBrace: 22,
  LBracket: 23,
  RBracket: 24,
  Comma: 25,
  LineComment: 40,
  BlockComment: 41
};
function isDigit(c) {
  return c >= CHAR_0 && c <= CHAR_9;
}
function isHexDigit(c) {
  return isDigit(c) || c >= CHAR_UPPER_A && c <= CHAR_UPPER_F || c >= CHAR_LOWER_A && c <= CHAR_LOWER_F;
}
function isPositiveDigit(c) {
  return c >= CHAR_1 && c <= CHAR_9;
}
function isKeywordStart(c) {
  return keywordStarts.has(c);
}
function isNumberStart(c) {
  return isDigit(c) || c === CHAR_DOT || c === CHAR_MINUS;
}
function isJSON5NumberStart(c) {
  return isNumberStart(c) || c === CHAR_PLUS;
}
function isStringStart(c, json5) {
  return c === CHAR_DOUBLE_QUOTE || json5 && c === CHAR_SINGLE_QUOTE;
}
function isJSON5IdentifierStart(c) {
  if (c === CHAR_DOLLAR || c === CHAR_UNDERSCORE || c === CHAR_BACKSLASH) {
    return true;
  }
  if (c >= CHAR_LOWER_A && c <= CHAR_LOWER_Z || c >= CHAR_UPPER_A && c <= CHAR_UPPER_Z) {
    return true;
  }
  if (c === 8204 || c === 8205) {
    return true;
  }
  const ct = String.fromCharCode(c);
  return ID_Start.test(ct);
}
function isJSON5IdentifierPart(c) {
  if (isJSON5IdentifierStart(c) || isDigit(c)) {
    return true;
  }
  const ct = String.fromCharCode(c);
  return ID_Continue.test(ct);
}
var Tokenizer = class {
  /**
   * Options for the tokenizer.
   * @type {TokenizeOptions}
   */
  #options;
  /**
   * The source text to tokenize.
   * @type {string}
   */
  #text;
  /**
   * The reader for the source text.
   * @type {CharCodeReader}
   */
  #reader;
  /**
   * Indicates if the tokenizer is in JSON5 mode.
   * @type {boolean}
   */
  #json5;
  /**
   * Indicates if comments are allowed.
   * @type {boolean}
   */
  #allowComments;
  /**
   * Indicates if ranges should be included in the tokens.
   * @type {boolean}
   */
  #ranges;
  /**
   * The last token type read.
   * @type {Token}
   */
  #token;
  /**
   * Determines if a character is an escaped character.
   * @type {(c:number) => boolean}
   */
  #isEscapedCharacter;
  /**
   * Determines if a character is a JSON5 line terminator.
   * @type {(c:number) => boolean}
   */
  #isJSON5LineTerminator;
  /**
   * Determines if a character is a JSON5 hex escape.
   * @type {(c:number) => boolean}
   */
  #isJSON5HexEscape;
  /**
   * Determines if a character is whitespace.
   * @type {(c:number) => boolean}
   */
  #isWhitespace;
  /**
   * Creates a new instance of the tokenizer.
   * @param {string} text The source text
   * @param {TokenizeOptions} [options] Options for the tokenizer.
   */
  constructor(text, options) {
    this.#text = text;
    this.#options = {
      ...DEFAULT_OPTIONS$1,
      ...options
    };
    this.#reader = new CharCodeReader(text);
    this.#json5 = this.#options.mode === "json5";
    this.#allowComments = this.#options.mode !== "json";
    this.#ranges = this.#options.ranges;
    this.#isEscapedCharacter = this.#json5 ? json5EscapeToChar.has.bind(json5EscapeToChar) : escapeToChar.has.bind(escapeToChar);
    this.#isJSON5LineTerminator = this.#json5 ? json5LineTerminators.has.bind(json5LineTerminators) : () => false;
    this.#isJSON5HexEscape = this.#json5 ? (c) => c === CHAR_LOWER_X : () => false;
    this.#isWhitespace = this.#json5 ? json5Whitespace.has.bind(json5Whitespace) : whitespace.has.bind(whitespace);
  }
  // #region Errors
  /**
   * Convenience function for throwing unexpected character errors.
   * @param {number} c The unexpected character.
   * @param {Location} [loc] The location of the unexpected character.
   * @returns {never}
   * @throws {UnexpectedChar} always.
   */
  #unexpected(c, loc = this.#reader.locate()) {
    throw new UnexpectedChar(c, loc);
  }
  /**
   * Convenience function for throwing unexpected identifier errors.
   * @param {string} identifier The unexpected identifier.
   * @param {Location} [loc] The location of the unexpected identifier.
   * @returns {never}
   * @throws {UnexpectedIdentifier} always.
   */
  #unexpectedIdentifier(identifier, loc = this.#reader.locate()) {
    throw new UnexpectedIdentifier(identifier, loc);
  }
  /**
  * Convenience function for throwing unexpected EOF errors.
  * @returns {never}
  * @throws {UnexpectedEOF} always.
  */
  #unexpectedEOF() {
    throw new UnexpectedEOF(this.#reader.locate());
  }
  // #endregion
  // #region Helpers
  /**
   * Creates a new token.
   * @param {TokenType} tokenType The type of token to create.
   * @param {number} length The length of the token.
   * @param {Location} startLoc The start location for the token.
   * @param {Location} [endLoc] The end location for the token.
   * @returns {Token} The token.
   */
  #createToken(tokenType, length, startLoc, endLoc) {
    const endOffset = startLoc.offset + length;
    let range2 = this.#options.ranges ? {
      range: (
        /** @type {Range} */
        [startLoc.offset, endOffset]
      )
    } : void 0;
    return {
      type: tokenType,
      loc: {
        start: startLoc,
        end: endLoc || {
          line: startLoc.line,
          column: startLoc.column + length,
          offset: endOffset
        }
      },
      ...range2
    };
  }
  /**
   * Reads in a specific number of hex digits.
   * @param {number} count The number of hex digits to read.
   * @returns {string} The hex digits read.
   */
  #readHexDigits(count) {
    let value = "";
    let c;
    for (let i = 0; i < count; i++) {
      c = this.#reader.peek();
      if (isHexDigit(c)) {
        this.#reader.next();
        value += String.fromCharCode(c);
        continue;
      }
      this.#unexpected(c);
    }
    return value;
  }
  /**
   * Reads in a JSON5 identifier. Also used for JSON but we validate
   * the identifier later.
   * @param {number} c The first character of the identifier.
   * @returns {string} The identifier read.
   * @throws {UnexpectedChar} when the identifier cannot be read.
   */
  #readIdentifier(c) {
    let value = "";
    do {
      value += String.fromCharCode(c);
      if (c === CHAR_BACKSLASH) {
        c = this.#reader.next();
        if (c !== CHAR_LOWER_U) {
          this.#unexpected(c);
        }
        value += String.fromCharCode(c);
        const hexDigits = this.#readHexDigits(4);
        const charCode = parseInt(hexDigits, 16);
        if (value.length === 2 && !isJSON5IdentifierStart(charCode)) {
          const loc = this.#reader.locate();
          this.#unexpected(CHAR_BACKSLASH, { line: loc.line, column: loc.column - 5, offset: loc.offset - 5 });
        } else if (!isJSON5IdentifierPart(charCode)) {
          const loc = this.#reader.locate();
          this.#unexpected(charCode, { line: loc.line, column: loc.column - 5, offset: loc.offset - 5 });
        }
        value += hexDigits;
      }
      c = this.#reader.peek();
      if (!isJSON5IdentifierPart(c)) {
        break;
      }
      this.#reader.next();
    } while (true);
    return value;
  }
  /**
   * Reads in a string. Works for both JSON and JSON5.
   * @param {number} c The first character of the string (either " or ').
   * @returns {number} The length of the string.
   * @throws {UnexpectedChar} when the string cannot be read.
   * @throws {UnexpectedEOF} when EOF is reached before the string is finalized.
   */
  #readString(c) {
    const delimiter = c;
    let length = 1;
    c = this.#reader.peek();
    while (c !== -1 && c !== delimiter) {
      this.#reader.next();
      length++;
      if (c === CHAR_BACKSLASH) {
        c = this.#reader.peek();
        if (this.#isEscapedCharacter(c) || this.#isJSON5LineTerminator(c)) {
          this.#reader.next();
          length++;
        } else if (c === CHAR_LOWER_U) {
          this.#reader.next();
          length++;
          const result = this.#readHexDigits(4);
          length += result.length;
        } else if (this.#isJSON5HexEscape(c)) {
          this.#reader.next();
          length++;
          const result = this.#readHexDigits(2);
          length += result.length;
        } else if (this.#json5) {
          this.#reader.next();
          length++;
        } else {
          this.#unexpected(c);
        }
      }
      c = this.#reader.peek();
    }
    if (c === -1) {
      this.#reader.next();
      this.#unexpectedEOF();
    }
    this.#reader.next();
    length++;
    return length;
  }
  /**
   * Reads a number. Works for both JSON and JSON5.
   * @param {number} c The first character of the number.
   * @returns {number} The length of the number.
   * @throws {UnexpectedChar} when the number cannot be read.
   * @throws {UnexpectedEOF} when EOF is reached before the number is finalized.
   */
  #readNumber(c) {
    let length = 1;
    if (c === CHAR_MINUS || this.#json5 && c === CHAR_PLUS) {
      c = this.#reader.peek();
      if (this.#json5) {
        if (c === CHAR_UPPER_I || c === CHAR_UPPER_N) {
          this.#reader.next();
          const identifier = this.#readIdentifier(c);
          if (identifier !== INFINITY && identifier !== NAN) {
            this.#unexpected(c);
          }
          return length + identifier.length;
        }
      }
      if (!isDigit(c)) {
        this.#unexpected(c);
      }
      this.#reader.next();
      length++;
    }
    if (c === CHAR_0) {
      c = this.#reader.peek();
      if (this.#json5 && (c === CHAR_LOWER_X || c === CHAR_UPPER_X)) {
        this.#reader.next();
        length++;
        c = this.#reader.peek();
        if (!isHexDigit(c)) {
          this.#reader.next();
          this.#unexpected(c);
        }
        do {
          this.#reader.next();
          length++;
          c = this.#reader.peek();
        } while (isHexDigit(c));
      } else if (isDigit(c)) {
        this.#unexpected(c);
      }
    } else {
      if (!this.#json5 || c !== CHAR_DOT) {
        if (!isPositiveDigit(c)) {
          this.#unexpected(c);
        }
        c = this.#reader.peek();
        while (isDigit(c)) {
          this.#reader.next();
          length++;
          c = this.#reader.peek();
        }
      }
    }
    if (c === CHAR_DOT) {
      let digitCount = -1;
      this.#reader.next();
      length++;
      digitCount++;
      c = this.#reader.peek();
      while (isDigit(c)) {
        this.#reader.next();
        length++;
        digitCount++;
        c = this.#reader.peek();
      }
      if (!this.#json5 && digitCount === 0) {
        this.#reader.next();
        if (c) {
          this.#unexpected(c);
        } else {
          this.#unexpectedEOF();
        }
      }
    }
    if (c === CHAR_LOWER_E || c === CHAR_UPPER_E) {
      this.#reader.next();
      length++;
      c = this.#reader.peek();
      if (c === CHAR_PLUS || c === CHAR_MINUS) {
        this.#reader.next();
        length++;
        c = this.#reader.peek();
      }
      if (c === -1) {
        this.#reader.next();
        this.#unexpectedEOF();
      }
      if (!isDigit(c)) {
        this.#reader.next();
        this.#unexpected(c);
      }
      while (isDigit(c)) {
        this.#reader.next();
        length++;
        c = this.#reader.peek();
      }
    }
    return length;
  }
  /**
   * Reads a comment. Works for both JSON and JSON5.
   * @param {number} c The first character of the comment.
   * @returns {{length: number, multiline: boolean}} The length of the comment, and whether the comment is multi-line.
   * @throws {UnexpectedChar} when the comment cannot be read.
   * @throws {UnexpectedEOF} when EOF is reached before the comment is finalized.
   */
  #readComment(c) {
    let length = 1;
    c = this.#reader.peek();
    if (c === CHAR_SLASH) {
      do {
        this.#reader.next();
        length += 1;
        c = this.#reader.peek();
      } while (c > -1 && c !== CHAR_RETURN && c !== CHAR_NEWLINE);
      return { length, multiline: false };
    }
    if (c === CHAR_STAR) {
      this.#reader.next();
      length += 1;
      while (c > -1) {
        c = this.#reader.peek();
        if (c === CHAR_STAR) {
          this.#reader.next();
          length += 1;
          c = this.#reader.peek();
          if (c === CHAR_SLASH) {
            this.#reader.next();
            length += 1;
            return { length, multiline: true };
          }
        } else {
          this.#reader.next();
          length += 1;
        }
      }
      this.#reader.next();
      this.#unexpectedEOF();
    }
    this.#reader.next();
    this.#unexpected(c);
  }
  // #endregion
  /**
   * Returns the next token in the source text.
   * @returns {number} The code for the next token.
   */
  next() {
    let c = this.#reader.next();
    while (this.#isWhitespace(c)) {
      c = this.#reader.next();
    }
    if (c === -1) {
      return tt.EOF;
    }
    const start = this.#reader.locate();
    const ct = String.fromCharCode(c);
    if (this.#json5) {
      if (knownJSON5TokenTypes.has(ct)) {
        this.#token = this.#createToken(knownJSON5TokenTypes.get(ct), 1, start);
      } else if (isJSON5IdentifierStart(c)) {
        const value = this.#readIdentifier(c);
        if (knownJSON5TokenTypes.has(value)) {
          this.#token = this.#createToken(knownJSON5TokenTypes.get(value), value.length, start);
        } else {
          this.#token = this.#createToken("Identifier", value.length, start);
        }
      } else if (isJSON5NumberStart(c)) {
        const result = this.#readNumber(c);
        this.#token = this.#createToken("Number", result, start);
      } else if (isStringStart(c, this.#json5)) {
        const result = this.#readString(c);
        const lastCharLoc = this.#reader.locate();
        this.#token = this.#createToken("String", result, start, {
          line: lastCharLoc.line,
          column: lastCharLoc.column + 1,
          offset: lastCharLoc.offset + 1
        });
      } else if (c === CHAR_SLASH && this.#allowComments) {
        const result = this.#readComment(c);
        const lastCharLoc = this.#reader.locate();
        this.#token = this.#createToken(!result.multiline ? "LineComment" : "BlockComment", result.length, start, {
          line: lastCharLoc.line,
          column: lastCharLoc.column + 1,
          offset: lastCharLoc.offset + 1
        });
      } else {
        this.#unexpected(c);
      }
    } else {
      if (knownTokenTypes.has(ct)) {
        this.#token = this.#createToken(knownTokenTypes.get(ct), 1, start);
      } else if (isKeywordStart(c)) {
        const value = this.#readIdentifier(c);
        if (!jsonKeywords.has(value)) {
          this.#unexpectedIdentifier(value, start);
        }
        this.#token = this.#createToken(knownTokenTypes.get(value), value.length, start);
      } else if (isNumberStart(c)) {
        const result = this.#readNumber(c);
        this.#token = this.#createToken("Number", result, start);
      } else if (isStringStart(c, this.#json5)) {
        const result = this.#readString(c);
        this.#token = this.#createToken("String", result, start);
      } else if (c === CHAR_SLASH && this.#allowComments) {
        const result = this.#readComment(c);
        const lastCharLoc = this.#reader.locate();
        this.#token = this.#createToken(!result.multiline ? "LineComment" : "BlockComment", result.length, start, {
          line: lastCharLoc.line,
          column: lastCharLoc.column + 1,
          offset: lastCharLoc.offset + 1
        });
      } else {
        this.#unexpected(c);
      }
    }
    return tt[this.#token.type];
  }
  /**
   * Returns the current token in the source text.
   * @returns {Token} The current token.
   */
  get token() {
    return this.#token;
  }
};
var types = {
  /**
   * Creates a document node.
   * @param {ValueNode} body The body of the document.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {DocumentNode} The document node.
   */
  document(body, parts = {}) {
    return {
      type: "Document",
      body,
      loc: parts.loc,
      ...parts
    };
  },
  /**
   * Creates a string node.
   * @param {string} value The value for the string.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {StringNode} The string node.
   */
  string(value, parts = {}) {
    return {
      type: "String",
      value,
      loc: parts.loc,
      ...parts
    };
  },
  /**
   * Creates a number node.
   * @param {number} value The value for the number.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {NumberNode} The number node.
   */
  number(value, parts = {}) {
    return {
      type: "Number",
      value,
      loc: parts.loc,
      ...parts
    };
  },
  /**
   * Creates a boolean node.
   * @param {boolean} value The value for the boolean.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {BooleanNode} The boolean node.
   */
  boolean(value, parts = {}) {
    return {
      type: "Boolean",
      value,
      loc: parts.loc,
      ...parts
    };
  },
  /**
   * Creates a null node.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {NullNode} The null node.
   */
  null(parts = {}) {
    return {
      type: "Null",
      loc: parts.loc,
      ...parts
    };
  },
  /**
   * Creates an array node.
   * @param {Array<ElementNode>} elements The elements to add.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {ArrayNode} The array node.
   */
  array(elements, parts = {}) {
    return {
      type: "Array",
      elements,
      loc: parts.loc,
      ...parts
    };
  },
  /**
   * Creates an element node.
   * @param {ValueNode} value The value for the element.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {ElementNode} The element node.
   */
  element(value, parts = {}) {
    return {
      type: "Element",
      value,
      loc: parts.loc,
      ...parts
    };
  },
  /**
   * Creates an object node.
   * @param {Array<MemberNode>} members The members to add.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {ObjectNode} The object node.
   */
  object(members, parts = {}) {
    return {
      type: "Object",
      members,
      loc: parts.loc,
      ...parts
    };
  },
  /**
   * Creates a member node.
   * @param {StringNode|IdentifierNode} name The name for the member.
   * @param {ValueNode} value The value for the member.
   * @param {NodeParts} parts Additional properties for the node. 
   * @returns {MemberNode} The member node.
   */
  member(name, value, parts = {}) {
    return {
      type: "Member",
      name,
      value,
      loc: parts.loc,
      ...parts
    };
  },
  /**
   * Creates an identifier node.
   * @param {string} name The name for the identifier.
   * @param {NodeParts} parts Additional properties for the node.
   * @returns {IdentifierNode} The identifier node.
   */
  identifier(name, parts = {}) {
    return {
      type: "Identifier",
      name,
      loc: parts.loc,
      ...parts
    };
  },
  /**
   * Creates a NaN node.
   * @param {Sign} sign The sign for the Infinity.
   * @param {NodeParts} parts Additional properties for the node.
   * @returns {NaNNode} The NaN node.
   */
  nan(sign = "", parts = {}) {
    return {
      type: "NaN",
      sign,
      loc: parts.loc,
      ...parts
    };
  },
  /**
   * Creates an Infinity node.
   * @param {Sign} sign The sign for the Infinity.
   * @param {NodeParts} parts Additional properties for the node.
   * @returns {InfinityNode} The Infinity node.
   */
  infinity(sign = "", parts = {}) {
    return {
      type: "Infinity",
      sign,
      loc: parts.loc,
      ...parts
    };
  }
};
var DEFAULT_OPTIONS = {
  mode: "json",
  ranges: false,
  tokens: false,
  allowTrailingCommas: false
};
var UNICODE_SEQUENCE = /\\u[\da-fA-F]{4}/gu;
function normalizeIdentifier(identifier) {
  return identifier.replace(UNICODE_SEQUENCE, (unicodeEscape) => {
    return String.fromCharCode(parseInt(unicodeEscape.slice(2), 16));
  });
}
function getStringValue(value, token, json5 = false) {
  let result = "";
  let escapeIndex = value.indexOf("\\");
  let lastIndex = 0;
  while (escapeIndex >= 0) {
    result += value.slice(lastIndex, escapeIndex);
    const escapeChar = value.charAt(escapeIndex + 1);
    const escapeCharCode = escapeChar.charCodeAt(0);
    if (json5 && json5EscapeToChar.has(escapeCharCode)) {
      result += json5EscapeToChar.get(escapeCharCode);
      lastIndex = escapeIndex + 2;
    } else if (escapeToChar.has(escapeCharCode)) {
      result += escapeToChar.get(escapeCharCode);
      lastIndex = escapeIndex + 2;
    } else if (escapeChar === "u") {
      const hexCode = value.slice(escapeIndex + 2, escapeIndex + 6);
      if (hexCode.length < 4 || /[^0-9a-f]/i.test(hexCode)) {
        throw new ErrorWithLocation(
          `Invalid unicode escape \\u${hexCode}.`,
          {
            line: token.loc.start.line,
            column: token.loc.start.column + escapeIndex,
            offset: token.loc.start.offset + escapeIndex
          }
        );
      }
      result += String.fromCharCode(parseInt(hexCode, 16));
      lastIndex = escapeIndex + 6;
    } else if (json5 && escapeChar === "x") {
      const hexCode = value.slice(escapeIndex + 2, escapeIndex + 4);
      if (hexCode.length < 2 || /[^0-9a-f]/i.test(hexCode)) {
        throw new ErrorWithLocation(
          `Invalid hex escape \\x${hexCode}.`,
          {
            line: token.loc.start.line,
            column: token.loc.start.column + escapeIndex,
            offset: token.loc.start.offset + escapeIndex
          }
        );
      }
      result += String.fromCharCode(parseInt(hexCode, 16));
      lastIndex = escapeIndex + 4;
    } else if (json5 && json5LineTerminators.has(escapeCharCode)) {
      lastIndex = escapeIndex + 2;
      if (escapeChar === "\r" && value.charAt(lastIndex) === "\n") {
        lastIndex++;
      }
    } else {
      if (json5) {
        result += escapeChar;
        lastIndex = escapeIndex + 2;
      } else {
        throw new ErrorWithLocation(
          `Invalid escape \\${escapeChar}.`,
          {
            line: token.loc.start.line,
            column: token.loc.start.column + escapeIndex,
            offset: token.loc.start.offset + escapeIndex
          }
        );
      }
    }
    escapeIndex = value.indexOf("\\", lastIndex);
  }
  result += value.slice(lastIndex);
  return result;
}
function getLiteralValue(value, token, json5 = false) {
  switch (token.type) {
    case "Boolean":
      return value === "true";
    case "Number":
      if (json5) {
        if (value.charCodeAt(0) === 45) {
          return -Number(value.slice(1));
        }
        if (value.charCodeAt(0) === 43) {
          return Number(value.slice(1));
        }
      }
      return Number(value);
    case "String":
      return getStringValue(value.slice(1, -1), token, json5);
    default:
      throw new TypeError(`Unknown token type "${token.type}.`);
  }
}
function parse(text, options) {
  options = Object.freeze({
    ...DEFAULT_OPTIONS,
    ...options
  });
  const tokens = [];
  const tokenizer = new Tokenizer(text, {
    mode: options.mode,
    ranges: options.ranges
  });
  const json5 = options.mode === "json5";
  const allowTrailingCommas = options.allowTrailingCommas || json5;
  function nextNoComments() {
    const nextType = tokenizer.next();
    if (nextType && options.tokens) {
      tokens.push(tokenizer.token);
    }
    return nextType;
  }
  function nextSkipComments() {
    const nextType = tokenizer.next();
    if (nextType && options.tokens) {
      tokens.push(tokenizer.token);
    }
    if (nextType >= tt.LineComment) {
      return nextSkipComments();
    }
    return nextType;
  }
  const next = options.mode === "json" ? nextNoComments : nextSkipComments;
  function assertTokenType(token, type2) {
    if (token !== type2) {
      throw new UnexpectedToken(tokenizer.token);
    }
  }
  function assertTokenTypes(token, types22) {
    if (!types22.includes(token)) {
      throw new UnexpectedToken(tokenizer.token);
    }
  }
  function createRange(start, end) {
    return options.ranges ? {
      range: [start.offset, end.offset]
    } : void 0;
  }
  function createLiteralNode(tokenType) {
    const token = tokenizer.token;
    const range2 = createRange(token.loc.start, token.loc.end);
    const value = getLiteralValue(
      text.slice(token.loc.start.offset, token.loc.end.offset),
      token,
      json5
    );
    const loc = {
      start: {
        ...token.loc.start
      },
      end: {
        ...token.loc.end
      }
    };
    const parts = { loc, ...range2 };
    switch (tokenType) {
      case tt.String:
        return types.string(
          /** @type {string} */
          value,
          parts
        );
      case tt.Number:
        return types.number(
          /** @type {number} */
          value,
          parts
        );
      case tt.Boolean:
        return types.boolean(
          /** @type {boolean} */
          value,
          parts
        );
      default:
        throw new TypeError(`Unknown token type ${token.type}.`);
    }
  }
  function createJSON5IdentifierNode(token) {
    const range2 = createRange(token.loc.start, token.loc.end);
    const identifier = text.slice(token.loc.start.offset, token.loc.end.offset);
    const loc = {
      start: {
        ...token.loc.start
      },
      end: {
        ...token.loc.end
      }
    };
    const parts = { loc, ...range2 };
    if (token.type !== "Identifier") {
      let sign = "";
      if (identifier[0] === "+" || identifier[0] === "-") {
        sign = identifier[0];
      }
      return types[identifier.includes("NaN") ? "nan" : "infinity"](
        /** @type {Sign} */
        sign,
        parts
      );
    }
    return types.identifier(normalizeIdentifier(identifier), parts);
  }
  function createNullNode(token) {
    const range2 = createRange(token.loc.start, token.loc.end);
    return types.null({
      loc: {
        start: {
          ...token.loc.start
        },
        end: {
          ...token.loc.end
        }
      },
      ...range2
    });
  }
  function parseProperty(tokenType) {
    if (json5) {
      assertTokenTypes(tokenType, [tt.String, tt.Identifier, tt.Number]);
    } else {
      assertTokenType(tokenType, tt.String);
    }
    const token = tokenizer.token;
    if (json5 && tokenType === tt.Number && /[+\-0-9]/.test(text[token.loc.start.offset])) {
      throw new UnexpectedToken(token);
    }
    let key = tokenType === tt.String ? (
      /** @type {StringNode} */
      createLiteralNode(tokenType)
    ) : (
      /** @type {IdentifierNode|NaNNode|InfinityNode} */
      createJSON5IdentifierNode(token)
    );
    if (json5 && (key.type === "NaN" || key.type === "Infinity")) {
      if (key.sign !== "") {
        throw new UnexpectedToken(tokenizer.token);
      }
      key = types.identifier(key.type, { loc: key.loc, ...createRange(key.loc.start, key.loc.end) });
    }
    tokenType = next();
    assertTokenType(tokenType, tt.Colon);
    const value = parseValue();
    const range2 = createRange(key.loc.start, value.loc.end);
    return types.member(
      /** @type {StringNode|IdentifierNode} */
      key,
      /** @type {ValueNode} */
      value,
      {
        loc: {
          start: {
            ...key.loc.start
          },
          end: {
            ...value.loc.end
          }
        },
        ...range2
      }
    );
  }
  function parseObject(firstTokenType) {
    assertTokenType(firstTokenType, tt.LBrace);
    const firstToken = tokenizer.token;
    const members = [];
    let tokenType = next();
    if (tokenType !== tt.RBrace) {
      do {
        members.push(parseProperty(tokenType));
        tokenType = next();
        if (!tokenType) {
          throw new UnexpectedEOF(members[members.length - 1].loc.end);
        }
        if (tokenType === tt.Comma) {
          tokenType = next();
          if (allowTrailingCommas && tokenType === tt.RBrace) {
            break;
          }
        } else {
          break;
        }
      } while (tokenType);
    }
    assertTokenType(tokenType, tt.RBrace);
    const lastToken = tokenizer.token;
    const range2 = createRange(firstToken.loc.start, lastToken.loc.end);
    return types.object(members, {
      loc: {
        start: {
          ...firstToken.loc.start
        },
        end: {
          ...lastToken.loc.end
        }
      },
      ...range2
    });
  }
  function parseArray(firstTokenType) {
    assertTokenType(firstTokenType, tt.LBracket);
    const firstToken = tokenizer.token;
    const elements = [];
    let tokenType = next();
    if (tokenType !== tt.RBracket) {
      do {
        const value = parseValue(tokenType);
        elements.push(types.element(
          /** @type {ValueNode} */
          value,
          { loc: value.loc }
        ));
        tokenType = next();
        if (tokenType === tt.Comma) {
          tokenType = next();
          if (allowTrailingCommas && tokenType === tt.RBracket) {
            break;
          }
        } else {
          break;
        }
      } while (tokenType);
    }
    assertTokenType(tokenType, tt.RBracket);
    const lastToken = tokenizer.token;
    const range2 = createRange(firstToken.loc.start, lastToken.loc.end);
    return types.array(elements, {
      loc: {
        start: {
          ...firstToken.loc.start
        },
        end: {
          ...lastToken.loc.end
        }
      },
      ...range2
    });
  }
  function parseValue(tokenType) {
    tokenType = tokenType ?? next();
    const token = tokenizer.token;
    switch (tokenType) {
      case tt.String:
      case tt.Boolean:
        return createLiteralNode(tokenType);
      case tt.Number:
        if (json5) {
          let tokenText = text.slice(token.loc.start.offset, token.loc.end.offset);
          if (tokenText[0] === "+" || tokenText[0] === "-") {
            tokenText = tokenText.slice(1);
          }
          if (tokenText === "NaN" || tokenText === "Infinity") {
            return createJSON5IdentifierNode(token);
          }
        }
        return createLiteralNode(tokenType);
      case tt.Null:
        return createNullNode(token);
      case tt.LBrace:
        return parseObject(tokenType);
      case tt.LBracket:
        return parseArray(tokenType);
      default:
        throw new UnexpectedToken(token);
    }
  }
  const docBody = parseValue();
  const unexpectedToken = next();
  if (unexpectedToken) {
    throw new UnexpectedToken(tokenizer.token);
  }
  const docParts = {
    loc: {
      start: {
        line: 1,
        column: 1,
        offset: 0
      },
      end: {
        ...docBody.loc.end
      }
    }
  };
  if (options.tokens) {
    docParts.tokens = tokens;
  }
  if (options.ranges) {
    docParts.range = [
      docParts.loc.start.offset,
      docParts.loc.end.offset
    ];
  }
  return types.document(
    /** @type {ValueNode} */
    docBody,
    docParts
  );
}
var eq = (x) => (y) => x === y;
var not = (fn) => (x) => !fn(x);
var getValues = (o) => Object.values(o);
var notUndefined = (x) => x !== void 0;
var isXError = (x) => (error) => error.keyword === x;
var isRequiredError = isXError("required");
var isAnyOfError = isXError("anyOf");
var isEnumError = isXError("enum");
var getErrors = (node) => node && node.errors ? node.errors.map(
  (e) => e.keyword === "errorMessage" ? { ...e.params.errors[0], message: e.message } : e
) : [];
var getChildren = (node) => node && getValues(node.children) || [];
var getSiblings = (parent2) => (node) => getChildren(parent2).filter(not(eq(node)));
var concatAll = (xs) => (ys) => ys.reduce((zs, z) => zs.concat(z), xs);
var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
function getMarkerLines(loc, source) {
  const startLoc = {
    ...loc.start
  };
  const endLoc = {
    ...startLoc,
    ...loc.end
  };
  const linesAbove = 2;
  const linesBelow = 3;
  const startLine = startLoc.line;
  const startColumn = startLoc.column;
  const endLine = endLoc.line;
  const endColumn = endLoc.column;
  const start = Math.max(startLine - (linesAbove + 1), 0);
  const end = Math.min(source.length, endLine + linesBelow);
  const lineDiff = endLine - startLine;
  const markerLines = {};
  if (lineDiff) {
    for (let i = 0; i <= lineDiff; i++) {
      const lineNumber = i + startLine;
      if (!startColumn) {
        markerLines[lineNumber] = true;
      } else if (i === 0) {
        const sourceLength = source[lineNumber - 1].length;
        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
      } else if (i === lineDiff) {
        markerLines[lineNumber] = [0, endColumn];
      } else {
        const sourceLength = source[lineNumber - i].length;
        markerLines[lineNumber] = [0, sourceLength];
      }
    }
  } else {
    if (startColumn === endColumn) {
      if (startColumn) {
        markerLines[startLine] = [startColumn, 0];
      } else {
        markerLines[startLine] = true;
      }
    } else {
      markerLines[startLine] = [startColumn, endColumn - startColumn];
    }
  }
  return { start, end, markerLines };
}
function codeFrameColumns(rawLines, loc, opts = {}) {
  const lines = rawLines.split(NEWLINE);
  const { start, end, markerLines } = getMarkerLines(loc, lines);
  const numberMaxWidth = String(end).length;
  return rawLines.split(NEWLINE, end).slice(start, end).map((line, index) => {
    const number = start + 1 + index;
    const paddedNumber = ` ${String(number)}`.slice(-numberMaxWidth);
    const gutter = ` ${paddedNumber} |`;
    const hasMarker = markerLines[number];
    const lastMarkerLine = !markerLines[number + 1];
    if (hasMarker) {
      let markerLine = "";
      if (Array.isArray(hasMarker)) {
        const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
        const numberOfMarkers = hasMarker[1] || 1;
        markerLine = [
          "\n ",
          gutter.replace(/\d/g, " "),
          " ",
          markerSpacing,
          "^".repeat(numberOfMarkers)
        ].join("");
        if (lastMarkerLine && opts.message) {
          markerLine += " " + opts.message;
        }
      }
      return [
        ">",
        gutter,
        line.length > 0 ? ` ${line}` : "",
        markerLine
      ].join("");
    } else {
      return [" ", gutter, line.length > 0 ? ` ${line}` : ""].join("");
    }
  }).join("\n");
}
var getPointers = (dataPath) => {
  return dataPath.split("/").slice(1).map((pointer2) => pointer2.split("~1").join("/").split("~0").join("~"));
};
function getMetaFromPath(jsonAst, dataPath, includeIdentifierLocation) {
  const pointers = getPointers(dataPath);
  const lastPointerIndex = pointers.length - 1;
  return pointers.reduce((obj, pointer2, idx) => {
    switch (obj.type) {
      case "Object": {
        const filtered = obj.members.filter(
          (child) => child.name.value === pointer2
        );
        if (filtered.length !== 1) {
          throw new Error(`Couldn't find property ${pointer2} of ${dataPath}`);
        }
        const { name, value } = filtered[0];
        return includeIdentifierLocation && idx === lastPointerIndex ? name : value;
      }
      case "Array":
        return obj.elements[pointer2].value;
      default:
        console.log(obj);
    }
  }, jsonAst.body);
}
function getDecoratedDataPath(jsonAst, dataPath) {
  let decoratedPath = "";
  getPointers(dataPath).reduce((obj, pointer2) => {
    switch (obj.type) {
      case "Element":
        obj = obj.value;
      /* eslint-disable-next-line no-fallthrough -- explicitly want fallthrough here */
      case "Object": {
        decoratedPath += `/${pointer2}`;
        const filtered = obj.members.filter(
          (child) => child.name.value === pointer2
        );
        if (filtered.length !== 1) {
          throw new Error(`Couldn't find property ${pointer2} of ${dataPath}`);
        }
        return filtered[0].value;
      }
      case "Array": {
        decoratedPath += `/${pointer2}${getTypeName(obj.elements[pointer2])}`;
        return obj.elements[pointer2];
      }
      default:
        console.log(obj);
    }
  }, jsonAst.body);
  return decoratedPath;
}
function getTypeName(obj) {
  if (!obj || !obj.elements) {
    return "";
  }
  const type2 = obj.elements.filter(
    (child) => child && child.name && child.name.value === "type"
  );
  if (!type2.length) {
    return "";
  }
  return type2[0].value && `:${type2[0].value.value}` || "";
}
var BaseValidationError = class {
  constructor(options = { isIdentifierLocation: false }, { data, schema: schema2, jsonAst, jsonRaw }) {
    this.options = options;
    this.data = data;
    this.schema = schema2;
    this.jsonAst = jsonAst;
    this.jsonRaw = jsonRaw;
  }
  getLocation(dataPath = this.instancePath) {
    const { isIdentifierLocation, isSkipEndLocation } = this.options;
    const { loc } = getMetaFromPath(
      this.jsonAst,
      dataPath,
      isIdentifierLocation
    );
    return {
      start: loc.start,
      end: isSkipEndLocation ? void 0 : loc.end
    };
  }
  getDecoratedPath(dataPath = this.instancePath) {
    const decoratedPath = getDecoratedDataPath(this.jsonAst, dataPath);
    return decoratedPath;
  }
  getCodeFrame(message, dataPath = this.instancePath) {
    return codeFrameColumns(this.jsonRaw, this.getLocation(dataPath), {
      message
    });
  }
  /**
   * @return {string}
   */
  get instancePath() {
    return typeof this.options.instancePath !== "undefined" ? this.options.instancePath : this.options.dataPath;
  }
  print() {
    throw new Error(
      `Implement the 'print' method inside ${this.constructor.name}!`
    );
  }
  getError() {
    throw new Error(
      `Implement the 'getError' method inside ${this.constructor.name}!`
    );
  }
};
var REQUIRED = bold("REQUIRED");
var RequiredValidationError = class extends BaseValidationError {
  getLocation(dataPath = this.instancePath) {
    const { start } = super.getLocation(dataPath);
    return { start };
  }
  print() {
    const { message, params } = this.options;
    const line = red(`${REQUIRED} ${message}`);
    const output = [`${line}
`];
    return output.concat(
      this.getCodeFrame(`${magenta(params.missingProperty)} is missing here!`)
    );
  }
  getError() {
    const { message } = this.options;
    return {
      ...this.getLocation(),
      error: `${this.getDecoratedPath()} ${message}`,
      path: this.instancePath
    };
  }
};
var ADDITIONAL_PROPERTY = bold("ADDITIONAL PROPERTY");
var AdditionalPropValidationError = class extends BaseValidationError {
  constructor(...args) {
    super(...args);
    this.options.isIdentifierLocation = true;
  }
  print() {
    const { message, params } = this.options;
    const line = red(`${ADDITIONAL_PROPERTY} ${message}`);
    const output = [`${line}
`];
    return output.concat(
      this.getCodeFrame(
        `${magenta(params.additionalProperty)} is not expected to be here!`,
        `${this.instancePath}/${params.additionalProperty}`
      )
    );
  }
  getError() {
    const { params } = this.options;
    return {
      ...this.getLocation(`${this.instancePath}/${params.additionalProperty}`),
      error: `${this.getDecoratedPath()} Property ${params.additionalProperty} is not expected to be here`,
      path: this.instancePath
    };
  }
};
var import_leven = __toESM2(require_leven());
var import_jsonpointer = __toESM2(require_jsonpointer());
var ENUM = bold("ENUM");
var EnumValidationError = class extends BaseValidationError {
  print() {
    const {
      message,
      params: { allowedValues }
    } = this.options;
    const bestMatch = this.findBestMatch();
    const line1 = red(`${ENUM} ${message}`);
    const line2 = red(`(${allowedValues.join(", ")})`);
    const output = [line1, `${line2}
`];
    return output.concat(
      this.getCodeFrame(
        bestMatch !== null ? `Did you mean ${magenta(bestMatch)} here?` : `Unexpected value, should be equal to one of the allowed values`
      )
    );
  }
  getError() {
    const { message, params } = this.options;
    const bestMatch = this.findBestMatch();
    const allowedValues = params.allowedValues.join(", ");
    const output = {
      ...this.getLocation(),
      error: `${this.getDecoratedPath()} ${message}: ${allowedValues}`,
      path: this.instancePath
    };
    if (bestMatch !== null) {
      output.suggestion = `Did you mean ${bestMatch}?`;
    }
    return output;
  }
  findBestMatch() {
    const {
      params: { allowedValues }
    } = this.options;
    const currentValue = this.instancePath === "" ? this.data : import_jsonpointer.default.get(this.data, this.instancePath);
    if (!currentValue) {
      return null;
    }
    const bestMatch = allowedValues.map((value) => ({
      value,
      weight: (0, import_leven.default)(value, currentValue.toString())
    })).sort(
      (x, y) => x.weight > y.weight ? 1 : x.weight < y.weight ? -1 : 0
    )[0];
    return allowedValues.length === 1 || bestMatch.weight < bestMatch.value.length ? bestMatch.value : null;
  }
};
var DefaultValidationError = class extends BaseValidationError {
  print() {
    const { keyword, message } = this.options;
    const line = red(`${bold(keyword.toUpperCase())} ${message}`);
    const output = [`${line}
`];
    return output.concat(this.getCodeFrame(`${magenta(keyword)} ${message}`));
  }
  getError() {
    const { keyword, message } = this.options;
    return {
      ...this.getLocation(),
      error: `${this.getDecoratedPath()}: ${keyword} ${message}`,
      path: this.instancePath
    };
  }
};
var JSON_POINTERS_REGEX = /\/[\w_-]+(\/\d+)?/g;
function makeTree(ajvErrors = []) {
  const root = { children: {} };
  ajvErrors.forEach((ajvError) => {
    const instancePath = typeof ajvError.instancePath !== "undefined" ? ajvError.instancePath : ajvError.dataPath;
    const paths = instancePath === "" ? [""] : instancePath.match(JSON_POINTERS_REGEX);
    paths && paths.reduce((obj, path5, i) => {
      obj.children[path5] = obj.children[path5] || { children: {}, errors: [] };
      if (i === paths.length - 1) {
        obj.children[path5].errors.push(ajvError);
      }
      return obj.children[path5];
    }, root);
  });
  return root;
}
function filterRedundantErrors(root, parent2, key) {
  getErrors(root).forEach((error) => {
    if (isRequiredError(error)) {
      root.errors = [error];
      root.children = {};
    }
  });
  if (getErrors(root).some(isAnyOfError)) {
    if (Object.keys(root.children).length > 0) {
      delete root.errors;
    }
  }
  if (root.errors && root.errors.length && getErrors(root).every(isEnumError)) {
    if (getSiblings(parent2)(root).filter(notUndefined).some(getErrors)) {
      delete parent2.children[key];
    }
  }
  Object.entries(root.children).forEach(
    ([key2, child]) => filterRedundantErrors(child, root, key2)
  );
}
function createErrorInstances(root, options) {
  const errors = getErrors(root);
  if (errors.length && errors.every(isEnumError)) {
    const uniqueValues = new Set(
      concatAll([])(errors.map((e) => e.params.allowedValues))
    );
    const allowedValues = [...uniqueValues];
    const error = errors[0];
    return [
      new EnumValidationError(
        {
          ...error,
          params: { allowedValues }
        },
        options
      )
    ];
  } else {
    return concatAll(
      errors.reduce((ret, error) => {
        switch (error.keyword) {
          case "additionalProperties":
            return ret.concat(
              new AdditionalPropValidationError(error, options)
            );
          case "enum":
            return ret.concat(new EnumValidationError(error, options));
          case "required":
            return ret.concat(new RequiredValidationError(error, options));
          default:
            return ret.concat(new DefaultValidationError(error, options));
        }
      }, [])
    )(getChildren(root).map((child) => createErrorInstances(child, options)));
  }
}
var helpers_default = (ajvErrors, options) => {
  const tree = makeTree(ajvErrors || []);
  filterRedundantErrors(tree);
  return createErrorInstances(tree, options);
};
var index_default = (schema2, data, errors, options = {}) => {
  const { format: format2 = "cli", indent = null, json = null } = options;
  const jsonRaw = json || JSON.stringify(data, null, indent);
  const jsonAst = parse(jsonRaw);
  const customErrorToText = (error) => error.print().join("\n");
  const customErrorToStructure = (error) => error.getError();
  const customErrors = helpers_default(errors, {
    data,
    schema: schema2,
    jsonAst,
    jsonRaw
  });
  if (format2 === "cli") {
    return customErrors.map(customErrorToText).join("\n\n");
  } else {
    return customErrors.map(customErrorToStructure);
  }
};

// node_modules/kleur/index.mjs
var FORCE_COLOR2;
var NODE_DISABLE_COLORS2;
var NO_COLOR2;
var TERM2;
var isTTY2 = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR: FORCE_COLOR2, NODE_DISABLE_COLORS: NODE_DISABLE_COLORS2, NO_COLOR: NO_COLOR2, TERM: TERM2 } = process.env || {});
  isTTY2 = process.stdout && process.stdout.isTTY;
}
var $2 = {
  enabled: !NODE_DISABLE_COLORS2 && NO_COLOR2 == null && TERM2 !== "dumb" && (FORCE_COLOR2 != null && FORCE_COLOR2 !== "0" || isTTY2),
  // modifiers
  reset: init2(0, 0),
  bold: init2(1, 22),
  dim: init2(2, 22),
  italic: init2(3, 23),
  underline: init2(4, 24),
  inverse: init2(7, 27),
  hidden: init2(8, 28),
  strikethrough: init2(9, 29),
  // colors
  black: init2(30, 39),
  red: init2(31, 39),
  green: init2(32, 39),
  yellow: init2(33, 39),
  blue: init2(34, 39),
  magenta: init2(35, 39),
  cyan: init2(36, 39),
  white: init2(37, 39),
  gray: init2(90, 39),
  grey: init2(90, 39),
  // background colors
  bgBlack: init2(40, 49),
  bgRed: init2(41, 49),
  bgGreen: init2(42, 49),
  bgYellow: init2(43, 49),
  bgBlue: init2(44, 49),
  bgMagenta: init2(45, 49),
  bgCyan: init2(46, 49),
  bgWhite: init2(47, 49)
};
function run(arr, str) {
  let i = 0, tmp, beg = "", end = "";
  for (; i < arr.length; i++) {
    tmp = arr[i];
    beg += tmp.open;
    end += tmp.close;
    if (!!~str.indexOf(tmp.close)) {
      str = str.replace(tmp.rgx, tmp.close + tmp.open);
    }
  }
  return beg + str + end;
}
function chain(has, keys) {
  let ctx = { has, keys };
  ctx.reset = $2.reset.bind(ctx);
  ctx.bold = $2.bold.bind(ctx);
  ctx.dim = $2.dim.bind(ctx);
  ctx.italic = $2.italic.bind(ctx);
  ctx.underline = $2.underline.bind(ctx);
  ctx.inverse = $2.inverse.bind(ctx);
  ctx.hidden = $2.hidden.bind(ctx);
  ctx.strikethrough = $2.strikethrough.bind(ctx);
  ctx.black = $2.black.bind(ctx);
  ctx.red = $2.red.bind(ctx);
  ctx.green = $2.green.bind(ctx);
  ctx.yellow = $2.yellow.bind(ctx);
  ctx.blue = $2.blue.bind(ctx);
  ctx.magenta = $2.magenta.bind(ctx);
  ctx.cyan = $2.cyan.bind(ctx);
  ctx.white = $2.white.bind(ctx);
  ctx.gray = $2.gray.bind(ctx);
  ctx.grey = $2.grey.bind(ctx);
  ctx.bgBlack = $2.bgBlack.bind(ctx);
  ctx.bgRed = $2.bgRed.bind(ctx);
  ctx.bgGreen = $2.bgGreen.bind(ctx);
  ctx.bgYellow = $2.bgYellow.bind(ctx);
  ctx.bgBlue = $2.bgBlue.bind(ctx);
  ctx.bgMagenta = $2.bgMagenta.bind(ctx);
  ctx.bgCyan = $2.bgCyan.bind(ctx);
  ctx.bgWhite = $2.bgWhite.bind(ctx);
  return ctx;
}
function init2(open, close) {
  let blk = {
    open: `\x1B[${open}m`,
    close: `\x1B[${close}m`,
    rgx: new RegExp(`\\x1b\\[${close}m`, "g")
  };
  return function(txt) {
    if (this !== void 0 && this.has !== void 0) {
      !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));
      return txt === void 0 ? this : $2.enabled ? run(this.keys, txt + "") : txt + "";
    }
    return txt === void 0 ? chain([open], [blk]) : $2.enabled ? run([blk], txt + "") : txt + "";
  };
}
var kleur_default = $2;

// node_modules/@html-validate/stylish/dist/esm/node.js
var __create3 = Object.create;
var __defProp3 = Object.defineProperty;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames3 = Object.getOwnPropertyNames;
var __getProtoOf3 = Object.getPrototypeOf;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __commonJS3 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames3(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps3 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames3(from))
      if (!__hasOwnProp3.call(to, key) && key !== except)
        __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM3 = (mod, isNodeMode, target) => (target = mod != null ? __create3(__getProtoOf3(mod)) : {}, __copyProps3(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_text_table = __commonJS3({
  "node_modules/text-table/index.js"(exports2, module2) {
    module2.exports = function(rows_, opts) {
      if (!opts) opts = {};
      var hsep = opts.hsep === void 0 ? "  " : opts.hsep;
      var align = opts.align || [];
      var stringLength = opts.stringLength || function(s) {
        return String(s).length;
      };
      var dotsizes = reduce(rows_, function(acc, row) {
        forEach(row, function(c, ix) {
          var n = dotindex(c);
          if (!acc[ix] || n > acc[ix]) acc[ix] = n;
        });
        return acc;
      }, []);
      var rows = map(rows_, function(row) {
        return map(row, function(c_, ix) {
          var c = String(c_);
          if (align[ix] === ".") {
            var index = dotindex(c);
            var size = dotsizes[ix] + (/\./.test(c) ? 1 : 2) - (stringLength(c) - index);
            return c + Array(size).join(" ");
          } else return c;
        });
      });
      var sizes = reduce(rows, function(acc, row) {
        forEach(row, function(c, ix) {
          var n = stringLength(c);
          if (!acc[ix] || n > acc[ix]) acc[ix] = n;
        });
        return acc;
      }, []);
      return map(rows, function(row) {
        return map(row, function(c, ix) {
          var n = sizes[ix] - stringLength(c) || 0;
          var s = Array(Math.max(n + 1, 1)).join(" ");
          if (align[ix] === "r" || align[ix] === ".") {
            return s + c;
          }
          if (align[ix] === "c") {
            return Array(Math.ceil(n / 2 + 1)).join(" ") + c + Array(Math.floor(n / 2 + 1)).join(" ");
          }
          return c + s;
        }).join(hsep).replace(/\s+$/, "");
      }).join("\n");
    };
    function dotindex(c) {
      var m = /\.[^.]*$/.exec(c);
      return m ? m.index + 1 : c.length;
    }
    function reduce(xs, f, init3) {
      if (xs.reduce) return xs.reduce(f, init3);
      var i = 0;
      var acc = arguments.length >= 3 ? init3 : xs[i++];
      for (; i < xs.length; i++) {
        f(acc, xs[i], i);
      }
      return acc;
    }
    function forEach(xs, f) {
      if (xs.forEach) return xs.forEach(f);
      for (var i = 0; i < xs.length; i++) {
        f.call(xs, xs[i], i);
      }
    }
    function map(xs, f) {
      if (xs.map) return xs.map(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        res.push(f.call(xs, xs[i], i));
      }
      return res;
    }
  }
});
var import_text_table = __toESM3(require_text_table());
var reset2 = reset;
var bold2 = bold;
var dim2 = dim;
var underline2 = underline;
var yellow2 = yellow;
var red2 = red;
function pluralize(word, count) {
  return count === 1 ? word : `${word}s`;
}
function centerLineColumn(el) {
  return el.replace(/(\d+)\s+(\d+)/u, (_m, p1, p2) => dim2(`${p1}:${p2}`));
}
function stripAnsi(text) {
  return text.replace(/\u001B\[[0-9;]*m/g, "");
}
function stylish(results) {
  let output = "\n";
  let errorCount = 0;
  let warningCount = 0;
  let fixableErrorCount = 0;
  let fixableWarningCount = 0;
  let summaryColor = yellow2;
  results.forEach((result) => {
    const messages = result.messages;
    if (messages.length === 0) {
      return;
    }
    errorCount += result.errorCount;
    warningCount += result.warningCount;
    fixableErrorCount += result.fixableErrorCount;
    fixableWarningCount += result.fixableWarningCount;
    const rows = messages.map((message) => {
      let messageType;
      if (Boolean(message.fatal) || message.severity === 2) {
        messageType = red2("error");
        summaryColor = red2;
      } else {
        messageType = yellow2("warning");
      }
      return [
        "",
        message.line ?? 0,
        message.column ?? 0,
        messageType,
        message.message.replace(/([^ ])\.$/u, "$1"),
        message.ruleId ? dim2(message.ruleId) : ""
      ];
    });
    const options = {
      align: ["l", "r", "l"],
      stringLength(str) {
        return stripAnsi(str).length;
      }
    };
    const formattedTable = (0, import_text_table.default)(rows, options).split("\n").map(centerLineColumn).join("\n");
    output += `${underline2(result.filePath)}
`;
    output += `${formattedTable}

`;
  });
  const total = errorCount + warningCount;
  if (total > 0) {
    output += summaryColor(
      bold2(
        [
          "\u2716 ",
          total,
          pluralize(" problem", total),
          " (",
          errorCount,
          pluralize(" error", errorCount),
          ", ",
          warningCount,
          pluralize(" warning", warningCount),
          ")\n"
        ].join("")
      )
    );
    if (fixableErrorCount > 0 || fixableWarningCount > 0) {
      output += summaryColor(
        bold2(
          [
            "  ",
            fixableErrorCount,
            pluralize(" error", fixableErrorCount),
            " and ",
            fixableWarningCount,
            pluralize(" warning", fixableWarningCount),
            " potentially fixable with the `--fix` option.\n"
          ].join("")
        )
      );
    }
  }
  return total > 0 ? reset2(output) : "";
}

// node_modules/html-validate/dist/esm/core.js
var import_semver = __toESM(require_semver2(), 1);
var $schema$2 = "http://json-schema.org/draft-06/schema#";
var $id$2 = "http://json-schema.org/draft-06/schema#";
var title = "Core schema meta-schema";
var definitions$1 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
var type$2 = [
  "object",
  "boolean"
];
var properties$2 = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": {},
  examples: {
    type: "array",
    items: {}
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": {}
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": {},
  "enum": {
    type: "array",
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
var ajvSchemaDraft = {
  $schema: $schema$2,
  $id: $id$2,
  title,
  definitions: definitions$1,
  type: type$2,
  properties: properties$2,
  "default": {}
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var cjs;
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  var isMergeableObject = function isMergeableObject2(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge2;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge2;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge2(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge2.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error("first argument should be an array");
    }
    return array.reduce(function(prev, next) {
      return deepmerge2(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge2;
  cjs = deepmerge_1;
  return cjs;
}
var cjsExports = /* @__PURE__ */ requireCjs();
var deepmerge = /* @__PURE__ */ getDefaultExportFromCjs(cjsExports);
function stringify(value) {
  if (typeof value === "string") {
    return value;
  } else {
    return JSON.stringify(value);
  }
}
var WrappedError = class extends Error {
  constructor(message) {
    super(stringify(message));
  }
};
function ensureError(value) {
  if (value instanceof Error) {
    return value;
  } else {
    return new WrappedError(value);
  }
}
var NestedError = class _NestedError extends Error {
  constructor(message, nested) {
    super(message);
    Error.captureStackTrace(this, _NestedError);
    this.name = _NestedError.name;
    if (nested?.stack) {
      this.stack ??= "";
      this.stack += `
Caused by: ${nested.stack}`;
    }
  }
};
var UserError = class _UserError extends NestedError {
  constructor(message, nested) {
    super(message, nested);
    Error.captureStackTrace(this, _UserError);
    this.name = _UserError.name;
    Object.defineProperty(this, "isUserError", {
      value: true,
      enumerable: false,
      writable: false
    });
  }
  /**
   * @public
   */
  /* istanbul ignore next: default implementation */
  prettyFormat() {
    return void 0;
  }
};
var InheritError = class _InheritError extends UserError {
  tagName;
  inherit;
  filename;
  constructor({ tagName, inherit }) {
    const message = `Element <${tagName}> cannot inherit from <${inherit}>: no such element`;
    super(message);
    Error.captureStackTrace(this, _InheritError);
    this.name = _InheritError.name;
    this.tagName = tagName;
    this.inherit = inherit;
    this.filename = null;
  }
  prettyFormat() {
    const { message, tagName, inherit } = this;
    const source = this.filename ? ["", "This error occurred when loading element metadata from:", `"${this.filename}"`, ""] : [""];
    return [
      message,
      ...source,
      "This usually occurs when the elements are defined in the wrong order, try one of the following:",
      "",
      `  - Ensure the spelling of "${inherit}" is correct.`,
      `  - Ensure the file containing "${inherit}" is loaded before the file containing "${tagName}".`,
      `  - Move the definition of "${inherit}" above the definition for "${tagName}".`
    ].join("\n");
  }
};
function getSummary(schema2, obj, errors) {
  const output = index_default(schema2, obj, errors, {
    format: "js"
  });
  return output.length > 0 ? output[0].error : "unknown validation error";
}
var SchemaValidationError = class extends UserError {
  /** Configuration filename the error originates from */
  filename;
  /** Configuration object the error originates from */
  obj;
  /** JSON schema used when validating the configuration */
  schema;
  /** List of schema validation errors */
  errors;
  constructor(filename, message, obj, schema2, errors) {
    const summary = getSummary(schema2, obj, errors);
    super(`${message}: ${summary}`);
    this.filename = filename;
    this.obj = obj;
    this.schema = schema2;
    this.errors = errors;
  }
};
function cyrb53(str) {
  const a = 2654435761;
  const b = 1597334677;
  const c = 2246822507;
  const d = 3266489909;
  const e = 4294967296;
  const f = 2097151;
  const seed = 0;
  let h1 = 3735928559 ^ seed;
  let h2 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, a);
    h2 = Math.imul(h2 ^ ch, b);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, c) ^ Math.imul(h2 ^ h2 >>> 13, d);
  h2 = Math.imul(h2 ^ h2 >>> 16, c) ^ Math.imul(h1 ^ h1 >>> 13, d);
  return e * (f & h2) + (h1 >>> 0);
}
var computeHash = cyrb53;
var $schema$1 = "http://json-schema.org/draft-06/schema#";
var $id$1 = "https://html-validate.org/schemas/elements.json";
var type$1 = "object";
var properties$1 = {
  $schema: {
    type: "string"
  }
};
var patternProperties = {
  "^[^$].*$": {
    type: "object",
    properties: {
      inherit: {
        title: "Inherit from another element",
        description: "Most properties from the parent element will be copied onto this one",
        type: "string"
      },
      embedded: {
        title: "Mark this element as belonging in the embedded content category",
        $ref: "#/definitions/contentCategory"
      },
      flow: {
        title: "Mark this element as belonging in the flow content category",
        $ref: "#/definitions/contentCategory"
      },
      heading: {
        title: "Mark this element as belonging in the heading content category",
        $ref: "#/definitions/contentCategory"
      },
      interactive: {
        title: "Mark this element as belonging in the interactive content category",
        $ref: "#/definitions/contentCategory"
      },
      metadata: {
        title: "Mark this element as belonging in the metadata content category",
        $ref: "#/definitions/contentCategory"
      },
      phrasing: {
        title: "Mark this element as belonging in the phrasing content category",
        $ref: "#/definitions/contentCategory"
      },
      sectioning: {
        title: "Mark this element as belonging in the sectioning content category",
        $ref: "#/definitions/contentCategory"
      },
      deprecated: {
        title: "Mark element as deprecated",
        description: "Deprecated elements should not be used. If a message is provided it will be included in the error",
        anyOf: [
          {
            type: "boolean"
          },
          {
            type: "string"
          },
          {
            $ref: "#/definitions/deprecatedElement"
          }
        ]
      },
      foreign: {
        title: "Mark element as foreign",
        description: "Foreign elements are elements which have a start and end tag but is otherwize not parsed",
        type: "boolean"
      },
      "void": {
        title: "Mark element as void",
        description: "Void elements are elements which cannot have content and thus must not use an end tag",
        type: "boolean"
      },
      transparent: {
        title: "Mark element as transparent",
        description: "Transparent elements follows the same content model as its parent, i.e. the content must be allowed in the parent.",
        anyOf: [
          {
            type: "boolean"
          },
          {
            type: "array",
            items: {
              type: "string"
            }
          }
        ]
      },
      implicitClosed: {
        title: "List of elements which implicitly closes this element",
        description: "Some elements are automatically closed when another start tag occurs",
        type: "array",
        items: {
          type: "string"
        }
      },
      implicitRole: {
        title: "Implicit ARIA role for this element",
        description: "Some elements have implicit ARIA roles.",
        deprecated: true,
        "function": true
      },
      aria: {
        title: "WAI-ARIA properties for this element",
        $ref: "#/definitions/Aria"
      },
      scriptSupporting: {
        title: "Mark element as script-supporting",
        description: "Script-supporting elements are elements which can be inserted where othersise not permitted to assist in templating",
        type: "boolean"
      },
      focusable: {
        title: "Mark this element as focusable",
        description: "This element may contain an associated label element.",
        anyOf: [
          {
            type: "boolean"
          },
          {
            "function": true
          }
        ]
      },
      form: {
        title: "Mark element as a submittable form element",
        type: "boolean"
      },
      formAssociated: {
        title: "Mark element as a form-associated element",
        $ref: "#/definitions/FormAssociated"
      },
      labelable: {
        title: "Mark this element as labelable",
        description: "This element may contain an associated label element.",
        anyOf: [
          {
            type: "boolean"
          },
          {
            "function": true
          }
        ]
      },
      templateRoot: {
        title: "Mark element as an element ignoring DOM ancestry, i.e. <template>.",
        description: "The <template> element can contain any elements.",
        type: "boolean"
      },
      deprecatedAttributes: {
        title: "List of deprecated attributes",
        type: "array",
        items: {
          type: "string"
        }
      },
      requiredAttributes: {
        title: "List of required attributes",
        type: "array",
        items: {
          type: "string"
        }
      },
      attributes: {
        title: "List of known attributes and allowed values",
        $ref: "#/definitions/PermittedAttribute"
      },
      permittedContent: {
        title: "List of elements or categories allowed as content in this element",
        $ref: "#/definitions/Permitted"
      },
      permittedDescendants: {
        title: "List of elements or categories allowed as descendants in this element",
        $ref: "#/definitions/Permitted"
      },
      permittedOrder: {
        title: "Required order of child elements",
        $ref: "#/definitions/PermittedOrder"
      },
      permittedParent: {
        title: "List of elements or categories allowed as parent to this element",
        $ref: "#/definitions/Permitted"
      },
      requiredAncestors: {
        title: "List of required ancestor elements",
        $ref: "#/definitions/RequiredAncestors"
      },
      requiredContent: {
        title: "List of required content elements",
        $ref: "#/definitions/RequiredContent"
      },
      textContent: {
        title: "Allow, disallow or require textual content",
        description: "This property controls whenever an element allows, disallows or requires text. Text from any descendant counts, not only direct children",
        "default": "default",
        type: "string",
        "enum": [
          "none",
          "default",
          "required",
          "accessible"
        ]
      }
    },
    additionalProperties: false
  }
};
var definitions = {
  Aria: {
    type: "object",
    additionalProperties: false,
    properties: {
      implicitRole: {
        title: "Implicit ARIA role for this element",
        description: "Some elements have implicit ARIA roles.",
        anyOf: [
          {
            type: "string"
          },
          {
            "function": true
          }
        ]
      },
      naming: {
        title: "Prohibit or allow this element to be named by aria-label or aria-labelledby",
        anyOf: [
          {
            type: "string",
            "enum": [
              "prohibited",
              "allowed"
            ]
          },
          {
            "function": true
          }
        ]
      }
    }
  },
  contentCategory: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        "function": true
      }
    ]
  },
  deprecatedElement: {
    type: "object",
    additionalProperties: false,
    properties: {
      message: {
        type: "string",
        title: "A short text message shown next to the regular error message."
      },
      documentation: {
        type: "string",
        title: "An extended markdown formatted message shown with the contextual rule documentation."
      },
      source: {
        type: "string",
        title: "Element source, e.g. what standard or library deprecated this element.",
        "default": "html5"
      }
    }
  },
  FormAssociated: {
    type: "object",
    additionalProperties: false,
    properties: {
      disablable: {
        type: "boolean",
        title: "Disablable elements can be disabled using the disabled attribute."
      },
      listed: {
        type: "boolean",
        title: "Listed elements have a name attribute and is listed in the form and fieldset elements property."
      }
    }
  },
  Permitted: {
    type: "array",
    items: {
      anyOf: [
        {
          type: "string"
        },
        {
          type: "array",
          items: {
            anyOf: [
              {
                type: "string"
              },
              {
                $ref: "#/definitions/PermittedGroup"
              }
            ]
          }
        },
        {
          $ref: "#/definitions/PermittedGroup"
        }
      ]
    }
  },
  PermittedAttribute: {
    type: "object",
    patternProperties: {
      "^.*$": {
        anyOf: [
          {
            type: "object",
            additionalProperties: false,
            properties: {
              allowed: {
                "function": true,
                title: "Set to a function to evaluate if this attribute is allowed in this context"
              },
              boolean: {
                type: "boolean",
                title: "Set to true if this is a boolean attribute"
              },
              deprecated: {
                title: "Set to true or string if this attribute is deprecated",
                oneOf: [
                  {
                    type: "boolean"
                  },
                  {
                    type: "string"
                  }
                ]
              },
              list: {
                type: "boolean",
                title: "Set to true if this attribute is a list of space-separated tokens, each which must be valid by itself"
              },
              "enum": {
                type: "array",
                title: "Exhaustive list of values (string or regex) this attribute accepts",
                uniqueItems: true,
                items: {
                  anyOf: [
                    {
                      type: "string"
                    },
                    {
                      regexp: true
                    }
                  ]
                }
              },
              omit: {
                type: "boolean",
                title: "Set to true if this attribute can optionally omit its value"
              },
              required: {
                type: "boolean",
                title: "Set to true if this attribute is required"
              }
            }
          },
          {
            type: "array",
            uniqueItems: true,
            items: {
              type: "string"
            }
          },
          {
            type: "null"
          }
        ]
      }
    }
  },
  PermittedGroup: {
    type: "object",
    additionalProperties: false,
    properties: {
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "string"
          }
        ]
      }
    }
  },
  PermittedOrder: {
    type: "array",
    items: {
      type: "string"
    }
  },
  RequiredAncestors: {
    type: "array",
    items: {
      type: "string"
    }
  },
  RequiredContent: {
    type: "array",
    items: {
      type: "string"
    }
  }
};
var schema = {
  $schema: $schema$1,
  $id: $id$1,
  type: type$1,
  properties: properties$1,
  patternProperties,
  definitions
};
var ajvRegexpValidate = function(data, dataCxt) {
  const valid = data instanceof RegExp;
  if (!valid) {
    ajvRegexpValidate.errors = [
      {
        instancePath: dataCxt?.instancePath,
        schemaPath: void 0,
        keyword: "type",
        message: "should be a regular expression",
        params: {
          keyword: "type"
        }
      }
    ];
  }
  return valid;
};
var ajvRegexpKeyword = {
  keyword: "regexp",
  schema: false,
  errors: true,
  validate: ajvRegexpValidate
};
var ajvFunctionValidate = function(data, dataCxt) {
  const valid = typeof data === "function";
  if (!valid) {
    ajvFunctionValidate.errors = [
      {
        instancePath: (
          /* istanbul ignore next */
          dataCxt?.instancePath
        ),
        schemaPath: void 0,
        keyword: "type",
        message: "should be a function",
        params: {
          keyword: "type"
        }
      }
    ];
  }
  return valid;
};
var ajvFunctionKeyword = {
  keyword: "function",
  schema: false,
  errors: true,
  validate: ajvFunctionValidate
};
var TextContent$1 = /* @__PURE__ */ ((TextContent2) => {
  TextContent2["NONE"] = "none";
  TextContent2["DEFAULT"] = "default";
  TextContent2["REQUIRED"] = "required";
  TextContent2["ACCESSIBLE"] = "accessible";
  return TextContent2;
})(TextContent$1 || {});
var MetaCopyableProperty = [
  "metadata",
  "flow",
  "sectioning",
  "heading",
  "phrasing",
  "embedded",
  "interactive",
  "transparent",
  "focusable",
  "form",
  "formAssociated",
  "labelable",
  "attributes",
  "aria",
  "permittedContent",
  "permittedDescendants",
  "permittedOrder",
  "permittedParent",
  "requiredAncestors",
  "requiredContent"
];
function setMetaProperty(dst, key, value) {
  dst[key] = value;
}
function isSet(value) {
  return typeof value !== "undefined";
}
function flag(value) {
  return value ? true : void 0;
}
function stripUndefined(src) {
  const entries = Object.entries(src).filter(([, value]) => isSet(value));
  return Object.fromEntries(entries);
}
function migrateSingleAttribute(src, key) {
  const result = {};
  result.deprecated = flag(src.deprecatedAttributes?.includes(key));
  result.required = flag(src.requiredAttributes?.includes(key));
  result.omit = void 0;
  const attr = src.attributes ? src.attributes[key] : void 0;
  if (typeof attr === "undefined") {
    return stripUndefined(result);
  }
  if (attr === null) {
    result.delete = true;
    return stripUndefined(result);
  }
  if (Array.isArray(attr)) {
    if (attr.length === 0) {
      result.boolean = true;
    } else {
      result.enum = attr.filter((it) => it !== "");
      if (attr.includes("")) {
        result.omit = true;
      }
    }
    return stripUndefined(result);
  } else {
    return stripUndefined({ ...result, ...attr });
  }
}
function migrateAttributes(src) {
  const keys = [
    ...Object.keys(src.attributes ?? {}),
    ...src.requiredAttributes ?? [],
    ...src.deprecatedAttributes ?? []
    /* eslint-disable-next-line sonarjs/no-alphabetical-sort -- not really needed in this case, this is a-z anyway */
  ].sort();
  const entries = keys.map((key) => {
    return [key, migrateSingleAttribute(src, key)];
  });
  return Object.fromEntries(entries);
}
function normalizeAriaImplicitRole(value) {
  if (!value) {
    return () => null;
  }
  if (typeof value === "string") {
    return () => value;
  }
  return value;
}
function normalizeAriaNaming(value) {
  if (!value) {
    return () => "allowed";
  }
  if (typeof value === "string") {
    return () => value;
  }
  return value;
}
function migrateElement(src) {
  const implicitRole = normalizeAriaImplicitRole(src.implicitRole ?? src.aria?.implicitRole);
  const result = {
    ...src,
    ...{
      formAssociated: void 0
    },
    attributes: migrateAttributes(src),
    textContent: src.textContent,
    focusable: src.focusable ?? false,
    implicitRole,
    templateRoot: src.templateRoot === true,
    aria: {
      implicitRole,
      naming: normalizeAriaNaming(src.aria?.naming)
    }
  };
  delete result.deprecatedAttributes;
  delete result.requiredAttributes;
  if (!result.textContent) {
    delete result.textContent;
  }
  if (src.formAssociated) {
    result.formAssociated = {
      disablable: Boolean(src.formAssociated.disablable),
      listed: Boolean(src.formAssociated.listed)
    };
  } else {
    delete result.formAssociated;
  }
  return result;
}
var dynamicKeys = [
  "metadata",
  "flow",
  "sectioning",
  "heading",
  "phrasing",
  "embedded",
  "interactive",
  "labelable"
];
var schemaCache = /* @__PURE__ */ new Map();
function clone(src) {
  return JSON.parse(JSON.stringify(src));
}
function overwriteMerge$1(_a, b) {
  return b;
}
var MetaTable = class {
  elements;
  schema;
  /**
   * @internal
   */
  constructor() {
    this.elements = {};
    this.schema = clone(schema);
  }
  /**
   * @internal
   */
  init() {
    this.resolveGlobal();
  }
  /**
   * Extend validation schema.
   *
   * @public
   */
  extendValidationSchema(patch) {
    if (patch.properties) {
      this.schema = deepmerge(this.schema, {
        patternProperties: {
          "^[^$].*$": {
            properties: patch.properties
          }
        }
      });
    }
    if (patch.definitions) {
      this.schema = deepmerge(this.schema, {
        definitions: patch.definitions
      });
    }
  }
  /**
   * Load metadata table from object.
   *
   * @public
   * @param obj - Object with metadata to load
   * @param filename - Optional filename used when presenting validation error
   */
  loadFromObject(obj, filename = null) {
    try {
      const validate = this.getSchemaValidator();
      if (!validate(obj)) {
        throw new SchemaValidationError(
          filename,
          `Element metadata is not valid`,
          obj,
          this.schema,
          /* istanbul ignore next: AJV sets .errors when validate returns false */
          validate.errors ?? []
        );
      }
      for (const [key, value] of Object.entries(obj)) {
        if (key === "$schema") continue;
        this.addEntry(key, migrateElement(value));
      }
    } catch (err) {
      if (err instanceof InheritError) {
        err.filename = filename;
        throw err;
      }
      if (err instanceof SchemaValidationError) {
        throw err;
      }
      if (!filename) {
        throw err;
      }
      throw new UserError(`Failed to load element metadata from "${filename}"`, ensureError(err));
    }
  }
  /**
   * Get [[MetaElement]] for the given tag. If no specific metadata is present
   * the global metadata is returned or null if no global is present.
   *
   * @public
   * @returns A shallow copy of metadata.
   */
  getMetaFor(tagName) {
    const meta = this.elements[tagName.toLowerCase()] ?? this.elements["*"];
    if (meta) {
      return { ...meta };
    } else {
      return null;
    }
  }
  /**
   * Find all tags which has enabled given property.
   *
   * @public
   */
  getTagsWithProperty(propName) {
    return this.entries.filter(([, entry]) => entry[propName]).map(([tagName]) => tagName);
  }
  /**
   * Find tag matching tagName or inheriting from it.
   *
   * @public
   */
  getTagsDerivedFrom(tagName) {
    return this.entries.filter(([key, entry]) => key === tagName || entry.inherit === tagName).map(([tagName2]) => tagName2);
  }
  addEntry(tagName, entry) {
    let parent2 = this.elements[tagName];
    if (entry.inherit) {
      const name = entry.inherit;
      parent2 = this.elements[name];
      if (!parent2) {
        throw new InheritError({
          tagName,
          inherit: name
        });
      }
    }
    const expanded = this.mergeElement(parent2 ?? {}, { ...entry, tagName });
    expandRegex(expanded);
    this.elements[tagName] = expanded;
  }
  /**
   * Construct a new AJV schema validator.
   */
  getSchemaValidator() {
    const hash = computeHash(JSON.stringify(this.schema));
    const cached = schemaCache.get(hash);
    if (cached) {
      return cached;
    } else {
      const ajv2 = new import_ajv.default({ strict: true, strictTuples: true, strictTypes: true });
      ajv2.addMetaSchema(ajvSchemaDraft);
      ajv2.addKeyword(ajvFunctionKeyword);
      ajv2.addKeyword(ajvRegexpKeyword);
      ajv2.addKeyword({ keyword: "copyable" });
      const validate = ajv2.compile(this.schema);
      schemaCache.set(hash, validate);
      return validate;
    }
  }
  /**
   * @public
   */
  getJSONSchema() {
    return this.schema;
  }
  /**
   * @internal
   */
  get entries() {
    return Object.entries(this.elements);
  }
  /**
   * Finds the global element definition and merges each known element with the
   * global, e.g. to assign global attributes.
   */
  resolveGlobal() {
    if (!this.elements["*"]) return;
    const global = this.elements["*"];
    delete this.elements["*"];
    delete global.tagName;
    delete global.void;
    for (const [tagName, entry] of this.entries) {
      this.elements[tagName] = this.mergeElement(global, entry);
    }
  }
  mergeElement(a, b) {
    const merged = deepmerge(a, b, { arrayMerge: overwriteMerge$1 });
    const filteredAttrs = Object.entries(
      merged.attributes
    ).filter(([, attr]) => {
      const val = !attr.delete;
      delete attr.delete;
      return val;
    });
    merged.attributes = Object.fromEntries(filteredAttrs);
    return merged;
  }
  /**
   * @internal
   */
  resolve(node) {
    if (node.meta) {
      expandProperties(node, node.meta);
    }
  }
};
function expandProperties(node, entry) {
  for (const key of dynamicKeys) {
    const property = entry[key];
    if (typeof property === "function") {
      setMetaProperty(entry, key, property(node._adapter));
    }
  }
  if (typeof entry.focusable === "function") {
    setMetaProperty(entry, "focusable", entry.focusable(node._adapter));
  }
}
function expandRegexValue(value) {
  if (value instanceof RegExp) {
    return value;
  }
  const match2 = /^\/(.*(?=\/))\/(i?)$/.exec(value);
  if (match2) {
    const [, expr, flags] = match2;
    if (expr.startsWith("^") || expr.endsWith("$")) {
      return new RegExp(expr, flags);
    } else {
      return new RegExp(`^${expr}$`, flags);
    }
  } else {
    return value;
  }
}
function expandRegex(entry) {
  for (const [name, values] of Object.entries(entry.attributes)) {
    if (values.enum) {
      entry.attributes[name].enum = values.enum.map(expandRegexValue);
    }
  }
}
var DynamicValue = class {
  expr;
  constructor(expr) {
    this.expr = expr;
  }
  toString() {
    return this.expr;
  }
};
function isStaticAttribute(attr) {
  return Boolean(attr?.isStatic);
}
function isDynamicAttribute(attr) {
  return Boolean(attr?.isDynamic);
}
var Attribute = class {
  /** Attribute name */
  key;
  value;
  keyLocation;
  valueLocation;
  originalAttribute;
  /**
   * @param key - Attribute name.
   * @param value - Attribute value. Set to `null` for boolean attributes.
   * @param keyLocation - Source location of attribute name.
   * @param valueLocation - Source location of attribute value.
   * @param originalAttribute - If this attribute was dynamically added via a
   * transformation (e.g. vuejs `:id` generating the `id` attribute) this
   * parameter should be set to the attribute name of the source attribute (`:id`).
   */
  constructor(key, value, keyLocation, valueLocation, originalAttribute) {
    this.key = key;
    this.value = value;
    this.keyLocation = keyLocation;
    this.valueLocation = valueLocation;
    this.originalAttribute = originalAttribute;
    if (typeof this.value === "undefined") {
      this.value = null;
    }
  }
  /**
   * Flag set to true if the attribute value is static.
   */
  get isStatic() {
    return !this.isDynamic;
  }
  /**
   * Flag set to true if the attribute value is dynamic.
   */
  get isDynamic() {
    return this.value instanceof DynamicValue;
  }
  /**
   * Test attribute value.
   *
   * @param pattern - Pattern to match value against. Can be a RegExp, literal
   * string or an array of strings (returns true if any value matches the
   * array).
   * @param dynamicMatches - If true `DynamicValue` will always match, if false
   * it never matches.
   * @returns `true` if attribute value matches pattern.
   */
  valueMatches(pattern, dynamicMatches = true) {
    if (this.value === null) {
      return false;
    }
    if (this.value instanceof DynamicValue) {
      return dynamicMatches;
    }
    if (Array.isArray(pattern)) {
      return pattern.includes(this.value);
    }
    if (pattern instanceof RegExp) {
      return this.value.match(pattern) !== null;
    } else {
      return this.value === pattern;
    }
  }
};
function getCSSDeclarations(value) {
  return value.trim().split(";").filter(Boolean).map((it) => {
    const [property, value2] = it.split(":", 2);
    return [property.trim(), value2 ? value2.trim() : ""];
  });
}
function parseCssDeclaration(value) {
  if (!value || value instanceof DynamicValue) {
    return {};
  }
  const pairs = getCSSDeclarations(value);
  return Object.fromEntries(pairs);
}
function sliceSize(size, begin, end) {
  if (typeof size !== "number") {
    return size;
  }
  if (typeof end !== "number") {
    return size - begin;
  }
  if (end < 0) {
    end = size + end;
  }
  return Math.min(size, end - begin);
}
function sliceLocation(location, begin, end, wrap2) {
  if (!location) return null;
  const size = sliceSize(location.size, begin, end);
  const sliced = {
    filename: location.filename,
    offset: location.offset + begin,
    line: location.line,
    column: location.column + begin,
    size
  };
  if (wrap2) {
    let index = -1;
    const col = sliced.column;
    do {
      index = wrap2.indexOf("\n", index + 1);
      if (index >= 0 && index < begin) {
        sliced.column = col - (index + 1);
        sliced.line++;
      } else {
        break;
      }
    } while (true);
  }
  return sliced;
}
var State = /* @__PURE__ */ ((State2) => {
  State2[State2["INITIAL"] = 1] = "INITIAL";
  State2[State2["DOCTYPE"] = 2] = "DOCTYPE";
  State2[State2["TEXT"] = 3] = "TEXT";
  State2[State2["TAG"] = 4] = "TAG";
  State2[State2["ATTR"] = 5] = "ATTR";
  State2[State2["CDATA"] = 6] = "CDATA";
  State2[State2["SCRIPT"] = 7] = "SCRIPT";
  State2[State2["STYLE"] = 8] = "STYLE";
  return State2;
})(State || {});
var ContentModel = /* @__PURE__ */ ((ContentModel2) => {
  ContentModel2[ContentModel2["TEXT"] = 1] = "TEXT";
  ContentModel2[ContentModel2["SCRIPT"] = 2] = "SCRIPT";
  ContentModel2[ContentModel2["STYLE"] = 3] = "STYLE";
  return ContentModel2;
})(ContentModel || {});
var Context = class {
  contentModel;
  state;
  string;
  filename;
  offset;
  line;
  column;
  constructor(source) {
    this.state = State.INITIAL;
    this.string = source.data;
    this.filename = source.filename;
    this.offset = source.offset;
    this.line = source.line;
    this.column = source.column;
    this.contentModel = 1;
  }
  getTruncatedLine(n = 13) {
    return JSON.stringify(this.string.length > n ? `${this.string.slice(0, 10)}...` : this.string);
  }
  consume(n, state) {
    let consumed = this.string.slice(0, n);
    let offset;
    while ((offset = consumed.indexOf("\n")) >= 0) {
      this.line++;
      this.column = 1;
      consumed = consumed.substr(offset + 1);
    }
    this.column += consumed.length;
    this.offset += n;
    this.string = this.string.substr(n);
    this.state = state;
  }
  getLocation(size) {
    return {
      filename: this.filename,
      offset: this.offset,
      line: this.line,
      column: this.column,
      size
    };
  }
};
function normalizeSource(source) {
  return {
    filename: "",
    offset: 0,
    line: 1,
    column: 1,
    ...source
  };
}
var NodeType = /* @__PURE__ */ ((NodeType2) => {
  NodeType2[NodeType2["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
  NodeType2[NodeType2["TEXT_NODE"] = 3] = "TEXT_NODE";
  NodeType2[NodeType2["DOCUMENT_NODE"] = 9] = "DOCUMENT_NODE";
  return NodeType2;
})(NodeType || {});
var DOCUMENT_NODE_NAME = "#document";
var TEXT_CONTENT = Symbol("textContent");
var counter = 0;
var DOMNode = class {
  nodeName;
  nodeType;
  childNodes;
  location;
  /**
   * @internal
   */
  unique;
  /* eslint-disable-next-line sonarjs/use-type-alias -- technical debt */
  cache;
  /**
   * Set of disabled rules for this node.
   *
   * Rules disabled by using directives are added here.
   */
  disabledRules;
  /**
   * Set of blocked rules for this node.
   *
   * Rules blocked by using directives are added here.
   */
  blockedRules;
  /**
   * Create a new DOMNode.
   *
   * @internal
   * @param nodeType - What node type to create.
   * @param nodeName - What node name to use. For `HtmlElement` this corresponds
   * to the tagName but other node types have specific predefined values.
   * @param location - Source code location of this node.
   */
  constructor(nodeType, nodeName, location) {
    this.nodeType = nodeType;
    this.nodeName = nodeName ?? DOCUMENT_NODE_NAME;
    this.location = location;
    this.disabledRules = /* @__PURE__ */ new Set();
    this.blockedRules = /* @__PURE__ */ new Map();
    this.childNodes = [];
    this.unique = counter++;
    this.cache = null;
  }
  /**
   * Enable cache for this node.
   *
   * Should not be called before the node and all children are fully constructed.
   *
   * @internal
   */
  cacheEnable() {
    this.cache = /* @__PURE__ */ new Map();
  }
  cacheGet(key) {
    if (this.cache) {
      return this.cache.get(key);
    } else {
      return void 0;
    }
  }
  cacheSet(key, value) {
    if (this.cache) {
      this.cache.set(key, value);
    }
    return value;
  }
  /**
   * Remove a value by key from cache.
   *
   * @returns `true` if the entry existed and has been removed.
   */
  cacheRemove(key) {
    if (this.cache) {
      return this.cache.delete(key);
    } else {
      return false;
    }
  }
  /**
   * Check if key exists in cache.
   */
  cacheExists(key) {
    return Boolean(this.cache?.has(key));
  }
  /**
   * Get the text (recursive) from all child nodes.
   */
  get textContent() {
    const cached = this.cacheGet(TEXT_CONTENT);
    if (cached) {
      return cached;
    }
    const text = this.childNodes.map((node) => node.textContent).join("");
    this.cacheSet(TEXT_CONTENT, text);
    return text;
  }
  append(node) {
    const oldParent = node._setParent(this);
    if (oldParent && this.isSameNode(oldParent)) {
      return;
    }
    this.childNodes.push(node);
    if (oldParent) {
      oldParent._removeChild(node);
    }
  }
  /**
   * Insert a node before a reference node.
   *
   * @internal
   */
  insertBefore(node, reference) {
    const index = reference ? this.childNodes.findIndex((it) => it.isSameNode(reference)) : -1;
    if (index >= 0) {
      this.childNodes.splice(index, 0, node);
    } else {
      this.childNodes.push(node);
    }
    const oldParent = node._setParent(this);
    if (oldParent) {
      oldParent._removeChild(node);
    }
  }
  isRootElement() {
    return this.nodeType === NodeType.DOCUMENT_NODE;
  }
  /**
   * Tests if two nodes are the same (references the same object).
   *
   * @since v4.11.0
   */
  isSameNode(otherNode) {
    return this.unique === otherNode.unique;
  }
  /**
   * Returns a DOMNode representing the first direct child node or `null` if the
   * node has no children.
   */
  get firstChild() {
    return this.childNodes[0] || null;
  }
  /**
   * Returns a DOMNode representing the last direct child node or `null` if the
   * node has no children.
   */
  get lastChild() {
    return this.childNodes[this.childNodes.length - 1] || null;
  }
  /**
   * @internal
   */
  removeChild(node) {
    this._removeChild(node);
    node._setParent(null);
    return node;
  }
  /**
   * Block a rule for this node.
   *
   * @internal
   */
  blockRule(ruleId, blocker) {
    const current = this.blockedRules.get(ruleId);
    if (current) {
      current.push(blocker);
    } else {
      this.blockedRules.set(ruleId, [blocker]);
    }
  }
  /**
   * Blocks multiple rules.
   *
   * @internal
   */
  blockRules(rules, blocker) {
    for (const rule of rules) {
      this.blockRule(rule, blocker);
    }
  }
  /**
   * Disable a rule for this node.
   *
   * @internal
   */
  disableRule(ruleId) {
    this.disabledRules.add(ruleId);
  }
  /**
   * Disables multiple rules.
   *
   * @internal
   */
  disableRules(rules) {
    for (const rule of rules) {
      this.disableRule(rule);
    }
  }
  /**
   * Enable a previously disabled rule for this node.
   */
  enableRule(ruleId) {
    this.disabledRules.delete(ruleId);
  }
  /**
   * Enables multiple rules.
   */
  enableRules(rules) {
    for (const rule of rules) {
      this.enableRule(rule);
    }
  }
  /**
   * Test if a rule is enabled for this node.
   *
   * @internal
   */
  ruleEnabled(ruleId) {
    return !this.disabledRules.has(ruleId);
  }
  /**
   * Test if a rule is blocked for this node.
   *
   * @internal
   */
  ruleBlockers(ruleId) {
    return this.blockedRules.get(ruleId) ?? [];
  }
  generateSelector() {
    return null;
  }
  /**
   * @internal
   *
   * @returns Old parent, if set.
   */
  _setParent(_node) {
    return null;
  }
  _removeChild(node) {
    const index = this.childNodes.findIndex((it) => it.isSameNode(node));
    if (index >= 0) {
      this.childNodes.splice(index, 1);
    } else {
      throw new Error("DOMException: _removeChild(..) could not find child to remove");
    }
  }
};
function parse2(text, baseLocation) {
  const tokens = [];
  const locations = baseLocation ? [] : null;
  for (let begin = 0; begin < text.length; ) {
    let end = text.indexOf(" ", begin);
    if (end === -1) {
      end = text.length;
    }
    const size = end - begin;
    if (size === 0) {
      begin++;
      continue;
    }
    const token = text.substring(begin, end);
    tokens.push(token);
    if (locations && baseLocation) {
      const location = sliceLocation(baseLocation, begin, end);
      locations.push(location);
    }
    begin += size + 1;
  }
  return { tokens, locations };
}
var DOMTokenList = class extends Array {
  value;
  locations;
  constructor(value, location) {
    if (value && typeof value === "string") {
      const normalized = value.replace(/[\t\r\n]/g, " ");
      const { tokens, locations } = parse2(normalized, location);
      super(...tokens);
      this.locations = locations;
    } else {
      super(0);
      this.locations = null;
    }
    if (value instanceof DynamicValue) {
      this.value = value.expr;
    } else {
      this.value = value ?? "";
    }
  }
  item(n) {
    return this[n];
  }
  location(n) {
    if (this.locations) {
      return this.locations[n];
    } else {
      throw new Error("Trying to access DOMTokenList location when base location isn't set");
    }
  }
  contains(token) {
    return this.includes(token);
  }
  *iterator() {
    for (let index = 0; index < this.length; index++) {
      const item = this.item(index);
      const location = this.location(index);
      yield { index, item, location };
    }
  }
};
var Combinator = /* @__PURE__ */ ((Combinator2) => {
  Combinator2[Combinator2["DESCENDANT"] = 1] = "DESCENDANT";
  Combinator2[Combinator2["CHILD"] = 2] = "CHILD";
  Combinator2[Combinator2["ADJACENT_SIBLING"] = 3] = "ADJACENT_SIBLING";
  Combinator2[Combinator2["GENERAL_SIBLING"] = 4] = "GENERAL_SIBLING";
  Combinator2[Combinator2["SCOPE"] = 5] = "SCOPE";
  return Combinator2;
})(Combinator || {});
function parseCombinator(combinator, pattern) {
  if (pattern === ":scope") {
    return 5;
  }
  switch (combinator) {
    case void 0:
    case null:
    case "":
      return 1;
    case ">":
      return 2;
    case "+":
      return 3;
    case "~":
      return 4;
    default:
      throw new Error(`Unknown combinator "${combinator}"`);
  }
}
function firstChild(node) {
  return node.previousSibling === null;
}
function lastChild(node) {
  return node.nextSibling === null;
}
var cache = {};
function getNthChild(node) {
  if (!node.parent) {
    return -1;
  }
  if (!cache[node.unique]) {
    const parent2 = node.parent;
    const index = parent2.childElements.findIndex((cur) => {
      return cur.unique === node.unique;
    });
    cache[node.unique] = index + 1;
  }
  return cache[node.unique];
}
function nthChild(node, args) {
  if (!args) {
    throw new Error("Missing argument to nth-child");
  }
  const n = parseInt(args.trim(), 10);
  const cur = getNthChild(node);
  return cur === n;
}
function scope$1(node) {
  return Boolean(this.scope && node.isSameNode(this.scope));
}
var table = {
  "first-child": firstChild,
  "last-child": lastChild,
  "nth-child": nthChild,
  scope: scope$1
};
function factory(name, context) {
  const fn = table[name];
  if (fn) {
    return fn.bind(context);
  } else {
    throw new Error(`Pseudo-class "${name}" is not implemented`);
  }
}
function stripslashes(value) {
  return value.replace(/\\(.)/g, "$1");
}
var Condition = class {
};
var ClassCondition = class extends Condition {
  classname;
  constructor(classname) {
    super();
    this.classname = classname;
  }
  match(node) {
    return node.classList.contains(this.classname);
  }
};
var IdCondition = class extends Condition {
  id;
  constructor(id) {
    super();
    this.id = stripslashes(id);
  }
  match(node) {
    return node.id === this.id;
  }
};
var AttributeCondition = class extends Condition {
  key;
  op;
  value;
  constructor(attr) {
    super();
    const [, key, op, value] = /^(.+?)(?:([~^$*|]?=)"([^"]+?)")?$/.exec(attr);
    this.key = key;
    this.op = op;
    this.value = typeof value === "string" ? stripslashes(value) : value;
  }
  match(node) {
    const attr = node.getAttribute(this.key, true);
    return attr.some((cur) => {
      switch (this.op) {
        case void 0:
          return true;
        /* attribute exists */
        case "=":
          return cur.value === this.value;
        default:
          throw new Error(`Attribute selector operator ${this.op} is not implemented yet`);
      }
    });
  }
};
var PseudoClassCondition = class extends Condition {
  name;
  args;
  constructor(pseudoclass, context) {
    super();
    const match2 = /^([^(]+)(?:\((.*)\))?$/.exec(pseudoclass);
    if (!match2) {
      throw new Error(`Missing pseudo-class after colon in selector pattern "${context}"`);
    }
    const [, name, args] = match2;
    this.name = name;
    this.args = args;
  }
  match(node, context) {
    const fn = factory(this.name, context);
    return fn(node, this.args);
  }
};
function isDelimiter(ch) {
  return /[.#[:]/.test(ch);
}
function isQuotationMark(ch) {
  return /['"]/.test(ch);
}
function isPseudoElement(ch, buffer) {
  return ch === ":" && buffer === ":";
}
function* splitCompound(pattern) {
  if (pattern === "") {
    return;
  }
  const end = pattern.length;
  let begin = 0;
  let cur = 1;
  let quoted = false;
  while (cur < end) {
    const ch = pattern[cur];
    const buffer = pattern.slice(begin, cur);
    if (ch === "\\") {
      cur += 2;
      continue;
    }
    if (quoted) {
      if (ch === quoted) {
        quoted = false;
      }
      cur += 1;
      continue;
    }
    if (isQuotationMark(ch)) {
      quoted = ch;
      cur += 1;
      continue;
    }
    if (isPseudoElement(ch, buffer)) {
      cur += 1;
      continue;
    }
    if (isDelimiter(ch)) {
      begin = cur;
      yield buffer;
    }
    cur += 1;
  }
  const tail = pattern.slice(begin, cur);
  yield tail;
}
var Compound = class {
  combinator;
  tagName;
  selector;
  conditions;
  constructor(pattern) {
    const match2 = /^([~+\->]?)((?:[*]|[^.#[:]+)?)([^]*)$/.exec(pattern);
    if (!match2) {
      throw new Error(`Failed to create selector pattern from "${pattern}"`);
    }
    match2.shift();
    this.selector = pattern;
    this.combinator = parseCombinator(match2.shift(), pattern);
    this.tagName = match2.shift() || "*";
    this.conditions = Array.from(splitCompound(match2[0]), (it) => this.createCondition(it));
  }
  match(node, context) {
    return node.is(this.tagName) && this.conditions.every((cur) => cur.match(node, context));
  }
  createCondition(pattern) {
    switch (pattern[0]) {
      case ".":
        return new ClassCondition(pattern.slice(1));
      case "#":
        return new IdCondition(pattern.slice(1));
      case "[":
        return new AttributeCondition(pattern.slice(1, -1));
      case ":":
        return new PseudoClassCondition(pattern.slice(1), this.selector);
      default:
        throw new Error(`Failed to create selector condition for "${pattern}"`);
    }
  }
};
function* ancestors$1(element) {
  let current = element.parent;
  while (current && !current.isRootElement()) {
    yield current;
    current = current.parent;
  }
}
function* parent(element) {
  const parent2 = element.parent;
  if (parent2 && !parent2.isRootElement()) {
    yield parent2;
  }
}
function* adjacentSibling(element) {
  const sibling = element.previousSibling;
  if (sibling) {
    yield sibling;
  }
}
function* generalSibling(element) {
  const siblings = element.siblings;
  const index = siblings.findIndex((it) => it.isSameNode(element));
  for (let i = 0; i < index; i++) {
    yield siblings[i];
  }
}
function* scope(element) {
  yield element;
}
function candidatesFromCombinator(element, combinator) {
  switch (combinator) {
    case Combinator.DESCENDANT:
      return ancestors$1(element);
    case Combinator.CHILD:
      return parent(element);
    case Combinator.ADJACENT_SIBLING:
      return adjacentSibling(element);
    case Combinator.GENERAL_SIBLING:
      return generalSibling(element);
    /* istanbul ignore next -- cannot really happen, the selector would be malformed */
    case Combinator.SCOPE:
      return scope(element);
  }
}
function matchElement(element, compounds, context) {
  const last = compounds[compounds.length - 1];
  if (!last.match(element, context)) {
    return false;
  }
  const remainder = compounds.slice(0, -1);
  if (remainder.length === 0) {
    return true;
  }
  const candidates = candidatesFromCombinator(element, last.combinator);
  for (const candidate of candidates) {
    if (matchElement(candidate, remainder, context)) {
      return true;
    }
  }
  return false;
}
var escapedCodepoints = ["9", "a", "d"];
function* splitSelectorElements(selector2) {
  let begin = 0;
  let end = 0;
  function initialState(ch, p) {
    if (ch === "\\") {
      return 1;
    }
    if (ch === " ") {
      end = p;
      return 2;
    }
    return 0;
  }
  function escapedState(ch) {
    if (escapedCodepoints.includes(ch)) {
      return 1;
    }
    return 0;
  }
  function* whitespaceState(ch, p) {
    if (ch === " ") {
      return 2;
    }
    yield selector2.slice(begin, end);
    begin = p;
    end = p;
    return 0;
  }
  let state = 0;
  for (let p = 0; p < selector2.length; p++) {
    const ch = selector2[p];
    switch (state) {
      case 0:
        state = initialState(ch, p);
        break;
      case 1:
        state = escapedState(ch);
        break;
      case 2:
        state = yield* whitespaceState(ch, p);
        break;
    }
  }
  if (begin !== selector2.length) {
    yield selector2.slice(begin);
  }
}
function unescapeCodepoint(value) {
  const replacement2 = {
    "\\9 ": "	",
    "\\a ": "\n",
    "\\d ": "\r"
  };
  return value.replace(
    /(\\[\u0039\u0061\u0064] )/g,
    (_, codepoint) => replacement2[codepoint]
  );
}
function escapeSelectorComponent(text) {
  const codepoints = {
    "	": "\\9 ",
    "\n": "\\a ",
    "\r": "\\d "
  };
  return text.toString().replace(/([\t\n\r]|[^a-z0-9_-])/gi, (_, ch) => {
    if (codepoints[ch]) {
      return codepoints[ch];
    } else {
      return `\\${ch}`;
    }
  });
}
function generateIdSelector(id) {
  const escaped = escapeSelectorComponent(id);
  return /^\d/.exec(escaped) ? `[id="${escaped}"]` : `#${escaped}`;
}
var Selector = class _Selector {
  pattern;
  constructor(selector2) {
    this.pattern = _Selector.parse(selector2);
  }
  /**
   * Match this selector against a HtmlElement.
   *
   * @param root - Element to match against.
   * @returns Iterator with matched elements.
   */
  *match(root) {
    const context = { scope: root };
    yield* this.matchInternal(root, 0, context);
  }
  /**
   * Returns `true` if the element matches this selector.
   */
  matchElement(element) {
    const context = { scope: null };
    return matchElement(element, this.pattern, context);
  }
  *matchInternal(root, level, context) {
    if (level >= this.pattern.length) {
      yield root;
      return;
    }
    const pattern = this.pattern[level];
    const matches = _Selector.findCandidates(root, pattern);
    for (const node of matches) {
      if (!pattern.match(node, context)) {
        continue;
      }
      yield* this.matchInternal(node, level + 1, context);
    }
  }
  static parse(selector2) {
    selector2 = selector2.replace(/([+~>]) /g, "$1");
    return Array.from(splitSelectorElements(selector2), (element) => {
      return new Compound(unescapeCodepoint(element));
    });
  }
  static findCandidates(root, pattern) {
    switch (pattern.combinator) {
      case Combinator.DESCENDANT:
        return root.getElementsByTagName(pattern.tagName);
      case Combinator.CHILD:
        return root.childElements.filter((node) => node.is(pattern.tagName));
      case Combinator.ADJACENT_SIBLING:
        return _Selector.findAdjacentSibling(root);
      case Combinator.GENERAL_SIBLING:
        return _Selector.findGeneralSibling(root);
      case Combinator.SCOPE:
        return [root];
    }
  }
  static findAdjacentSibling(node) {
    let adjacent = false;
    return node.siblings.filter((cur) => {
      if (adjacent) {
        adjacent = false;
        return true;
      }
      if (cur === node) {
        adjacent = true;
      }
      return false;
    });
  }
  static findGeneralSibling(node) {
    let after = false;
    return node.siblings.filter((cur) => {
      if (after) {
        return true;
      }
      if (cur === node) {
        after = true;
      }
      return false;
    });
  }
};
var TEXT_NODE_NAME = "#text";
function isTextNode(node) {
  return Boolean(node && node.nodeType === NodeType.TEXT_NODE);
}
var TextNode = class extends DOMNode {
  text;
  /**
   * @param text - Text to add. When a `DynamicValue` is used the expression is
   * used as "text".
   * @param location - Source code location of this node.
   */
  constructor(text, location) {
    super(NodeType.TEXT_NODE, TEXT_NODE_NAME, location);
    this.text = text;
  }
  /**
   * Get the text from node.
   */
  get textContent() {
    return this.text.toString();
  }
  /**
   * Flag set to true if the attribute value is static.
   */
  get isStatic() {
    return !this.isDynamic;
  }
  /**
   * Flag set to true if the attribute value is dynamic.
   */
  get isDynamic() {
    return this.text instanceof DynamicValue;
  }
};
var ROLE = Symbol("role");
var TABINDEX = Symbol("tabindex");
var NodeClosed = /* @__PURE__ */ ((NodeClosed2) => {
  NodeClosed2[NodeClosed2["Open"] = 0] = "Open";
  NodeClosed2[NodeClosed2["EndTag"] = 1] = "EndTag";
  NodeClosed2[NodeClosed2["VoidOmitted"] = 2] = "VoidOmitted";
  NodeClosed2[NodeClosed2["VoidSelfClosed"] = 3] = "VoidSelfClosed";
  NodeClosed2[NodeClosed2["ImplicitClosed"] = 4] = "ImplicitClosed";
  return NodeClosed2;
})(NodeClosed || {});
function isElementNode(node) {
  return Boolean(node && node.nodeType === NodeType.ELEMENT_NODE);
}
function isInvalidTagName(tagName) {
  return tagName === "" || tagName === "*";
}
function createAdapter(node) {
  return {
    closest(selectors2) {
      return node.closest(selectors2)?._adapter;
    },
    getAttribute(name) {
      return node.getAttribute(name)?.value;
    },
    hasAttribute(name) {
      return node.hasAttribute(name);
    }
  };
}
var HtmlElement = class _HtmlElement extends DOMNode {
  tagName;
  voidElement;
  depth;
  closed;
  attr;
  metaElement;
  annotation;
  _parent;
  /** @internal */
  _adapter;
  constructor(details) {
    const {
      nodeType,
      tagName,
      parent: parent2 = null,
      closed = 1,
      meta = null,
      location
    } = details;
    super(nodeType, tagName, location);
    if (isInvalidTagName(tagName)) {
      throw new Error(`The tag name provided ("${tagName}") is not a valid name`);
    }
    this.tagName = tagName ?? "#document";
    this._parent = null;
    this.attr = {};
    this.metaElement = meta ?? null;
    this.closed = closed;
    this.voidElement = meta ? Boolean(meta.void) : false;
    this.depth = 0;
    this.annotation = null;
    this._adapter = createAdapter(this);
    if (parent2) {
      parent2.append(this);
      let cur = parent2;
      while (cur.parent) {
        this.depth++;
        cur = cur.parent;
      }
    }
  }
  /**
   * Manually create a new element. This is primary useful for test-cases. While
   * the API is public it is not meant for general consumption and is not
   * guaranteed to be stable across versions.
   *
   * Use at your own risk. Prefer to use [[Parser]] to parse a string of markup
   * instead.
   *
   * @public
   * @since 8.22.0
   * @param tagName - Element tagname.
   * @param location - Element location.
   * @param details - Additional element details.
   */
  static createElement(tagName, location, details = {}) {
    const { closed = 1, meta = null, parent: parent2 = null } = details;
    return new _HtmlElement({
      nodeType: NodeType.ELEMENT_NODE,
      tagName,
      parent: parent2,
      closed,
      meta,
      location
    });
  }
  /**
   * @internal
   */
  static rootNode(location) {
    const root = new _HtmlElement({
      nodeType: NodeType.DOCUMENT_NODE,
      location
    });
    root.setAnnotation("#document");
    return root;
  }
  /**
   * @internal
   *
   * @param namespace - If given it is appended to the tagName.
   */
  static fromTokens(startToken, endToken, parent2, metaTable, namespace = "") {
    const name = startToken.data[2];
    const tagName = namespace ? `${namespace}:${name}` : name;
    if (!name) {
      throw new Error("tagName cannot be empty");
    }
    const meta = metaTable ? metaTable.getMetaFor(tagName) : null;
    const open = startToken.data[1] !== "/";
    const closed = isClosed(endToken, meta);
    const location = sliceLocation(startToken.location, 1);
    return new _HtmlElement({
      nodeType: NodeType.ELEMENT_NODE,
      tagName,
      parent: open ? parent2 : null,
      closed,
      meta,
      location
    });
  }
  /**
   * Returns annotated name if set or defaults to `<tagName>`.
   *
   * E.g. `my-annotation` or `<div>`.
   */
  get annotatedName() {
    if (this.annotation) {
      return this.annotation;
    } else {
      return `<${this.tagName}>`;
    }
  }
  /**
   * Get list of IDs referenced by `aria-labelledby`.
   *
   * If the attribute is unset or empty this getter returns null.
   * If the attribute is dynamic the original {@link DynamicValue} is returned.
   *
   * @public
   */
  get ariaLabelledby() {
    const attr = this.getAttribute("aria-labelledby");
    if (!attr?.value) {
      return null;
    }
    if (attr.value instanceof DynamicValue) {
      return attr.value;
    }
    const list = new DOMTokenList(attr.value, attr.valueLocation);
    return list.length ? Array.from(list) : null;
  }
  /**
   * Similar to childNodes but only elements.
   */
  get childElements() {
    return this.childNodes.filter(isElementNode);
  }
  /**
   * Find the first ancestor matching a selector.
   *
   * Implementation of DOM specification of Element.closest(selectors).
   */
  closest(selectors2) {
    let node = this;
    while (node) {
      if (node.matches(selectors2)) {
        return node;
      }
      node = node.parent;
    }
    return null;
  }
  /**
   * Generate a DOM selector for this element. The returned selector will be
   * unique inside the current document.
   */
  generateSelector() {
    if (this.isRootElement()) {
      return null;
    }
    const parts = [];
    let root;
    for (root = this; root.parent; root = root.parent) {
    }
    for (let cur = this; cur.parent; cur = cur.parent) {
      if (cur.id) {
        const selector2 = generateIdSelector(cur.id);
        const matches = root.querySelectorAll(selector2);
        if (matches.length === 1) {
          parts.push(selector2);
          break;
        }
      }
      const parent2 = cur.parent;
      const child = parent2.childElements;
      const index = child.findIndex((it) => it.unique === cur.unique);
      const numOfType = child.filter((it) => it.is(cur.tagName)).length;
      const solo = numOfType === 1;
      if (solo) {
        parts.push(cur.tagName.toLowerCase());
        continue;
      }
      parts.push(`${cur.tagName.toLowerCase()}:nth-child(${String(index + 1)})`);
    }
    return parts.reverse().join(" > ");
  }
  /**
   * Tests if this element has given tagname.
   *
   * If passing "*" this test will pass if any tagname is set.
   */
  is(tagName) {
    return tagName === "*" || this.tagName.toLowerCase() === tagName.toLowerCase();
  }
  /**
   * Load new element metadata onto this element.
   *
   * Do note that semantics such as `void` cannot be changed (as the element has
   * already been created). In addition the element will still "be" the same
   * element, i.e. even if loading meta for a `<p>` tag upon a `<div>` tag it
   * will still be a `<div>` as far as the rest of the validator is concerned.
   *
   * In fact only certain properties will be copied onto the element:
   *
   * - content categories (flow, phrasing, etc)
   * - required attributes
   * - attribute allowed values
   * - permitted/required elements
   *
   * Properties *not* loaded:
   *
   * - inherit
   * - deprecated
   * - foreign
   * - void
   * - implicitClosed
   * - scriptSupporting
   * - deprecatedAttributes
   *
   * Changes to element metadata will only be visible after `element:ready` (and
   * the subsequent `dom:ready` event).
   */
  loadMeta(meta) {
    this.metaElement ??= {};
    for (const key of MetaCopyableProperty) {
      const value = meta[key];
      if (typeof value !== "undefined") {
        setMetaProperty(this.metaElement, key, value);
      } else {
        delete this.metaElement[key];
      }
    }
  }
  /**
   * Match this element against given selectors. Returns true if any selector
   * matches.
   *
   * Implementation of DOM specification of Element.matches(selectors).
   */
  matches(selectorList) {
    return selectorList.split(",").some((it) => {
      const selector2 = new Selector(it.trim());
      return selector2.matchElement(this);
    });
  }
  get meta() {
    return this.metaElement;
  }
  get parent() {
    return this._parent;
  }
  /**
   * Get current role for this element (explicit with `role` attribute or mapped
   * with implicit role).
   *
   * @since 8.9.1
   */
  get role() {
    const cached = this.cacheGet(ROLE);
    if (cached !== void 0) {
      return cached;
    }
    const role = this.getAttribute("role");
    if (role) {
      return this.cacheSet(ROLE, role.value);
    }
    if (this.metaElement) {
      const { aria } = this.metaElement;
      const implicitRole = aria.implicitRole(this._adapter);
      return this.cacheSet(ROLE, implicitRole);
    }
    return this.cacheSet(ROLE, null);
  }
  /**
   * Set annotation for this element.
   */
  setAnnotation(text) {
    this.annotation = text;
  }
  /**
   * Set attribute. Stores all attributes set even with the same name.
   *
   * @param key - Attribute name
   * @param value - Attribute value. Use `null` if no value is present.
   * @param keyLocation - Location of the attribute name.
   * @param valueLocation - Location of the attribute value (excluding quotation)
   * @param originalAttribute - If attribute is an alias for another attribute
   * (dynamic attributes) set this to the original attribute name.
   */
  setAttribute(key, value, keyLocation, valueLocation, originalAttribute) {
    key = key.toLowerCase();
    const attr = new Attribute(key, value, keyLocation, valueLocation, originalAttribute);
    const list = this.attr[key];
    if (list) {
      list.push(attr);
    } else {
      this.attr[key] = [attr];
    }
  }
  /**
   * Get parsed tabindex for this element.
   *
   * - If `tabindex` attribute is not present `null` is returned.
   * - If attribute value is omitted or the empty string `null` is returned.
   * - If attribute value cannot be parsed `null` is returned.
   * - If attribute value is dynamic `0` is returned.
   * - Otherwise the parsed value is returned.
   *
   * This property does *NOT* take into account if the element have a default
   * `tabindex` (such as `<input>` have). Instead use the `focusable` metadata
   * property to determine this.
   *
   * @public
   * @since 8.16.0
   */
  get tabIndex() {
    const cached = this.cacheGet(TABINDEX);
    if (cached !== void 0) {
      return cached;
    }
    const tabindex = this.getAttribute("tabindex");
    if (!tabindex) {
      return this.cacheSet(TABINDEX, null);
    }
    if (tabindex.value === null) {
      return this.cacheSet(TABINDEX, null);
    }
    if (tabindex.value instanceof DynamicValue) {
      return this.cacheSet(TABINDEX, 0);
    }
    const parsed = parseInt(tabindex.value, 10);
    if (isNaN(parsed)) {
      return this.cacheSet(TABINDEX, null);
    }
    return this.cacheSet(TABINDEX, parsed);
  }
  /**
   * Get a list of all attributes on this node.
   */
  get attributes() {
    return Object.values(this.attr).reduce((result, cur) => {
      return result.concat(cur);
    }, []);
  }
  hasAttribute(key) {
    key = key.toLowerCase();
    return key in this.attr;
  }
  getAttribute(key, all = false) {
    key = key.toLowerCase();
    if (key in this.attr) {
      const matches = this.attr[key];
      return all ? matches : matches[0];
    } else {
      return all ? [] : null;
    }
  }
  /**
   * Get attribute value.
   *
   * Returns the attribute value if present.
   *
   * - Missing attributes return `null`.
   * - Boolean attributes return `null`.
   * - `DynamicValue` returns attribute expression.
   *
   * @param key - Attribute name
   * @returns Attribute value or null.
   */
  getAttributeValue(key) {
    const attr = this.getAttribute(key);
    if (attr) {
      return attr.value !== null ? attr.value.toString() : null;
    } else {
      return null;
    }
  }
  /**
   * Add text as a child node to this element.
   *
   * @param text - Text to add.
   * @param location - Source code location of this text.
   */
  appendText(text, location) {
    this.childNodes.push(new TextNode(text, location));
  }
  /**
   * Return a list of all known classes on the element. Dynamic values are
   * ignored.
   */
  get classList() {
    if (!this.hasAttribute("class")) {
      return new DOMTokenList(null, null);
    }
    const classes = this.getAttribute("class", true).filter((attr) => attr.isStatic).map((attr) => attr.value).join(" ");
    return new DOMTokenList(classes, null);
  }
  /**
   * Get element ID if present.
   */
  get id() {
    return this.getAttributeValue("id");
  }
  get style() {
    const attr = this.getAttribute("style");
    return parseCssDeclaration(attr?.value);
  }
  /**
   * Returns the first child element or null if there are no child elements.
   */
  get firstElementChild() {
    const children = this.childElements;
    return children.length > 0 ? children[0] : null;
  }
  /**
   * Returns the last child element or null if there are no child elements.
   */
  get lastElementChild() {
    const children = this.childElements;
    return children.length > 0 ? children[children.length - 1] : null;
  }
  get siblings() {
    return this.parent ? this.parent.childElements : [this];
  }
  get previousSibling() {
    const i = this.siblings.findIndex((node) => node.unique === this.unique);
    return i >= 1 ? this.siblings[i - 1] : null;
  }
  get nextSibling() {
    const i = this.siblings.findIndex((node) => node.unique === this.unique);
    return i <= this.siblings.length - 2 ? this.siblings[i + 1] : null;
  }
  getElementsByTagName(tagName) {
    return this.childElements.reduce((matches, node) => {
      return matches.concat(node.is(tagName) ? [node] : [], node.getElementsByTagName(tagName));
    }, []);
  }
  querySelector(selector2) {
    const it = this.querySelectorImpl(selector2);
    const next = it.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  querySelectorAll(selector2) {
    const it = this.querySelectorImpl(selector2);
    const unique = new Set(it);
    return Array.from(unique.values());
  }
  *querySelectorImpl(selectorList) {
    if (!selectorList) {
      return;
    }
    for (const selector2 of selectorList.split(/(?<!\\),\s*/)) {
      const pattern = new Selector(selector2);
      yield* pattern.match(this);
    }
  }
  /**
   * Evaluates callbackk on all descendants, returning true if any are true.
   *
   * @internal
   */
  someChildren(callback) {
    return this.childElements.some(visit);
    function visit(node) {
      if (callback(node)) {
        return true;
      } else {
        return node.childElements.some(visit);
      }
    }
  }
  /**
   * Evaluates callbackk on all descendants, returning true if all are true.
   *
   * @internal
   */
  everyChildren(callback) {
    return this.childElements.every(visit);
    function visit(node) {
      if (!callback(node)) {
        return false;
      }
      return node.childElements.every(visit);
    }
  }
  /**
   * Visit all nodes from this node and down. Breadth first.
   *
   * The first node for which the callback evaluates to true is returned.
   *
   * @internal
   */
  find(callback) {
    function visit(node) {
      if (callback(node)) {
        return node;
      }
      for (const child of node.childElements) {
        const match2 = child.find(callback);
        if (match2) {
          return match2;
        }
      }
      return null;
    }
    return visit(this);
  }
  /**
   * @internal
   */
  _setParent(node) {
    const oldParent = this._parent;
    this._parent = node instanceof _HtmlElement ? node : null;
    return oldParent;
  }
};
function isClosed(endToken, meta) {
  let closed = 0;
  if (meta?.void) {
    closed = 2;
  }
  if (endToken.data[0] === "/>") {
    closed = 3;
  }
  return closed;
}
function isDOMTree(value) {
  return "root" in value && "readyState" in value;
}
function depthFirst(root, callback) {
  if (isDOMTree(root)) {
    if (root.readyState !== "complete") {
      throw new Error(`Cannot call walk.depthFirst(..) before document is ready`);
    }
    root = root.root;
  }
  function visit(node) {
    node.childElements.forEach(visit);
    if (!node.isRootElement()) {
      callback(node);
    }
  }
  visit(root);
}
var walk = {
  depthFirst
};
var DOMTree = class {
  root;
  active;
  _readyState;
  doctype;
  /**
   * @internal
   */
  constructor(location) {
    this.root = HtmlElement.rootNode(location);
    this.active = this.root;
    this.doctype = null;
    this._readyState = "loading";
  }
  /**
   * @internal
   */
  pushActive(node) {
    this.active = node;
  }
  /**
   * @internal
   */
  popActive() {
    if (this.active.isRootElement()) {
      return;
    }
    this.active = this.active.parent ?? this.root;
  }
  /**
   * @internal
   */
  getActive() {
    return this.active;
  }
  /**
   * Describes the loading state of the document.
   *
   * When `"loading"` it is still not safe to use functions such as
   * `querySelector` or presence of attributes, child nodes, etc.
   */
  get readyState() {
    return this._readyState;
  }
  /**
   * Resolve dynamic meta expressions.
   *
   * @internal
   */
  resolveMeta(table2) {
    this._readyState = "complete";
    walk.depthFirst(this, (node) => {
      table2.resolve(node);
    });
  }
  getElementsByTagName(tagName) {
    return this.root.getElementsByTagName(tagName);
  }
  /**
   * @deprecated use utility function `walk.depthFirst(..)` instead (since 8.21.0).
   */
  visitDepthFirst(callback) {
    walk.depthFirst(this, callback);
  }
  /**
   * @deprecated use `querySelector(..)` instead (since 8.21.0)
   */
  find(callback) {
    return this.root.find(callback);
  }
  querySelector(selector2) {
    return this.root.querySelector(selector2);
  }
  querySelectorAll(selector2) {
    return this.root.querySelectorAll(selector2);
  }
};
var allowedKeys = ["exclude"];
var Validator = class _Validator {
  /**
   * Test if element is used in a proper context.
   *
   * @param node - Element to test.
   * @param rules - List of rules.
   * @returns `true` if element passes all tests.
   */
  static validatePermitted(node, rules) {
    if (!rules) {
      return true;
    }
    return rules.some((rule) => {
      return _Validator.validatePermittedRule(node, rule);
    });
  }
  /**
   * Test if an element is used the correct amount of times.
   *
   * For instance, a `<table>` element can only contain a single `<tbody>`
   * child. If multiple `<tbody>` exists this test will fail both nodes.
   * Note that this is called on the parent but will fail the children violating
   * the rule.
   *
   * @param children - Array of children to validate.
   * @param rules - List of rules of the parent element.
   * @returns `true` if the parent element of the children passes the test.
   */
  static validateOccurrences(children, rules, cb) {
    if (!rules) {
      return true;
    }
    let valid = true;
    for (const rule of rules) {
      if (typeof rule !== "string") {
        return false;
      }
      const [, category, quantifier] = /^(@?.*?)([?*]?)$/.exec(rule);
      const limit = category && quantifier && parseQuantifier(quantifier);
      if (limit) {
        const siblings = children.filter(
          (cur) => _Validator.validatePermittedCategory(cur, rule, true)
        );
        if (siblings.length > limit) {
          for (const child of siblings.slice(limit)) {
            cb(child, category);
          }
          valid = false;
        }
      }
    }
    return valid;
  }
  /**
   * Validate elements order.
   *
   * Given a parent element with children and metadata containing permitted
   * order it will validate each children and ensure each one exists in the
   * specified order.
   *
   * For instance, for a `<table>` element the `<caption>` element must come
   * before a `<thead>` which must come before `<tbody>`.
   *
   * @param children - Array of children to validate.
   */
  static validateOrder(children, rules, cb) {
    if (!rules) {
      return true;
    }
    let i = 0;
    let prev = null;
    for (const node of children) {
      const old = i;
      while (rules[i] && !_Validator.validatePermittedCategory(node, rules[i], true)) {
        i++;
      }
      if (i >= rules.length) {
        const orderSpecified = rules.find(
          (cur) => _Validator.validatePermittedCategory(node, cur, true)
        );
        if (orderSpecified) {
          cb(node, prev);
          return false;
        }
        i = old;
      }
      prev = node;
    }
    return true;
  }
  /**
   * Validate element ancestors.
   *
   * Check if an element has the required set of elements. At least one of the
   * selectors must match.
   */
  static validateAncestors(node, rules) {
    if (!rules || rules.length === 0) {
      return true;
    }
    return rules.some((rule) => node.closest(rule));
  }
  /**
   * Validate element required content.
   *
   * Check if an element has the required set of elements. At least one of the
   * selectors must match.
   *
   * Returns `[]` when valid or a list of required but missing tagnames or
   * categories.
   */
  static validateRequiredContent(node, rules) {
    if (!rules || rules.length === 0) {
      return [];
    }
    return rules.filter((tagName) => {
      const haveMatchingChild = node.childElements.some(
        (child) => _Validator.validatePermittedCategory(child, tagName, false)
      );
      return !haveMatchingChild;
    });
  }
  /**
   * Test if an attribute has an allowed value and/or format.
   *
   * @param attr - Attribute to test.
   * @param rules - Element attribute metadta.
   * @returns `true` if attribute passes all tests.
   */
  static validateAttribute(attr, rules) {
    const rule = rules[attr.key];
    if (!rule) {
      return true;
    }
    const value = attr.value;
    if (value instanceof DynamicValue) {
      return true;
    }
    const empty = value === null || value === "";
    if (rule.boolean) {
      return empty || value === attr.key;
    }
    if (rule.omit && empty) {
      return true;
    }
    if (rule.list) {
      const tokens = new DOMTokenList(value, attr.valueLocation);
      return tokens.every((token) => {
        return this.validateAttributeValue(token, rule);
      });
    }
    return this.validateAttributeValue(value, rule);
  }
  static validateAttributeValue(value, rule) {
    if (!rule.enum) {
      return true;
    }
    if (value === null) {
      return false;
    }
    const caseInsensitiveValue = value.toLowerCase();
    return rule.enum.some((entry) => {
      if (entry instanceof RegExp) {
        return !!value.match(entry);
      } else {
        return caseInsensitiveValue === entry;
      }
    });
  }
  static validatePermittedRule(node, rule, isExclude = false) {
    if (typeof rule === "string") {
      return _Validator.validatePermittedCategory(node, rule, !isExclude);
    } else if (Array.isArray(rule)) {
      return rule.every((inner) => {
        return _Validator.validatePermittedRule(node, inner, isExclude);
      });
    } else {
      validateKeys(rule);
      if (rule.exclude) {
        if (Array.isArray(rule.exclude)) {
          return !rule.exclude.some((inner) => {
            return _Validator.validatePermittedRule(node, inner, true);
          });
        } else {
          return !_Validator.validatePermittedRule(node, rule.exclude, true);
        }
      } else {
        return true;
      }
    }
  }
  /**
   * Validate node against a content category.
   *
   * When matching parent nodes against permitted parents use the superset
   * parameter to also match for `@flow`. E.g. if a node expects a `@phrasing`
   * parent it should also allow `@flow` parent since `@phrasing` is a subset of
   * `@flow`.
   *
   * @param node - The node to test against
   * @param category - Name of category with `@` prefix or tag name.
   * @param defaultMatch - The default return value when node categories is not known.
   */
  /* eslint-disable-next-line complexity -- rule does not like switch */
  static validatePermittedCategory(node, category, defaultMatch) {
    const [, rawCategory] = /^(@?.*?)([?*]?)$/.exec(category);
    if (!rawCategory.startsWith("@")) {
      return node.tagName === rawCategory;
    }
    if (!node.meta) {
      return defaultMatch;
    }
    switch (rawCategory) {
      case "@meta":
        return node.meta.metadata;
      case "@flow":
        return node.meta.flow;
      case "@sectioning":
        return node.meta.sectioning;
      case "@heading":
        return node.meta.heading;
      case "@phrasing":
        return node.meta.phrasing;
      case "@embedded":
        return node.meta.embedded;
      case "@interactive":
        return node.meta.interactive;
      case "@script":
        return Boolean(node.meta.scriptSupporting);
      case "@form":
        return Boolean(node.meta.form);
      default:
        throw new Error(`Invalid content category "${category}"`);
    }
  }
};
function validateKeys(rule) {
  for (const key of Object.keys(rule)) {
    if (!allowedKeys.includes(key)) {
      const str = JSON.stringify(rule);
      throw new Error(`Permitted rule "${str}" contains unknown property "${key}"`);
    }
  }
}
function parseQuantifier(quantifier) {
  switch (quantifier) {
    case "?":
      return 1;
    case "*":
      return null;
    // istanbul ignore next
    default:
      throw new Error(`Invalid quantifier "${quantifier}" used`);
  }
}
var $schema = "http://json-schema.org/draft-06/schema#";
var $id = "https://html-validate.org/schemas/config.json";
var type = "object";
var additionalProperties = false;
var properties = {
  $schema: {
    type: "string"
  },
  root: {
    type: "boolean",
    title: "Mark as root configuration",
    description: "If this is set to true no further configurations will be searched.",
    "default": false
  },
  "extends": {
    type: "array",
    items: {
      type: "string"
    },
    title: "Configurations to extend",
    description: "Array of shareable or builtin configurations to extend."
  },
  elements: {
    type: "array",
    items: {
      anyOf: [
        {
          type: "string"
        },
        {
          type: "object"
        }
      ]
    },
    title: "Element metadata to load",
    description: "Array of modules, plugins or files to load element metadata from. Use <rootDir> to refer to the folder with the package.json file.",
    examples: [
      [
        "html-validate:recommended",
        "plugin:recommended",
        "module",
        "./local-file.json"
      ]
    ]
  },
  plugins: {
    type: "array",
    items: {
      anyOf: [
        {
          type: "string"
        },
        {
          type: "object"
        }
      ]
    },
    title: "Plugins to load",
    description: "Array of plugins load. Use <rootDir> to refer to the folder with the package.json file.",
    examples: [
      [
        "my-plugin",
        "./local-plugin"
      ]
    ]
  },
  transform: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          type: "string"
        },
        {
          "function": true
        }
      ]
    },
    title: "File transformations to use.",
    description: "Object where key is regular expression to match filename and value is name of transformer or a function.",
    examples: [
      {
        "^.*\\.foo$": "my-transformer",
        "^.*\\.bar$": "my-plugin",
        "^.*\\.baz$": "my-plugin:named"
      }
    ]
  },
  rules: {
    type: "object",
    patternProperties: {
      ".*": {
        anyOf: [
          {
            "enum": [
              0,
              1,
              2,
              "off",
              "warn",
              "error"
            ]
          },
          {
            type: "array",
            minItems: 1,
            maxItems: 1,
            items: [
              {
                "enum": [
                  0,
                  1,
                  2,
                  "off",
                  "warn",
                  "error"
                ]
              }
            ]
          },
          {
            type: "array",
            minItems: 2,
            maxItems: 2,
            items: [
              {
                "enum": [
                  0,
                  1,
                  2,
                  "off",
                  "warn",
                  "error"
                ]
              },
              {}
            ]
          }
        ]
      }
    },
    title: "Rule configuration.",
    description: "Enable/disable rules, set severity. Some rules have additional configuration like style or patterns to use.",
    examples: [
      {
        foo: "error",
        bar: "off",
        baz: [
          "error",
          {
            style: "camelcase"
          }
        ]
      }
    ]
  }
};
var configurationSchema = {
  $schema,
  $id,
  type,
  additionalProperties,
  properties
};
var Severity = /* @__PURE__ */ ((Severity2) => {
  Severity2[Severity2["DISABLED"] = 0] = "DISABLED";
  Severity2[Severity2["WARN"] = 1] = "WARN";
  Severity2[Severity2["ERROR"] = 2] = "ERROR";
  return Severity2;
})(Severity || {});
function parseSeverity(value) {
  switch (value) {
    case 0:
    case "off":
      return 0;
    case 1:
    case "warn":
      return 1;
    case 2:
    case "error":
      return 2;
    default:
      throw new Error(`Invalid severity "${String(value)}"`);
  }
}
function escape2(value) {
  return JSON.stringify(value);
}
function format(value, quote = false) {
  if (value === null || value === void 0) {
    return "null";
  }
  if (typeof value === "number") {
    return value.toString();
  }
  if (typeof value === "string") {
    return quote ? escape2(value) : value;
  }
  if (Array.isArray(value)) {
    const content = value.map((it) => format(it, true)).join(", ");
    return `[ ${content} ]`;
  }
  if (typeof value === "object") {
    const content = Object.entries(value).map(([key, nested]) => `${key}: ${format(nested, true)}`).join(", ");
    return `{ ${content} }`;
  }
  return String(value);
}
function interpolate(text, data) {
  return text.replace(/{{\s*([^\s{}]+)\s*}}/g, (match2, key) => {
    return typeof data[key] !== "undefined" ? format(data[key]) : match2;
  });
}
var cacheKey = Symbol("aria-naming");
var defaultValue = "allowed";
var prohibitedRoles = [
  "caption",
  "code",
  "deletion",
  "emphasis",
  "generic",
  "insertion",
  "paragraph",
  "presentation",
  "strong",
  "subscript",
  "superscript"
];
function byRole(role) {
  return prohibitedRoles.includes(role) ? "prohibited" : "allowed";
}
function byMeta(element, meta) {
  return meta.aria.naming(element._adapter);
}
function ariaNaming(element) {
  const cached = element.cacheGet(cacheKey);
  if (cached) {
    return cached;
  }
  const role = element.getAttribute("role")?.value;
  if (role) {
    if (role instanceof DynamicValue) {
      return element.cacheSet(cacheKey, defaultValue);
    } else {
      return element.cacheSet(cacheKey, byRole(role));
    }
  }
  const meta = element.meta;
  if (!meta) {
    return element.cacheSet(cacheKey, defaultValue);
  }
  return element.cacheSet(cacheKey, byMeta(element, meta));
}
var patternCache = /* @__PURE__ */ new Map();
function compileStringPattern(pattern) {
  const regexp2 = pattern.replace(/[*]+/g, ".+");
  return new RegExp(`^${regexp2}$`);
}
function compileRegExpPattern(pattern) {
  return new RegExp(`^${pattern}$`);
}
function compilePattern(pattern) {
  const cached = patternCache.get(pattern);
  if (cached) {
    return cached;
  }
  const match2 = /^\/(.*)\/$/.exec(pattern);
  const regexp2 = match2 ? compileRegExpPattern(match2[1]) : compileStringPattern(pattern);
  patternCache.set(pattern, regexp2);
  return regexp2;
}
function keywordPatternMatcher(list, keyword) {
  for (const pattern of list) {
    const regexp2 = compilePattern(pattern);
    if (regexp2.test(keyword)) {
      return true;
    }
  }
  return false;
}
function isKeywordIgnored(options, keyword, matcher = (list, it) => list.includes(it)) {
  const { include, exclude } = options;
  if (include && !matcher(include, keyword)) {
    return true;
  }
  if (exclude && matcher(exclude, keyword)) {
    return true;
  }
  return false;
}
var ARIA_HIDDEN_CACHE = Symbol(isAriaHidden.name);
var HTML_HIDDEN_CACHE = Symbol(isHTMLHidden.name);
var INERT_CACHE = Symbol(isInert.name);
var ROLE_PRESENTATION_CACHE = Symbol(isPresentation.name);
var STYLE_HIDDEN_CACHE = Symbol(isStyleHidden.name);
function inAccessibilityTree(node) {
  if (isAriaHidden(node)) {
    return false;
  }
  if (isPresentation(node)) {
    return false;
  }
  if (isHTMLHidden(node)) {
    return false;
  }
  if (isInert(node)) {
    return false;
  }
  if (isStyleHidden(node)) {
    return false;
  }
  return true;
}
function isAriaHiddenImpl(node) {
  const getAriaHiddenAttr = (node2) => {
    const ariaHidden = node2.getAttribute("aria-hidden");
    return Boolean(ariaHidden && ariaHidden.value === "true");
  };
  return {
    byParent: node.parent ? isAriaHidden(node.parent) : false,
    bySelf: getAriaHiddenAttr(node)
  };
}
function isAriaHidden(node, details) {
  const cached = node.cacheGet(ARIA_HIDDEN_CACHE);
  if (cached) {
    return details ? cached : cached.byParent || cached.bySelf;
  }
  const result = node.cacheSet(ARIA_HIDDEN_CACHE, isAriaHiddenImpl(node));
  return details ? result : result.byParent || result.bySelf;
}
function isHTMLHiddenImpl(node) {
  const getHiddenAttr = (node2) => {
    const hidden2 = node2.getAttribute("hidden");
    return Boolean(hidden2?.isStatic);
  };
  return {
    byParent: node.parent ? isHTMLHidden(node.parent) : false,
    bySelf: getHiddenAttr(node)
  };
}
function isHTMLHidden(node, details) {
  const cached = node.cacheGet(HTML_HIDDEN_CACHE);
  if (cached) {
    return details ? cached : cached.byParent || cached.bySelf;
  }
  const result = node.cacheSet(HTML_HIDDEN_CACHE, isHTMLHiddenImpl(node));
  return details ? result : result.byParent || result.bySelf;
}
function isInertImpl(node) {
  const getInertAttr = (node2) => {
    const inert = node2.getAttribute("inert");
    return Boolean(inert?.isStatic);
  };
  return {
    byParent: node.parent ? isInert(node.parent) : false,
    bySelf: getInertAttr(node)
  };
}
function isInert(node, details) {
  const cached = node.cacheGet(INERT_CACHE);
  if (cached) {
    return details ? cached : cached.byParent || cached.bySelf;
  }
  const result = node.cacheSet(INERT_CACHE, isInertImpl(node));
  return details ? result : result.byParent || result.bySelf;
}
function isStyleHiddenImpl(node) {
  const getStyleAttr = (node2) => {
    const style = node2.getAttribute("style");
    const { display, visibility } = parseCssDeclaration(style?.value);
    return display === "none" || visibility === "hidden";
  };
  const byParent = node.parent ? isStyleHidden(node.parent) : false;
  const bySelf = getStyleAttr(node);
  return byParent || bySelf;
}
function isStyleHidden(node) {
  const cached = node.cacheGet(STYLE_HIDDEN_CACHE);
  if (cached) {
    return cached;
  }
  return node.cacheSet(STYLE_HIDDEN_CACHE, isStyleHiddenImpl(node));
}
function isPresentation(node) {
  if (node.cacheExists(ROLE_PRESENTATION_CACHE)) {
    return Boolean(node.cacheGet(ROLE_PRESENTATION_CACHE));
  }
  const meta = node.meta;
  if (meta?.interactive) {
    return node.cacheSet(ROLE_PRESENTATION_CACHE, false);
  }
  const tabindex = node.getAttribute("tabindex");
  if (tabindex) {
    return node.cacheSet(ROLE_PRESENTATION_CACHE, false);
  }
  const role = node.getAttribute("role");
  if (role && (role.value === "presentation" || role.value === "none")) {
    return node.cacheSet(ROLE_PRESENTATION_CACHE, true);
  } else {
    return node.cacheSet(ROLE_PRESENTATION_CACHE, false);
  }
}
var cachePrefix = classifyNodeText.name;
var HTML_CACHE_KEY = Symbol(`${cachePrefix}|html`);
var A11Y_CACHE_KEY = Symbol(`${cachePrefix}|a11y`);
var IGNORE_HIDDEN_ROOT_HTML_CACHE_KEY = Symbol(`${cachePrefix}|html|ignore-hidden-root`);
var IGNORE_HIDDEN_ROOT_A11Y_CACHE_KEY = Symbol(`${cachePrefix}|a11y|ignore-hidden-root`);
var TextClassification = /* @__PURE__ */ ((TextClassification2) => {
  TextClassification2[TextClassification2["EMPTY_TEXT"] = 0] = "EMPTY_TEXT";
  TextClassification2[TextClassification2["DYNAMIC_TEXT"] = 1] = "DYNAMIC_TEXT";
  TextClassification2[TextClassification2["STATIC_TEXT"] = 2] = "STATIC_TEXT";
  return TextClassification2;
})(TextClassification || {});
function getCachekey(options) {
  const { accessible = false, ignoreHiddenRoot = false } = options;
  if (accessible && ignoreHiddenRoot) {
    return IGNORE_HIDDEN_ROOT_A11Y_CACHE_KEY;
  } else if (ignoreHiddenRoot) {
    return IGNORE_HIDDEN_ROOT_HTML_CACHE_KEY;
  } else if (accessible) {
    return A11Y_CACHE_KEY;
  } else {
    return HTML_CACHE_KEY;
  }
}
function isSpecialEmpty(node) {
  return node.is("select") || node.is("textarea");
}
function classifyNodeText(node, options = {}) {
  const { accessible = false, ignoreHiddenRoot = false } = options;
  const cacheKey2 = getCachekey(options);
  if (node.cacheExists(cacheKey2)) {
    return node.cacheGet(cacheKey2);
  }
  if (!ignoreHiddenRoot && isHTMLHidden(node)) {
    return node.cacheSet(
      cacheKey2,
      0
      /* EMPTY_TEXT */
    );
  }
  if (!ignoreHiddenRoot && accessible && isAriaHidden(node)) {
    return node.cacheSet(
      cacheKey2,
      0
      /* EMPTY_TEXT */
    );
  }
  if (isSpecialEmpty(node)) {
    return node.cacheSet(
      cacheKey2,
      0
      /* EMPTY_TEXT */
    );
  }
  const text = findTextNodes(node, {
    ...options
  });
  if (text.some((cur) => cur.isDynamic)) {
    return node.cacheSet(
      cacheKey2,
      1
      /* DYNAMIC_TEXT */
    );
  }
  if (text.some((cur) => /\S/.exec(cur.textContent) !== null)) {
    return node.cacheSet(
      cacheKey2,
      2
      /* STATIC_TEXT */
    );
  }
  return node.cacheSet(
    cacheKey2,
    0
    /* EMPTY_TEXT */
  );
}
function findTextNodes(node, options) {
  const { accessible = false } = options;
  let text = [];
  for (const child of node.childNodes) {
    if (isTextNode(child)) {
      text.push(child);
    } else if (isElementNode(child)) {
      if (isHTMLHidden(child, true).bySelf) {
        continue;
      }
      if (accessible && isAriaHidden(child, true).bySelf) {
        continue;
      }
      text = text.concat(findTextNodes(child, options));
    }
  }
  return text;
}
function hasAltText(image) {
  const alt = image.getAttribute("alt");
  if (!alt) {
    return false;
  }
  if (alt.value === null) {
    return false;
  }
  return alt.isDynamic || alt.value.toString() !== "";
}
function hasAriaLabel(node) {
  const label = node.getAttribute("aria-label");
  if (!label) {
    return false;
  }
  if (label.value === null) {
    return false;
  }
  return label.isDynamic || label.value.toString() !== "";
}
function partition(values, predicate) {
  const initial = [[], []];
  return values.reduce((accumulator, value, index) => {
    const match2 = predicate(value, index, values);
    accumulator[match2 ? 0 : 1].push(value);
    return accumulator;
  }, initial);
}
var ajv$1 = new import_ajv.default({ strict: true, strictTuples: true, strictTypes: true });
ajv$1.addMetaSchema(ajvSchemaDraft);
function getSchemaValidator(ruleId, properties2) {
  const $id2 = `rule/${ruleId}`;
  const cached = ajv$1.getSchema($id2);
  if (cached) {
    return cached;
  }
  const schema2 = {
    $id: $id2,
    type: "object",
    additionalProperties: false,
    properties: properties2
  };
  return ajv$1.compile(schema2);
}
function isErrorDescriptor(value) {
  return Boolean(value[0] && value[0].message);
}
function unpackErrorDescriptor(value) {
  if (isErrorDescriptor(value)) {
    return value[0];
  } else {
    const [node, message, location, context] = value;
    return { node, message, location, context };
  }
}
var Rule = class {
  reporter;
  parser;
  meta;
  enabled;
  // rule enabled/disabled, irregardless of severity
  blockers;
  severity;
  // rule severity
  event;
  /**
   * Rule name. Defaults to filename without extension but can be overwritten by
   * subclasses.
   */
  name;
  /**
   * Rule options.
   */
  options;
  constructor(options) {
    this.reporter = null;
    this.parser = null;
    this.meta = null;
    this.event = null;
    this.options = options;
    this.enabled = true;
    this.blockers = [];
    this.severity = Severity.DISABLED;
    this.name = "";
  }
  getSeverity() {
    return this.severity;
  }
  setServerity(severity) {
    this.severity = severity;
  }
  /**
   * Block this rule from generating errors. Pass in an id generated by
   * `createBlocker`. Can be unblocked by {@link Rule.unblock}.
   *
   * A blocked rule is similar to disabling it but it will still receive parser
   * events. A list of all blockers is passed to the `rule:error` event.
   *
   * @internal
   */
  block(id) {
    this.blockers.push(id);
  }
  /**
   * Unblock a rule previously blocked by {@link Rule.block}.
   *
   * @internal
   */
  unblock(id) {
    this.blockers = this.blockers.filter((it) => it !== id);
  }
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  /**
   * Returns `true` if rule is deprecated.
   *
   * Overridden by subclasses.
   */
  get deprecated() {
    return false;
  }
  /**
   * Test if rule is enabled.
   *
   * To be considered enabled the enabled flag must be true and the severity at
   * least warning.
   *
   * @internal
   */
  isEnabled(node) {
    return this.enabled && this.severity >= Severity.WARN && (!node || node.ruleEnabled(this.name));
  }
  /**
   * Test if rule is enabled.
   *
   * To be considered enabled the enabled flag must be true and the severity at
   * least warning.
   *
   * @internal
   */
  isBlocked(node) {
    if (this.blockers.length > 0) {
      return true;
    }
    if (node && node.ruleBlockers(this.name).length > 0) {
      return true;
    }
    return false;
  }
  /**
   * Get a list of all blockers currently active this rule.
   *
   * @internal
   */
  getBlockers(node) {
    return [...this.blockers, ...node ? node.ruleBlockers(this.name) : []];
  }
  /**
   * Check if keyword is being ignored by the current rule configuration.
   *
   * This method requires the [[RuleOption]] type to include two properties:
   *
   * - include: string[] | null
   * - exclude: string[] | null
   *
   * This methods checks if the given keyword is included by "include" but not
   * excluded by "exclude". If any property is unset it is skipped by the
   * condition. Usually the user would use either one but not both but there is
   * no limitation to use both but the keyword must satisfy both conditions. If
   * either condition fails `true` is returned.
   *
   * For instance, given `{ include: ["foo"] }` the keyword `"foo"` would match
   * but not `"bar"`.
   *
   * Similarly, given `{ exclude: ["foo"] }` the keyword `"bar"` would match but
   * not `"foo"`.
   *
   * @param keyword - Keyword to match against `include` and `exclude` options.
   * @param matcher - Optional function to compare items with.
   * @returns `true` if keyword is not present in `include` or is present in
   * `exclude`.
   */
  isKeywordIgnored(keyword, matcher = (list, it) => list.includes(it)) {
    return isKeywordIgnored(this.options, keyword, matcher);
  }
  /**
   * Get [[MetaElement]] for the given tag. If no specific metadata is present
   * the global metadata is returned or null if no global is present.
   *
   * @public
   * @returns A shallow copy of metadata.
   */
  getMetaFor(tagName) {
    return this.meta.getMetaFor(tagName);
  }
  /**
   * Find all tags which has enabled given property.
   */
  getTagsWithProperty(propName) {
    return this.meta.getTagsWithProperty(propName);
  }
  /**
   * Find tag matching tagName or inheriting from it.
   */
  getTagsDerivedFrom(tagName) {
    return this.meta.getTagsDerivedFrom(tagName);
  }
  /**
   * JSON schema for rule options.
   *
   * Rules should override this to return an object with JSON schema to validate
   * rule options. If `null` or `undefined` is returned no validation is
   * performed.
   */
  static schema() {
    return null;
  }
  report(...args) {
    const { node, message, location, context } = unpackErrorDescriptor(args);
    const enabled = this.isEnabled(node);
    const blocked = this.isBlocked(node);
    const where = this.findLocation({ node, location, event: this.event });
    this.parser.trigger("rule:error", {
      location: where,
      ruleId: this.name,
      enabled,
      blockers: this.getBlockers(node)
    });
    if (enabled && !blocked) {
      const interpolated = interpolate(message, context ?? {});
      this.reporter.add(this, interpolated, this.severity, node, where, context);
    }
  }
  findLocation(src) {
    if (src.location) {
      return src.location;
    }
    if (src.event?.location) {
      return src.event.location;
    }
    if (src.node?.location) {
      return src.node.location;
    }
    return {};
  }
  on(event, ...args) {
    const callback = args.pop();
    const filter2 = args.pop() ?? (() => true);
    return this.parser.on(event, (_event, data) => {
      if (this.isEnabled() && filter2(data)) {
        this.event = data;
        callback(data);
      }
    });
  }
  /**
   * Called by [[Engine]] when initializing the rule.
   *
   * Do not override this, use the `setup` callback instead.
   *
   * @internal
   */
  init(parser, reporter, severity, meta) {
    this.parser = parser;
    this.reporter = reporter;
    this.severity = severity;
    this.meta = meta;
  }
  /**
   * Validate rule options against schema. Throws error if object does not validate.
   *
   * For rules without schema this function does nothing.
   *
   * @throws {@link SchemaValidationError}
   * Thrown when provided options does not validate against rule schema.
   *
   * @param cls - Rule class (constructor)
   * @param ruleId - Rule identifier
   * @param jsonPath - JSON path from which [[options]] can be found in [[config]]
   * @param options - User configured options to be validated
   * @param filename - Filename from which options originated
   * @param config - Configuration from which options originated
   *
   * @internal
   */
  static validateOptions(cls, ruleId, jsonPath, options, filename, config2) {
    if (!cls) {
      return;
    }
    const schema2 = cls.schema();
    if (!schema2) {
      return;
    }
    const isValid = getSchemaValidator(ruleId, schema2);
    if (!isValid(options)) {
      const errors = isValid.errors ?? [];
      const mapped = errors.map((error) => {
        error.instancePath = `${jsonPath}${error.instancePath}`;
        return error;
      });
      throw new SchemaValidationError(filename, `Rule configuration error`, config2, schema2, mapped);
    }
  }
  /**
   * Rule documentation callback.
   *
   * Called when requesting additional documentation for a rule. Some rules
   * provide additional context to provide context-aware suggestions.
   *
   * @public
   * @virtual
   * @param context - Error context given by a reported error.
   * @returns Rule documentation and url with additional details or `null` if no
   * additional documentation is available.
   */
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars -- technical debt, prototype should be moved to interface */
  documentation(context) {
    return null;
  }
};
var defaults$y = {
  allowExternal: true,
  allowRelative: true,
  allowAbsolute: true,
  allowBase: true
};
var mapping = {
  a: "href",
  img: "src",
  link: "href",
  script: "src"
};
var description = {
  [
    "external"
    /* EXTERNAL */
  ]: "External links are not allowed by current configuration.",
  [
    "relative-base"
    /* RELATIVE_BASE */
  ]: "Links relative to <base> are not allowed by current configuration.",
  [
    "relative-path"
    /* RELATIVE_PATH */
  ]: "Relative links are not allowed by current configuration.",
  [
    "absolute"
    /* ABSOLUTE */
  ]: "Absolute links are not allowed by current configuration.",
  [
    "anchor"
    /* ANCHOR */
  ]: null
};
function parseAllow(value) {
  if (typeof value === "boolean") {
    return value;
  }
  return {
    /* eslint-disable security/detect-non-literal-regexp -- expected to be regexp  */
    include: value.include ? value.include.map((it) => new RegExp(it)) : null,
    exclude: value.exclude ? value.exclude.map((it) => new RegExp(it)) : null
    /* eslint-enable security/detect-non-literal-regexp */
  };
}
function matchList(value, list) {
  if (list.include && !list.include.some((it) => it.test(value))) {
    return false;
  }
  if (list.exclude?.some((it) => it.test(value))) {
    return false;
  }
  return true;
}
var AllowedLinks = class extends Rule {
  allowExternal;
  allowRelative;
  allowAbsolute;
  constructor(options) {
    super({ ...defaults$y, ...options });
    this.allowExternal = parseAllow(this.options.allowExternal);
    this.allowRelative = parseAllow(this.options.allowRelative);
    this.allowAbsolute = parseAllow(this.options.allowAbsolute);
  }
  static schema() {
    const booleanOrObject = {
      anyOf: [
        { type: "boolean" },
        {
          type: "object",
          properties: {
            include: {
              type: "array",
              items: { type: "string" }
            },
            exclude: {
              type: "array",
              items: { type: "string" }
            }
          }
        }
      ]
    };
    return {
      allowExternal: { ...booleanOrObject },
      allowRelative: { ...booleanOrObject },
      allowAbsolute: { ...booleanOrObject },
      allowBase: { type: "boolean" }
    };
  }
  documentation(context) {
    const message = description[context] ?? "This link type is not allowed by current configuration";
    return {
      description: message,
      url: "https://html-validate.org/rules/allowed-links.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      if (!event.value || !this.isRelevant(event)) {
        return;
      }
      const link = event.value.toString();
      const style = this.getStyle(link);
      switch (style) {
        case "anchor":
          break;
        case "absolute":
          this.handleAbsolute(link, event, style);
          break;
        case "external":
          this.handleExternal(link, event, style);
          break;
        case "relative-base":
          this.handleRelativeBase(link, event, style);
          break;
        case "relative-path":
          this.handleRelativePath(link, event, style);
          break;
      }
    });
  }
  isRelevant(event) {
    const { target, key, value } = event;
    if (value instanceof DynamicValue) {
      return false;
    }
    const attr = mapping[target.tagName];
    return Boolean(attr && attr === key);
  }
  getStyle(value) {
    if (value.match(/^([a-z]+:)?\/\//g)) {
      return "external";
    }
    switch (value[0]) {
      /* /foo/bar */
      case "/":
        return "absolute";
      /* ../foo/bar */
      case ".":
        return "relative-path";
      /* #foo */
      case "#":
        return "anchor";
      /* foo/bar */
      default:
        return "relative-base";
    }
  }
  handleAbsolute(target, event, style) {
    const { allowAbsolute } = this;
    if (allowAbsolute === true) {
      return;
    } else if (allowAbsolute === false) {
      this.report(
        event.target,
        "Link destination must not be absolute url",
        event.valueLocation,
        style
      );
    } else if (!matchList(target, allowAbsolute)) {
      this.report(
        event.target,
        "Absolute link to this destination is not allowed by current configuration",
        event.valueLocation,
        style
      );
    }
  }
  handleExternal(target, event, style) {
    const { allowExternal } = this;
    if (allowExternal === true) {
      return;
    } else if (allowExternal === false) {
      this.report(
        event.target,
        "Link destination must not be external url",
        event.valueLocation,
        style
      );
    } else if (!matchList(target, allowExternal)) {
      this.report(
        event.target,
        "External link to this destination is not allowed by current configuration",
        event.valueLocation,
        style
      );
    }
  }
  handleRelativePath(target, event, style) {
    const { allowRelative } = this;
    if (allowRelative === true) {
      return false;
    } else if (allowRelative === false) {
      this.report(
        event.target,
        "Link destination must not be relative url",
        event.valueLocation,
        style
      );
      return true;
    } else if (!matchList(target, allowRelative)) {
      this.report(
        event.target,
        "Relative link to this destination is not allowed by current configuration",
        event.valueLocation,
        style
      );
      return true;
    }
    return false;
  }
  handleRelativeBase(target, event, style) {
    const { allowBase } = this.options;
    if (this.handleRelativePath(target, event, style)) {
      return;
    } else if (!allowBase) {
      this.report(
        event.target,
        "Relative links must be relative to current folder",
        event.valueLocation,
        style
      );
    }
  }
};
var defaults$x = {
  accessible: true
};
function findByTarget(target, siblings) {
  return siblings.filter((it) => it.getAttributeValue("href") === target);
}
function getAltText(node) {
  return node.getAttributeValue("alt");
}
function getDescription$1(context) {
  switch (context) {
    case "missing-alt":
      return [
        "The `alt` attribute must be set (and not empty) when the `href` attribute is present on an `<area>` element.",
        "",
        "The attribute is used to provide an alternative text description for the area of the image map.",
        "The text should describe the purpose of area and the resource referenced by the `href` attribute.",
        "",
        "Either add the `alt` attribute or remove the `href` attribute."
      ];
    case "missing-href":
      return [
        "The `alt` attribute must not be set when the `href` attribute is missing on an `<area>` element.",
        "",
        "Either add the `href` attribute or remove the `alt` attribute."
      ];
  }
}
var AreaAlt = class extends Rule {
  constructor(options) {
    super({ ...defaults$x, ...options });
  }
  static schema() {
    return {
      accessible: {
        type: "boolean"
      }
    };
  }
  documentation(context) {
    return {
      description: getDescription$1(context).join("\n"),
      url: "https://html-validate.org/rules/area-alt.html"
    };
  }
  setup() {
    this.on("element:ready", this.isRelevant, (event) => {
      const { target } = event;
      const siblings = target.querySelectorAll("area");
      for (const child of siblings) {
        this.validateArea(child, siblings);
      }
    });
  }
  validateArea(area, siblings) {
    const { accessible } = this.options;
    const href = area.getAttribute("href");
    const alt = area.getAttribute("alt");
    if (href) {
      if (isDynamicAttribute(alt)) {
        return;
      }
      const target = area.getAttributeValue("href");
      const altTexts = accessible ? [getAltText(area)] : findByTarget(target, siblings).map(getAltText);
      if (!altTexts.some(Boolean)) {
        this.report({
          node: area,
          message: `"alt" attribute must be set and non-empty when the "href" attribute is present`,
          location: alt ? alt.keyLocation : href.keyLocation,
          context: "missing-alt"
          /* MISSING_ALT */
        });
      }
    } else if (alt) {
      this.report({
        node: area,
        message: `"alt" attribute cannot be used unless the "href" attribute is present`,
        location: alt.keyLocation,
        context: "missing-href"
        /* MISSING_HREF */
      });
    }
  }
  isRelevant(event) {
    const { target } = event;
    return target.is("map");
  }
};
var AriaHiddenBody = class extends Rule {
  documentation() {
    return {
      description: "`aria-hidden` must not be used on the `<body>` element as it makes the page inaccessible to assistive technology such as screenreaders",
      url: "https://html-validate.org/rules/aria-hidden-body.html"
    };
  }
  setup() {
    this.on("tag:ready", this.isRelevant, (event) => {
      const { target } = event;
      const attr = target.getAttribute("aria-hidden");
      if (!attr?.valueMatches("true", true)) {
        return;
      }
      this.report(target, "aria-hidden must not be used on <body>", attr.keyLocation);
    });
  }
  isRelevant(event) {
    return event.target.is("body");
  }
};
var defaults$w = {
  allowAnyNamable: false
};
var whitelisted = [
  "main",
  "nav",
  "table",
  "td",
  "th",
  "aside",
  "header",
  "footer",
  "section",
  "article",
  "dialog",
  "form",
  "img",
  "area",
  "fieldset",
  "summary",
  "figure"
];
function isValidUsage(target, meta) {
  const explicit = meta.attributes["aria-label"];
  if (explicit) {
    return true;
  }
  if (whitelisted.includes(target.tagName)) {
    return true;
  }
  if (target.hasAttribute("role")) {
    return true;
  }
  if (target.hasAttribute("tabindex")) {
    return true;
  }
  if (Boolean(meta.interactive) || Boolean(meta.labelable)) {
    return true;
  }
  return false;
}
var AriaLabelMisuse = class extends Rule {
  constructor(options) {
    super({ ...defaults$w, ...options });
  }
  documentation() {
    const valid = [
      "Interactive elements",
      "Labelable elements",
      "Landmark elements",
      "Elements with roles inheriting from widget",
      "`<area>`",
      "`<dialog>`",
      "`<form>` and `<fieldset>`",
      "`<iframe>`",
      "`<img>` and `<figure>`",
      "`<summary>`",
      "`<table>`, `<td>` and `<th>`"
    ];
    const lines = valid.map((it) => `- ${it}
`).join("");
    return {
      description: `\`aria-label\` can only be used on:

${lines}`,
      url: "https://html-validate.org/rules/aria-label-misuse.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      for (const target of document.querySelectorAll("[aria-label]")) {
        this.validateElement(target);
      }
    });
  }
  validateElement(target) {
    const attr = target.getAttribute("aria-label");
    if (!attr.value || attr.valueMatches("", false)) {
      return;
    }
    const meta = target.meta;
    if (!meta) {
      return;
    }
    if (isValidUsage(target, meta)) {
      return;
    }
    if (this.options.allowAnyNamable && ariaNaming(target) === "allowed") {
      return;
    }
    this.report(target, `"aria-label" cannot be used on this element`, attr.keyLocation);
  }
};
var ConfigError = class _ConfigError extends UserError {
  constructor(message, nested) {
    super(message, nested);
    Error.captureStackTrace(this, _ConfigError);
    this.name = _ConfigError.name;
  }
};
var CaseStyle = class {
  styles;
  /**
   * @param style - Name of a valid case style.
   */
  constructor(style, ruleId) {
    if (!Array.isArray(style)) {
      style = [style];
    }
    if (style.length === 0) {
      throw new ConfigError(`Missing style for ${ruleId} rule`);
    }
    this.styles = this.parseStyle(style, ruleId);
  }
  /**
   * Test if a text matches this case style.
   */
  match(text) {
    return this.styles.some((style) => text.match(style.pattern));
  }
  get name() {
    const names = this.styles.map((style) => style.name);
    switch (this.styles.length) {
      case 1:
        return names[0];
      case 2:
        return names.join(" or ");
      default: {
        const last = names.slice(-1);
        const rest = names.slice(0, -1);
        return `${rest.join(", ")} or ${last[0]}`;
      }
    }
  }
  parseStyle(style, ruleId) {
    return style.map((cur) => {
      switch (cur.toLowerCase()) {
        case "lowercase":
          return { pattern: /^[a-z]*$/, name: "lowercase" };
        case "uppercase":
          return { pattern: /^[A-Z]*$/, name: "uppercase" };
        case "pascalcase":
          return { pattern: /^[A-Z][A-Za-z]*$/, name: "PascalCase" };
        case "camelcase":
          return { pattern: /^[a-z][A-Za-z]*$/, name: "camelCase" };
        default:
          throw new ConfigError(`Invalid style "${cur}" for ${ruleId} rule`);
      }
    });
  }
};
var defaults$v = {
  style: "lowercase",
  ignoreForeign: true
};
var AttrCase = class extends Rule {
  style;
  constructor(options) {
    super({ ...defaults$v, ...options });
    this.style = new CaseStyle(this.options.style, "attr-case");
  }
  static schema() {
    const styleEnum = ["lowercase", "uppercase", "pascalcase", "camelcase"];
    return {
      ignoreForeign: {
        type: "boolean"
      },
      style: {
        anyOf: [
          {
            enum: styleEnum,
            type: "string"
          },
          {
            items: {
              enum: styleEnum,
              type: "string"
            },
            type: "array"
          }
        ]
      }
    };
  }
  documentation() {
    const { style } = this.options;
    return {
      description: Array.isArray(style) ? [`Attribute name must be in one of:`, "", ...style.map((it) => `- ${it}`)].join("\n") : `Attribute name must be in ${style}.`,
      url: "https://html-validate.org/rules/attr-case.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      if (this.isIgnored(event.target)) {
        return;
      }
      if (event.originalAttribute) {
        return;
      }
      const letters = event.key.replace(/[^a-z]+/gi, "");
      if (this.style.match(letters)) {
        return;
      }
      this.report({
        node: event.target,
        message: `Attribute "${event.key}" should be ${this.style.name}`,
        location: event.keyLocation
      });
    });
  }
  isIgnored(node) {
    if (this.options.ignoreForeign) {
      return Boolean(node.meta?.foreign);
    } else {
      return false;
    }
  }
};
var TokenType = /* @__PURE__ */ ((TokenType2) => {
  TokenType2[TokenType2["UNICODE_BOM"] = 1] = "UNICODE_BOM";
  TokenType2[TokenType2["WHITESPACE"] = 2] = "WHITESPACE";
  TokenType2[TokenType2["DOCTYPE_OPEN"] = 3] = "DOCTYPE_OPEN";
  TokenType2[TokenType2["DOCTYPE_VALUE"] = 4] = "DOCTYPE_VALUE";
  TokenType2[TokenType2["DOCTYPE_CLOSE"] = 5] = "DOCTYPE_CLOSE";
  TokenType2[TokenType2["TAG_OPEN"] = 6] = "TAG_OPEN";
  TokenType2[TokenType2["TAG_CLOSE"] = 7] = "TAG_CLOSE";
  TokenType2[TokenType2["ATTR_NAME"] = 8] = "ATTR_NAME";
  TokenType2[TokenType2["ATTR_VALUE"] = 9] = "ATTR_VALUE";
  TokenType2[TokenType2["TEXT"] = 10] = "TEXT";
  TokenType2[TokenType2["TEMPLATING"] = 11] = "TEMPLATING";
  TokenType2[TokenType2["SCRIPT"] = 12] = "SCRIPT";
  TokenType2[TokenType2["STYLE"] = 13] = "STYLE";
  TokenType2[TokenType2["COMMENT"] = 14] = "COMMENT";
  TokenType2[TokenType2["CONDITIONAL"] = 15] = "CONDITIONAL";
  TokenType2[TokenType2["DIRECTIVE"] = 16] = "DIRECTIVE";
  TokenType2[TokenType2["EOF"] = 17] = "EOF";
  return TokenType2;
})(TokenType || {});
var MATCH_UNICODE_BOM = /^\uFEFF/;
var MATCH_WHITESPACE = /^(?:\r\n|\r|\n|[ \t]+(?:\r\n|\r|\n)?)/;
var MATCH_DOCTYPE_OPEN = /^<!(DOCTYPE)\s/i;
var MATCH_DOCTYPE_VALUE = /^[^>]+/;
var MATCH_DOCTYPE_CLOSE = /^>/;
var MATCH_XML_TAG = /^<\?xml.*?\?>\s+/;
var MATCH_TAG_OPEN = /^<(\/?)([a-zA-Z0-9\-_:]+)/;
var MATCH_TAG_CLOSE = /^\/?>/;
var MATCH_TEXT = /^[^]*?(?=(?:[ \t]*(?:\r\n|\r|\n)|<[^ ]|$))/;
var MATCH_TEMPLATING = /^(?:<%.*?%>|<\?.*?\?>|<\$.*?\$>)/s;
var MATCH_TAG_LOOKAHEAD = /^[^]*?(?=<|$)/;
var MATCH_ATTR_START = /^([^\t\r\n\f \/><"'=]+)/;
var MATCH_ATTR_SINGLE = /^(\s*=\s*)'([^']*?)(')/;
var MATCH_ATTR_DOUBLE = /^(\s*=\s*)"([^"]*?)(")/;
var MATCH_ATTR_UNQUOTED = /^(\s*=\s*)([^\t\r\n\f "'<>][^\t\r\n\f <>]*)/;
var MATCH_CDATA_BEGIN = /^<!\[CDATA\[/;
var MATCH_CDATA_END = /^[^]*?]]>/;
var MATCH_SCRIPT_DATA = /^[^]*?(?=<\/script)/;
var MATCH_SCRIPT_END = /^<(\/)(script)/;
var MATCH_STYLE_DATA = /^[^]*?(?=<\/style)/;
var MATCH_STYLE_END = /^<(\/)(style)/;
var MATCH_DIRECTIVE = /^(<!--\s*\[html-validate-)([a-z0-9-]+)(\s*)(.*?)(]?\s*-->)/;
var MATCH_COMMENT = /^<!--([^]*?)-->/;
var MATCH_CONDITIONAL = /^<!\[([^\]]*?)\]>/;
var InvalidTokenError = class extends Error {
  location;
  constructor(location, message) {
    super(message);
    this.location = location;
  }
};
var Lexer = class {
  /* eslint-disable-next-line complexity -- there isn't really a good way to refactor this while keeping readability */
  *tokenize(source) {
    const context = new Context(source);
    let previousState = context.state;
    let previousLength = context.string.length;
    while (context.string.length > 0) {
      switch (context.state) {
        case State.INITIAL:
          yield* this.tokenizeInitial(context);
          break;
        case State.DOCTYPE:
          yield* this.tokenizeDoctype(context);
          break;
        case State.TAG:
          yield* this.tokenizeTag(context);
          break;
        case State.ATTR:
          yield* this.tokenizeAttr(context);
          break;
        case State.TEXT:
          yield* this.tokenizeText(context);
          break;
        case State.CDATA:
          yield* this.tokenizeCDATA(context);
          break;
        case State.SCRIPT:
          yield* this.tokenizeScript(context);
          break;
        case State.STYLE:
          yield* this.tokenizeStyle(context);
          break;
        /* istanbul ignore next: sanity check: should not happen unless adding new states */
        default:
          this.unhandled(context);
      }
      if (context.state === previousState && context.string.length === previousLength) {
        this.errorStuck(context);
      }
      previousState = context.state;
      previousLength = context.string.length;
    }
    yield this.token(context, TokenType.EOF, []);
  }
  token(context, type2, data) {
    const size = data.length > 0 ? data[0].length : 0;
    const location = context.getLocation(size);
    return {
      type: type2,
      location,
      data: Array.from(data)
    };
  }
  /* istanbul ignore next: used to provide a better error when an unhandled state happens */
  unhandled(context) {
    const truncated = JSON.stringify(
      context.string.length > 13 ? `${context.string.slice(0, 15)}...` : context.string
    );
    const state = State[context.state];
    const message = `failed to tokenize ${truncated}, unhandled state ${state}.`;
    throw new InvalidTokenError(context.getLocation(1), message);
  }
  /* istanbul ignore next: used to provide a better error when lexer is detected to be stuck, no known way to reproduce */
  errorStuck(context) {
    const state = State[context.state];
    const message = `failed to tokenize ${context.getTruncatedLine()}, state ${state} failed to consume data or change state.`;
    throw new InvalidTokenError(context.getLocation(1), message);
  }
  evalNextState(nextState, token) {
    if (typeof nextState === "function") {
      return nextState(token);
    } else {
      return nextState;
    }
  }
  *match(context, tests, error) {
    const n = tests.length;
    for (let i = 0; i < n; i++) {
      const [regex, nextState, tokenType] = tests[i];
      const match2 = regex ? context.string.match(regex) : [""];
      if (match2) {
        let token = null;
        if (tokenType !== false) {
          token = this.token(context, tokenType, match2);
          yield token;
        }
        const state = this.evalNextState(nextState, token);
        context.consume(match2[0].length, state);
        this.enter(context, state, match2);
        return;
      }
    }
    const message = `failed to tokenize ${context.getTruncatedLine()}, ${error}.`;
    throw new InvalidTokenError(context.getLocation(1), message);
  }
  /**
   * Called when entering a new state.
   */
  enter(context, state, data) {
    if (state === State.TAG && data?.[0].startsWith("<")) {
      if (data[0] === "<script") {
        context.contentModel = ContentModel.SCRIPT;
      } else if (data[0] === "<style") {
        context.contentModel = ContentModel.STYLE;
      } else {
        context.contentModel = ContentModel.TEXT;
      }
    }
  }
  *tokenizeInitial(context) {
    yield* this.match(
      context,
      [
        [MATCH_UNICODE_BOM, State.INITIAL, TokenType.UNICODE_BOM],
        [MATCH_XML_TAG, State.INITIAL, false],
        [MATCH_DOCTYPE_OPEN, State.DOCTYPE, TokenType.DOCTYPE_OPEN],
        [MATCH_WHITESPACE, State.INITIAL, TokenType.WHITESPACE],
        [MATCH_DIRECTIVE, State.INITIAL, TokenType.DIRECTIVE],
        [MATCH_CONDITIONAL, State.INITIAL, TokenType.CONDITIONAL],
        [MATCH_COMMENT, State.INITIAL, TokenType.COMMENT],
        [false, State.TEXT, false]
      ],
      "expected doctype"
    );
  }
  *tokenizeDoctype(context) {
    yield* this.match(
      context,
      [
        [MATCH_WHITESPACE, State.DOCTYPE, TokenType.WHITESPACE],
        [MATCH_DOCTYPE_VALUE, State.DOCTYPE, TokenType.DOCTYPE_VALUE],
        [MATCH_DOCTYPE_CLOSE, State.TEXT, TokenType.DOCTYPE_CLOSE]
      ],
      "expected doctype name"
    );
  }
  *tokenizeTag(context) {
    function nextState(token) {
      const tagCloseToken = token;
      switch (context.contentModel) {
        case ContentModel.TEXT:
          return State.TEXT;
        case ContentModel.SCRIPT:
          if (tagCloseToken && !tagCloseToken.data[0].startsWith("/")) {
            return State.SCRIPT;
          } else {
            return State.TEXT;
          }
        case ContentModel.STYLE:
          if (tagCloseToken && !tagCloseToken.data[0].startsWith("/")) {
            return State.STYLE;
          } else {
            return State.TEXT;
          }
      }
    }
    yield* this.match(
      context,
      [
        [MATCH_TAG_CLOSE, nextState, TokenType.TAG_CLOSE],
        [MATCH_ATTR_START, State.ATTR, TokenType.ATTR_NAME],
        [MATCH_WHITESPACE, State.TAG, TokenType.WHITESPACE]
      ],
      'expected attribute, ">" or "/>"'
    );
  }
  *tokenizeAttr(context) {
    yield* this.match(
      context,
      [
        [MATCH_ATTR_SINGLE, State.TAG, TokenType.ATTR_VALUE],
        [MATCH_ATTR_DOUBLE, State.TAG, TokenType.ATTR_VALUE],
        [MATCH_ATTR_UNQUOTED, State.TAG, TokenType.ATTR_VALUE],
        [false, State.TAG, false]
      ],
      'expected attribute, ">" or "/>"'
    );
  }
  *tokenizeText(context) {
    yield* this.match(
      context,
      [
        [MATCH_WHITESPACE, State.TEXT, TokenType.WHITESPACE],
        [MATCH_CDATA_BEGIN, State.CDATA, false],
        [MATCH_DIRECTIVE, State.TEXT, TokenType.DIRECTIVE],
        [MATCH_CONDITIONAL, State.TEXT, TokenType.CONDITIONAL],
        [MATCH_COMMENT, State.TEXT, TokenType.COMMENT],
        [MATCH_TEMPLATING, State.TEXT, TokenType.TEMPLATING],
        [MATCH_TAG_OPEN, State.TAG, TokenType.TAG_OPEN],
        [MATCH_TEXT, State.TEXT, TokenType.TEXT],
        [MATCH_TAG_LOOKAHEAD, State.TEXT, TokenType.TEXT]
      ],
      'expected text or "<"'
    );
  }
  *tokenizeCDATA(context) {
    yield* this.match(context, [[MATCH_CDATA_END, State.TEXT, false]], "expected ]]>");
  }
  *tokenizeScript(context) {
    yield* this.match(
      context,
      [
        [MATCH_SCRIPT_END, State.TAG, TokenType.TAG_OPEN],
        [MATCH_SCRIPT_DATA, State.SCRIPT, TokenType.SCRIPT]
      ],
      "expected </script>"
    );
  }
  *tokenizeStyle(context) {
    yield* this.match(
      context,
      [
        [MATCH_STYLE_END, State.TAG, TokenType.TAG_OPEN],
        [MATCH_STYLE_DATA, State.STYLE, TokenType.STYLE]
      ],
      "expected </style>"
    );
  }
};
var whitespace2 = /(\s+)/;
var AttrDelimiter = class extends Rule {
  documentation() {
    return {
      description: `Attribute value must not be separated by whitespace.`,
      url: "https://html-validate.org/rules/attr-delimiter.html"
    };
  }
  setup() {
    this.on("token", (event) => {
      const { token } = event;
      if (token.type !== TokenType.ATTR_VALUE) {
        return;
      }
      const delimiter = token.data[1];
      const match2 = whitespace2.exec(delimiter);
      if (match2) {
        const location = sliceLocation(event.location, 0, delimiter.length);
        this.report(null, "Attribute value must not be delimited by whitespace", location);
      }
    });
  }
};
var DEFAULT_PATTERN = "[a-z0-9-:]+";
var defaults$u = {
  pattern: DEFAULT_PATTERN,
  ignoreForeign: true
};
function generateRegexp(pattern) {
  if (Array.isArray(pattern)) {
    return new RegExp(`^(${pattern.join("|")})$`, "i");
  } else {
    return new RegExp(`^${pattern}$`, "i");
  }
}
function generateMessage(name, pattern) {
  if (Array.isArray(pattern)) {
    const patterns = pattern.map((it) => `/${it}/`).join(", ");
    return `Attribute "${name}" should match one of [${patterns}]`;
  } else {
    return `Attribute "${name}" should match /${pattern}/`;
  }
}
function generateDescription(name, pattern) {
  if (Array.isArray(pattern)) {
    return [
      `Attribute "${name}" should match one of the configured regular expressions:`,
      "",
      ...pattern.map((it) => `- \`/${it}/\``)
    ].join("\n");
  } else {
    return `Attribute "${name}" should match the regular expression \`/${pattern}/\``;
  }
}
var AttrPattern = class extends Rule {
  pattern;
  constructor(options) {
    super({ ...defaults$u, ...options });
    this.pattern = generateRegexp(this.options.pattern);
  }
  static schema() {
    return {
      pattern: {
        oneOf: [{ type: "array", items: { type: "string" }, minItems: 1 }, { type: "string" }]
      },
      ignoreForeign: {
        type: "boolean"
      }
    };
  }
  documentation(context) {
    return {
      description: generateDescription(context.attr, context.pattern),
      url: "https://html-validate.org/rules/attr-pattern.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      if (this.isIgnored(event.target)) {
        return;
      }
      if (event.originalAttribute) {
        return;
      }
      if (this.pattern.test(event.key)) {
        return;
      }
      const message = generateMessage(event.key, this.options.pattern);
      const context = {
        attr: event.key,
        pattern: this.options.pattern
      };
      this.report(event.target, message, event.keyLocation, context);
    });
  }
  isIgnored(node) {
    if (this.options.ignoreForeign) {
      return Boolean(node.meta?.foreign);
    } else {
      return false;
    }
  }
};
var defaults$t = {
  style: "auto",
  unquoted: false
};
function describeError(context) {
  switch (context.error) {
    case "style":
      return `Attribute \`${context.attr}\` must use \`${context.expected}\` instead of \`${context.actual}\`.`;
    case "unquoted":
      return `Attribute \`${context.attr}\` must not be unquoted.`;
  }
}
function describeStyle(style, unquoted) {
  const description2 = [];
  switch (style) {
    case "auto":
      description2.push(
        "- quoted with double quotes `\"` unless the value contains double quotes in which case single quotes `'` should be used instead"
      );
      break;
    case "any":
      description2.push("- quoted with single quotes `'`");
      description2.push('- quoted with double quotes `"`');
      break;
    case "'":
    case '"': {
      const name = style === "'" ? "single" : "double";
      description2.push(`- quoted with ${name} quotes \`${style}\``);
      break;
    }
  }
  if (unquoted) {
    description2.push("- unquoted (if applicable)");
  }
  return `${description2.join(" or\n")}
`;
}
var AttrQuotes = class extends Rule {
  style;
  static schema() {
    return {
      style: {
        enum: ["auto", "double", "single", "any"],
        type: "string"
      },
      unquoted: {
        type: "boolean"
      }
    };
  }
  documentation(context) {
    const { style } = this;
    const { unquoted } = this.options;
    const description2 = [
      describeError(context),
      "",
      "Under the current configuration attributes must be:",
      "",
      describeStyle(style, unquoted)
    ];
    return {
      description: description2.join("\n"),
      url: "https://html-validate.org/rules/attr-quotes.html"
    };
  }
  constructor(options) {
    super({ ...defaults$t, ...options });
    this.style = parseStyle$3(this.options.style);
  }
  setup() {
    this.on("attr", (event) => {
      if (event.originalAttribute) {
        return;
      }
      if (event.value === null) {
        return;
      }
      if (!event.quote) {
        if (!this.options.unquoted) {
          const message = `Attribute "${event.key}" using unquoted value`;
          const context = {
            error: "unquoted",
            attr: event.key
          };
          this.report(event.target, message, null, context);
        }
        return;
      }
      if (this.style === "any") {
        return;
      }
      const expected = this.resolveQuotemark(event.value.toString(), this.style);
      if (event.quote !== expected) {
        const message = `Attribute "${event.key}" used ${event.quote} instead of expected ${expected}`;
        const context = {
          error: "style",
          attr: event.key,
          actual: event.quote,
          expected
        };
        this.report(event.target, message, null, context);
      }
    });
  }
  resolveQuotemark(value, style) {
    if (style === "auto") {
      return value.includes('"') ? "'" : '"';
    } else {
      return style;
    }
  }
};
function parseStyle$3(style) {
  switch (style.toLowerCase()) {
    case "auto":
      return "auto";
    case "double":
      return '"';
    case "single":
      return "'";
    case "any":
      return "any";
    /* istanbul ignore next: covered by schema validation */
    default:
      throw new ConfigError(`Invalid style "${style}" for "attr-quotes" rule`);
  }
}
var AttrSpacing = class extends Rule {
  documentation() {
    return {
      description: `No space between attributes. At least one whitespace character (commonly space) must be used to separate attributes.`,
      url: "https://html-validate.org/rules/attr-spacing.html"
    };
  }
  setup() {
    let previousToken;
    this.on("token", (event) => {
      if (event.type === TokenType.ATTR_NAME && previousToken !== TokenType.WHITESPACE) {
        this.report(null, "No space between attributes", event.location);
      }
      previousToken = event.type;
    });
  }
};
function pick(attr) {
  const result = {};
  if (typeof attr.enum !== "undefined") {
    result.enum = attr.enum;
  }
  if (typeof attr.boolean !== "undefined") {
    result.boolean = attr.boolean;
  }
  return result;
}
var AttributeAllowedValues = class extends Rule {
  documentation(context) {
    const docs = {
      description: "Attribute has invalid value.",
      url: "https://html-validate.org/rules/attribute-allowed-values.html"
    };
    if (!context) {
      return docs;
    }
    const { allowed, attribute, element, value } = context;
    if (allowed.enum) {
      const allowedList = allowed.enum.map((value2) => {
        if (typeof value2 === "string") {
          return `- \`"${value2}"\``;
        } else {
          return `- \`${value2.toString()}\``;
        }
      });
      docs.description = [
        `The \`<${element}>\` element does not allow the attribute \`${attribute}\` to have the value \`"${value}"\`.`,
        "",
        "It must match one of the following:",
        "",
        ...allowedList
      ].join("\n");
    } else if (allowed.boolean) {
      docs.description = `The \`<${context.element}>\` attribute \`${context.attribute}\` must be a boolean attribute, e.g. \`<${context.element} ${context.attribute}>\``;
    }
    return docs;
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      walk.depthFirst(doc, (node) => {
        const meta = node.meta;
        if (!meta?.attributes) return;
        for (const attr of node.attributes) {
          if (Validator.validateAttribute(attr, meta.attributes)) {
            continue;
          }
          const value = attr.value ? attr.value.toString() : "";
          const context = {
            element: node.tagName,
            attribute: attr.key,
            value,
            allowed: pick(meta.attributes[attr.key])
          };
          const message = this.getMessage(attr);
          const location = this.getLocation(attr);
          this.report(node, message, location, context);
        }
      });
    });
  }
  getMessage(attr) {
    const { key, value } = attr;
    if (value !== null) {
      return `Attribute "${key}" has invalid value "${value.toString()}"`;
    } else {
      return `Attribute "${key}" is missing value`;
    }
  }
  getLocation(attr) {
    return attr.valueLocation ?? attr.keyLocation;
  }
};
var defaults$s = {
  style: "omit"
};
var AttributeBooleanStyle = class extends Rule {
  hasInvalidStyle;
  constructor(options) {
    super({ ...defaults$s, ...options });
    this.hasInvalidStyle = parseStyle$2(this.options.style);
  }
  static schema() {
    return {
      style: {
        enum: ["empty", "name", "omit"],
        type: "string"
      }
    };
  }
  documentation() {
    return {
      description: "Require a specific style when writing boolean attributes.",
      url: "https://html-validate.org/rules/attribute-boolean-style.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      walk.depthFirst(doc, (node) => {
        const meta = node.meta;
        if (!meta?.attributes) return;
        for (const attr of node.attributes) {
          if (!this.isBoolean(attr, meta.attributes)) continue;
          if (attr.originalAttribute) {
            continue;
          }
          if (this.hasInvalidStyle(attr)) {
            this.report(node, reportMessage$1(attr, this.options.style), attr.keyLocation);
          }
        }
      });
    });
  }
  isBoolean(attr, rules) {
    const meta = rules[attr.key];
    return Boolean(meta?.boolean);
  }
};
function parseStyle$2(style) {
  switch (style.toLowerCase()) {
    case "omit":
      return (attr) => attr.value !== null;
    case "empty":
      return (attr) => attr.value !== "";
    case "name":
      return (attr) => attr.value !== attr.key;
    /* istanbul ignore next: covered by schema validation */
    default:
      throw new Error(`Invalid style "${style}" for "attribute-boolean-style" rule`);
  }
}
function reportMessage$1(attr, style) {
  const key = attr.key;
  switch (style.toLowerCase()) {
    case "omit":
      return `Attribute "${key}" should omit value`;
    case "empty":
      return `Attribute "${key}" value should be empty string`;
    case "name":
      return `Attribute "${key}" should be set to ${key}="${key}"`;
  }
  return "";
}
var defaults$r = {
  style: "omit"
};
var AttributeEmptyStyle = class extends Rule {
  hasInvalidStyle;
  constructor(options) {
    super({ ...defaults$r, ...options });
    this.hasInvalidStyle = parseStyle$1(this.options.style);
  }
  static schema() {
    return {
      style: {
        enum: ["empty", "omit"],
        type: "string"
      }
    };
  }
  documentation() {
    return {
      description: "Require a specific style for attributes with empty values.",
      url: "https://html-validate.org/rules/attribute-empty-style.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      walk.depthFirst(doc, (node) => {
        const meta = node.meta;
        if (!meta?.attributes) return;
        for (const attr of node.attributes) {
          if (!allowsEmpty(attr, meta.attributes)) {
            continue;
          }
          if (!isEmptyValue(attr)) {
            continue;
          }
          if (!this.hasInvalidStyle(attr)) {
            continue;
          }
          this.report(node, reportMessage(attr, this.options.style), attr.keyLocation);
        }
      });
    });
  }
};
function allowsEmpty(attr, rules) {
  const meta = rules[attr.key];
  return Boolean(meta?.omit);
}
function isEmptyValue(attr) {
  if (attr.isDynamic) {
    return false;
  }
  return attr.value === null || attr.value === "";
}
function parseStyle$1(style) {
  switch (style.toLowerCase()) {
    case "omit":
      return (attr) => attr.value !== null;
    case "empty":
      return (attr) => attr.value !== "";
    /* istanbul ignore next: covered by schema validation */
    default:
      throw new Error(`Invalid style "${style}" for "attribute-empty-style" rule`);
  }
}
function reportMessage(attr, style) {
  const key = attr.key;
  switch (style.toLowerCase()) {
    case "omit":
      return `Attribute "${key}" should omit value`;
    case "empty":
      return `Attribute "${key}" value should be empty string`;
  }
  return "";
}
function ruleDescription(context) {
  const { tagName, attr, details } = context;
  return `The \`${attr}\` attribute cannot be used on \`${tagName}\` in this context: ${details}`;
}
var AttributeMisuse = class extends Rule {
  documentation(context) {
    return {
      description: ruleDescription(context),
      url: "https://html-validate.org/rules/attribute-misuse.html"
    };
  }
  setup() {
    this.on("element:ready", (event) => {
      const { target } = event;
      const { meta } = target;
      if (!meta) {
        return;
      }
      for (const attr of target.attributes) {
        const key = attr.key.toLowerCase();
        this.validateAttr(target, attr, meta.attributes[key]);
      }
    });
  }
  validateAttr(node, attr, meta) {
    if (!meta?.allowed) {
      return;
    }
    const details = meta.allowed(node._adapter, attr.value);
    if (details) {
      this.report({
        node,
        message: `"{{ attr }}" attribute cannot be used on {{ tagName }} in this context: {{ details }}`,
        location: attr.keyLocation,
        context: {
          tagName: node.annotatedName,
          attr: attr.key,
          details
        }
      });
    }
  }
};
function parsePattern(pattern) {
  switch (pattern) {
    case "kebabcase":
      return { regexp: /^[a-z][a-z0-9]*(?:-[a-z0-9]+)*$/, description: pattern };
    case "camelcase":
      return { regexp: /^[a-z][a-zA-Z0-9]*$/, description: pattern };
    case "snakecase":
    case "underscore":
      return { regexp: /^[a-z][a-z0-9]*(?:_[a-z0-9]+)*$/, description: pattern };
    case "bem": {
      const block = "[a-z][a-z0-9]*(?:-[a-z0-9]+)*";
      const element = "(?:__[a-z0-9]+(?:-[a-z0-9]+)*)?";
      const modifier = "(?:--[a-z0-9]+(?:-[a-z0-9]+)*){0,2}";
      return {
        regexp: new RegExp(`^${block}${element}${modifier}$`),
        description: pattern
      };
    }
    default: {
      const regexp2 = new RegExp(pattern);
      return { regexp: regexp2, description: regexp2.toString() };
    }
  }
}
function toArray$2(value) {
  return Array.isArray(value) ? value : [value];
}
var BasePatternRule = class extends Rule {
  /** Attribute being tested */
  attr;
  /** Parsed configured patterns */
  patterns;
  /**
   * @param attr - Attribute holding the value.
   * @param options - Rule options with defaults expanded.
   */
  constructor(attr, options) {
    super(options);
    const { pattern } = this.options;
    this.attr = attr;
    this.patterns = toArray$2(pattern).map((it) => parsePattern(it));
  }
  static schema() {
    return {
      pattern: {
        oneOf: [{ type: "array", items: { type: "string" }, minItems: 1 }, { type: "string" }]
      }
    };
  }
  description(context) {
    const { attr, patterns } = this;
    const { value } = context;
    const lead = patterns.length === 1 ? `The \`${attr}\` attribute value \`"${value}"\` does not match the configured pattern.` : `The \`${attr}\` attribute value \`"${value}"\` does not match either of the configured patterns.`;
    return [
      lead,
      "For consistency within the codebase the `${attr}` is required to match one or more of the following patterns:",
      "",
      ...patterns.map((it) => `- \`${it.description}\``)
    ].join("\n");
  }
  validateValue(node, value, location) {
    const { attr, patterns } = this;
    const matches = patterns.some((it) => it.regexp.test(value));
    if (matches) {
      return;
    }
    const allowed = naturalJoin(patterns.map((it) => `"${it.description}"`));
    const message = patterns.length === 1 ? `${attr} "${value}" does not match the configured pattern ${allowed}` : `${attr} "${value}" does not match either of the configured patterns: ${allowed}`;
    this.report({
      node,
      message,
      location,
      context: {
        value
      }
    });
  }
};
var defaults$q = {
  pattern: "kebabcase"
};
var ClassPattern = class extends BasePatternRule {
  constructor(options) {
    super("class", { ...defaults$q, ...options });
  }
  static schema() {
    return BasePatternRule.schema();
  }
  documentation(context) {
    return {
      description: this.description(context),
      url: "https://html-validate.org/rules/class-pattern.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      const { target, key, value, valueLocation } = event;
      if (key.toLowerCase() !== "class") {
        return;
      }
      const classes = new DOMTokenList(value, valueLocation);
      for (const { item, location } of classes.iterator()) {
        this.validateValue(target, item, location);
      }
    });
  }
};
var CloseAttr = class extends Rule {
  documentation() {
    return {
      description: "HTML disallows end tags to have attributes.",
      url: "https://html-validate.org/rules/close-attr.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      if (!event.target) {
        return;
      }
      if (event.previous === event.target) {
        return;
      }
      const node = event.target;
      if (Object.keys(node.attributes).length > 0) {
        const first = node.attributes[0];
        this.report(null, "Close tags cannot have attributes", first.keyLocation);
      }
    });
  }
};
function* ancestors(node) {
  if (!node) {
    return;
  }
  let ancestor = node;
  while (ancestor && !ancestor.isRootElement()) {
    yield ancestor;
    ancestor = ancestor.parent;
  }
  if (ancestor) {
    yield ancestor;
  }
}
function findAncestor(node, predicate) {
  for (const ancestor of ancestors(node)) {
    if (predicate(ancestor)) {
      return ancestor;
    }
  }
  return null;
}
var CloseOrder = class extends Rule {
  documentation() {
    return {
      description: "HTML requires elements to be closed in the same order as they were opened.",
      url: "https://html-validate.org/rules/close-order.html"
    };
  }
  setup() {
    let reported;
    this.on("parse:begin", () => {
      reported = /* @__PURE__ */ new Set();
    });
    this.on("tag:end", (event) => {
      const current = event.target;
      const active = event.previous;
      if (current) {
        return;
      }
      for (const ancestor of ancestors(active)) {
        if (ancestor.isRootElement() || reported.has(ancestor.unique)) {
          continue;
        }
        this.report(ancestor, `Unclosed element '<${ancestor.tagName}>'`, ancestor.location);
        reported.add(ancestor.unique);
      }
    });
    this.on("tag:end", (event) => {
      const current = event.target;
      const active = event.previous;
      if (!current) {
        return;
      }
      if (current.voidElement) {
        return;
      }
      if (active.closed === NodeClosed.ImplicitClosed) {
        return;
      }
      if (active.isRootElement()) {
        const location = {
          filename: current.location.filename,
          line: current.location.line,
          column: current.location.column,
          offset: current.location.offset,
          size: current.tagName.length + 1
        };
        this.report(null, `Stray end tag '</${current.tagName}>'`, location);
        return;
      }
      if (current.tagName === active.tagName) {
        return;
      }
      const ancestor = findAncestor(active.parent, (node) => node.is(current.tagName));
      if (ancestor && !ancestor.isRootElement()) {
        for (const element of ancestors(active)) {
          if (ancestor.isSameNode(element)) {
            break;
          }
          if (reported.has(element.unique)) {
            continue;
          }
          this.report(element, `Unclosed element '<${element.tagName}>'`, element.location);
          reported.add(element.unique);
        }
        this.report(
          null,
          `End tag '</${current.tagName}>' seen but there were open elements`,
          current.location
        );
        reported.add(ancestor.unique);
      } else {
        this.report(null, `Stray end tag '</${current.tagName}>'`, current.location);
      }
    });
  }
};
var defaults$p = {
  include: null,
  exclude: null
};
var Deprecated = class extends Rule {
  constructor(options) {
    super({ ...defaults$p, ...options });
  }
  static schema() {
    return {
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      }
    };
  }
  documentation(context) {
    const text = [];
    if (context.source) {
      const source = prettySource(context.source);
      const message = `The \`<$tagname>\` element is deprecated ${source} and should not be used in new code.`;
      text.push(message);
    } else {
      const message = `The \`<$tagname>\` element is deprecated and should not be used in new code.`;
      text.push(message);
    }
    if (context.documentation) {
      text.push(context.documentation);
    }
    const doc = {
      description: text.map((cur) => cur.replace(/\$tagname/g, context.tagName)).join("\n\n"),
      url: "https://html-validate.org/rules/deprecated.html"
    };
    return doc;
  }
  setup() {
    this.on("tag:start", (event) => {
      const node = event.target;
      if (node.meta === null) {
        return;
      }
      const deprecated = node.meta.deprecated;
      if (!deprecated) {
        return;
      }
      if (this.isKeywordIgnored(node.tagName)) {
        return;
      }
      const location = sliceLocation(event.location, 1);
      if (typeof deprecated === "string") {
        this.reportString(deprecated, node, location);
      } else if (typeof deprecated === "boolean") {
        this.reportBoolean(node, location);
      } else {
        this.reportObject(deprecated, node, location);
      }
    });
  }
  reportString(deprecated, node, location) {
    const context = { tagName: node.tagName };
    const message = `<${node.tagName}> is deprecated: ${deprecated}`;
    this.report(node, message, location, context);
  }
  reportBoolean(node, location) {
    const context = { tagName: node.tagName };
    const message = `<${node.tagName}> is deprecated`;
    this.report(node, message, location, context);
  }
  reportObject(deprecated, node, location) {
    const context = { ...deprecated, tagName: node.tagName };
    const notice = deprecated.message ? `: ${deprecated.message}` : "";
    const message = `<${node.tagName}> is deprecated${notice}`;
    this.report(node, message, location, context);
  }
};
function prettySource(source) {
  const match2 = /html(\d)(\d)?/.exec(source);
  if (match2) {
    const [, ...parts] = match2;
    const version2 = parts.filter(Boolean).join(".");
    return `in HTML ${version2}`;
  }
  switch (source) {
    case "whatwg":
      return "in HTML Living Standard";
    case "non-standard":
      return "and non-standard";
    default:
      return `by ${source}`;
  }
}
var DeprecatedRule = class extends Rule {
  documentation(context) {
    const preamble = context ? `The rule "${context}"` : "This rule";
    return {
      description: `${preamble} is deprecated and should not be used any longer, consult documentation for further information.`,
      url: "https://html-validate.org/rules/deprecated-rule.html"
    };
  }
  setup() {
    this.on("config:ready", (event) => {
      for (const rule of this.getDeprecatedRules(event)) {
        if (rule.getSeverity() > Severity.DISABLED) {
          this.report(null, `Usage of deprecated rule "${rule.name}"`, null, rule.name);
        }
      }
    });
  }
  getDeprecatedRules(event) {
    const rules = Object.values(event.rules);
    return rules.filter((rule) => rule.deprecated);
  }
};
var NoStyleTag$1 = class NoStyleTag extends Rule {
  documentation() {
    return {
      description: [
        'HTML5 documents should use the "html" doctype (short `form`, not legacy string):',
        "",
        "```html",
        "<!DOCTYPE html>",
        "```"
      ].join("\n"),
      url: "https://html-validate.org/rules/doctype-html.html"
    };
  }
  setup() {
    this.on("doctype", (event) => {
      const doctype = event.value.toLowerCase();
      if (doctype !== "html") {
        this.report(null, 'doctype should be "html"', event.valueLocation);
      }
    });
  }
};
var defaults$o = {
  style: "uppercase"
};
var DoctypeStyle = class extends Rule {
  constructor(options) {
    super({ ...defaults$o, ...options });
  }
  static schema() {
    return {
      style: {
        enum: ["lowercase", "uppercase"],
        type: "string"
      }
    };
  }
  documentation(context) {
    return {
      description: `While DOCTYPE is case-insensitive in the standard the current configuration requires it to be ${context.style}`,
      url: "https://html-validate.org/rules/doctype-style.html"
    };
  }
  setup() {
    this.on("doctype", (event) => {
      if (this.options.style === "uppercase" && event.tag !== "DOCTYPE") {
        this.report(null, "DOCTYPE should be uppercase", event.location, this.options);
      }
      if (this.options.style === "lowercase" && event.tag !== "doctype") {
        this.report(null, "DOCTYPE should be lowercase", event.location, this.options);
      }
    });
  }
};
var defaults$n = {
  style: "lowercase"
};
var ElementCase = class extends Rule {
  style;
  constructor(options) {
    super({ ...defaults$n, ...options });
    this.style = new CaseStyle(this.options.style, "element-case");
  }
  static schema() {
    const styleEnum = ["lowercase", "uppercase", "pascalcase", "camelcase"];
    return {
      style: {
        anyOf: [
          {
            enum: styleEnum,
            type: "string"
          },
          {
            items: {
              enum: styleEnum,
              type: "string"
            },
            type: "array"
          }
        ]
      }
    };
  }
  documentation() {
    const { style } = this.options;
    return {
      description: Array.isArray(style) ? [`Element tagname must be in one of:`, "", ...style.map((it) => `- ${it}`)].join("\n") : `Element tagname must be in ${style}.`,
      url: "https://html-validate.org/rules/element-case.html"
    };
  }
  setup() {
    this.on("tag:start", (event) => {
      const { target, location } = event;
      this.validateCase(target, location);
    });
    this.on("tag:end", (event) => {
      const { target, previous } = event;
      this.validateMatchingCase(previous, target);
    });
  }
  validateCase(target, targetLocation) {
    const letters = target.tagName.replace(/[^a-z]+/gi, "");
    if (!this.style.match(letters)) {
      const location = sliceLocation(targetLocation, 1);
      this.report(target, `Element "${target.tagName}" should be ${this.style.name}`, location);
    }
  }
  validateMatchingCase(start, end) {
    if (!start || !end || !start.tagName || !end.tagName) {
      return;
    }
    if (start.tagName.toLowerCase() !== end.tagName.toLowerCase()) {
      return;
    }
    if (start.tagName !== end.tagName) {
      this.report(start, "Start and end tag must not differ in casing", end.location);
    }
  }
};
var defaults$m = {
  pattern: "^[a-z][a-z0-9\\-._]*-[a-z0-9\\-._]*$",
  whitelist: [],
  blacklist: []
};
var ElementName = class extends Rule {
  pattern;
  constructor(options) {
    super({ ...defaults$m, ...options });
    this.pattern = new RegExp(this.options.pattern);
  }
  static schema() {
    return {
      blacklist: {
        items: {
          type: "string"
        },
        type: "array"
      },
      pattern: {
        type: "string"
      },
      whitelist: {
        items: {
          type: "string"
        },
        type: "array"
      }
    };
  }
  documentation(context) {
    return {
      description: this.documentationMessages(context).join("\n"),
      url: "https://html-validate.org/rules/element-name.html"
    };
  }
  documentationMessages(context) {
    if (context.blacklist.includes(context.tagName)) {
      return [
        `<${context.tagName}> is blacklisted by the project configuration.`,
        "",
        "The following names are blacklisted:",
        ...context.blacklist.map((cur) => `- ${cur}`)
      ];
    }
    if (context.pattern !== defaults$m.pattern) {
      return [
        `<${context.tagName}> is not a valid element name. This project is configured to only allow names matching the following regular expression:`,
        "",
        `- \`${context.pattern}\``
      ];
    }
    return [
      `<${context.tagName}> is not a valid element name. If this is a custom element HTML requires the name to follow these rules:`,
      "",
      "- The name must begin with `a-z`",
      "- The name must include a hyphen `-`",
      "- It may include alphanumerical characters `a-z0-9` or hyphens `-`, dots `.` or underscores `_`."
    ];
  }
  setup() {
    const xmlns2 = /^(.+):.+$/;
    this.on("tag:start", (event) => {
      const target = event.target;
      const tagName = target.tagName;
      const location = sliceLocation(event.location, 1);
      const context = {
        tagName,
        pattern: this.options.pattern,
        blacklist: this.options.blacklist
      };
      if (this.options.blacklist.includes(tagName)) {
        this.report(target, `<${tagName}> element is blacklisted`, location, context);
      }
      if (target.meta) {
        return;
      }
      if (xmlns2.exec(tagName)) {
        return;
      }
      if (this.options.whitelist.includes(tagName)) {
        return;
      }
      if (!tagName.match(this.pattern)) {
        this.report(target, `<${tagName}> is not a valid element name`, location, context);
      }
    });
  }
};
function isNativeTemplate(node) {
  const { tagName, meta } = node;
  return Boolean(tagName === "template" && meta?.templateRoot && meta?.scriptSupporting);
}
function getTransparentChildren(node, transparent) {
  if (typeof transparent === "boolean") {
    return node.childElements;
  } else {
    return node.childElements.filter((it) => {
      return transparent.some((category) => {
        return Validator.validatePermittedCategory(it, category, false);
      });
    });
  }
}
function getRuleDescription$2(context) {
  switch (context.kind) {
    case "content":
      return [
        `The \`${context.child}\` element is not permitted as content under the parent \`${context.parent}\` element.`
      ];
    case "descendant":
      return [
        `The \`${context.child}\` element is not permitted as a descendant of the \`${context.ancestor}\` element.`
      ];
  }
}
var ElementPermittedContent = class extends Rule {
  documentation(context) {
    return {
      description: getRuleDescription$2(context).join("\n"),
      url: "https://html-validate.org/rules/element-permitted-content.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      walk.depthFirst(doc, (node) => {
        const parent2 = node.parent;
        if (!parent2) {
          return;
        }
        [
          () => this.validatePermittedContent(node, parent2),
          () => this.validatePermittedDescendant(node, parent2)
        ].some((fn) => fn());
      });
    });
  }
  validatePermittedContent(cur, parent2) {
    if (!parent2.meta) {
      return false;
    }
    const rules = parent2.meta.permittedContent ?? null;
    return this.validatePermittedContentImpl(cur, parent2, rules);
  }
  validatePermittedContentImpl(cur, parent2, rules) {
    if (!Validator.validatePermitted(cur, rules)) {
      const child = `<${cur.tagName}>`;
      const message = `${child} element is not permitted as content under ${parent2.annotatedName}`;
      const context = {
        kind: "content",
        parent: parent2.annotatedName,
        child
      };
      this.report(cur, message, null, context);
      return true;
    }
    if (cur.meta?.transparent) {
      const children = getTransparentChildren(cur, cur.meta.transparent);
      return children.map((child) => {
        return this.validatePermittedContentImpl(child, parent2, rules);
      }).some(Boolean);
    }
    return false;
  }
  validatePermittedDescendant(node, parent2) {
    for (let cur = parent2; cur && !cur.isRootElement() && !isNativeTemplate(cur); cur = /* istanbul ignore next */
    cur.parent ?? null) {
      const meta = cur.meta;
      if (!meta) {
        continue;
      }
      const rules = meta.permittedDescendants;
      if (!rules) {
        continue;
      }
      if (Validator.validatePermitted(node, rules)) {
        continue;
      }
      const child = `<${node.tagName}>`;
      const ancestor = cur.annotatedName;
      const message = `${child} element is not permitted as a descendant of ${ancestor}`;
      const context = {
        kind: "descendant",
        ancestor,
        child
      };
      this.report(node, message, null, context);
      return true;
    }
    return false;
  }
};
var ElementPermittedOccurrences = class extends Rule {
  documentation() {
    return {
      description: "Some elements may only be used a fixed amount of times in given context.",
      url: "https://html-validate.org/rules/element-permitted-occurrences.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      walk.depthFirst(doc, (node) => {
        if (!node.meta) {
          return;
        }
        const rules = node.meta.permittedContent;
        if (!rules) {
          return;
        }
        Validator.validateOccurrences(
          node.childElements,
          rules,
          (child, category) => {
            this.report(
              child,
              `Element <${category}> can only appear once under ${node.annotatedName}`
            );
          }
        );
      });
    });
  }
};
var ElementPermittedOrder = class extends Rule {
  documentation() {
    return {
      description: "Some elements has a specific order the children must use.",
      url: "https://html-validate.org/rules/element-permitted-order.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      walk.depthFirst(doc, (node) => {
        if (!node.meta) {
          return;
        }
        const rules = node.meta.permittedOrder;
        if (!rules) {
          return;
        }
        Validator.validateOrder(
          node.childElements,
          rules,
          (child, prev) => {
            this.report(
              child,
              `Element <${child.tagName}> must be used before <${prev.tagName}> in this context`
            );
          }
        );
      });
    });
  }
};
function isCategoryOrTag(value) {
  return typeof value === "string";
}
function isCategory$1(value) {
  return value.startsWith("@");
}
function formatCategoryOrTag(value) {
  return isCategory$1(value) ? value.slice(1) : `<${value}>`;
}
function isFormattable(rules) {
  return rules.length > 0 && rules.every(isCategoryOrTag);
}
function getRuleDescription$1(context) {
  const { child, parent: parent2, rules } = context;
  const preamble = `The \`${child}\` element cannot have a \`${parent2}\` element as parent.`;
  if (isFormattable(rules)) {
    const allowed = rules.filter(isCategoryOrTag).map((it) => {
      if (isCategory$1(it)) {
        return `- any ${it.slice(1)} element`;
      } else {
        return `- \`<${it}>\``;
      }
    });
    return [preamble, "", "Allowed parents one of:", "", ...allowed];
  } else {
    return [preamble];
  }
}
function formatMessage$1(node, parent2, rules) {
  const nodeName = node.annotatedName;
  const parentName = parent2.annotatedName;
  if (!isFormattable(rules)) {
    return `${nodeName} element cannot have ${parentName} element as parent`;
  }
  const allowed = naturalJoin(rules.filter(isCategoryOrTag).map(formatCategoryOrTag));
  return `${nodeName} element requires a ${allowed} element as parent`;
}
var ElementPermittedParent = class extends Rule {
  documentation(context) {
    return {
      description: getRuleDescription$1(context).join("\n"),
      url: "https://html-validate.org/rules/element-permitted-parent.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      walk.depthFirst(doc, (node) => {
        const parent2 = node.parent;
        if (!parent2) {
          return;
        }
        if (parent2.isRootElement()) {
          return;
        }
        if (parent2.tagName === node.tagName) {
          return;
        }
        const rules = node.meta?.permittedParent;
        if (!rules) {
          return false;
        }
        if (Validator.validatePermitted(parent2, rules)) {
          return;
        }
        const message = formatMessage$1(node, parent2, rules);
        const context = {
          parent: parent2.annotatedName,
          child: node.annotatedName,
          rules
        };
        this.report(node, message, null, context);
      });
    });
  }
};
function isTagnameOnly(value) {
  return Boolean(/^[a-zA-Z0-9-]+$/.exec(value));
}
function getRuleDescription(context) {
  const escaped = context.ancestor.map((it) => `\`${it}\``);
  return [`The \`${context.child}\` element requires a ${naturalJoin(escaped)} ancestor.`];
}
var ElementRequiredAncestor = class extends Rule {
  documentation(context) {
    return {
      description: getRuleDescription(context).join("\n"),
      url: "https://html-validate.org/rules/element-required-ancestor.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      walk.depthFirst(doc, (node) => {
        const parent2 = node.parent;
        if (!parent2) {
          return;
        }
        this.validateRequiredAncestors(node);
      });
    });
  }
  validateRequiredAncestors(node) {
    if (!node.meta) {
      return;
    }
    const rules = node.meta.requiredAncestors;
    if (!rules) {
      return;
    }
    if (Validator.validateAncestors(node, rules)) {
      return;
    }
    const ancestor = rules.map((it) => isTagnameOnly(it) ? `<${it}>` : `"${it}"`);
    const child = `<${node.tagName}>`;
    const message = `<${node.tagName}> element requires a ${naturalJoin(ancestor)} ancestor`;
    const context = {
      ancestor,
      child
    };
    this.report(node, message, null, context);
  }
};
var ElementRequiredAttributes = class extends Rule {
  documentation(context) {
    const docs = {
      description: "Element is missing a required attribute",
      url: "https://html-validate.org/rules/element-required-attributes.html"
    };
    if (context) {
      docs.description = `The <${context.element}> element is required to have a "${context.attribute}" attribute.`;
    }
    return docs;
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.previous;
      const meta = node.meta;
      if (!meta?.attributes) {
        return;
      }
      for (const [key, attr] of Object.entries(meta.attributes)) {
        if (!attr.required) {
          continue;
        }
        if (node.hasAttribute(key)) continue;
        const context = {
          element: node.tagName,
          attribute: key
        };
        this.report(
          node,
          `${node.annotatedName} is missing required "${key}" attribute`,
          node.location,
          context
        );
      }
    });
  }
};
function isCategory(value) {
  return value.startsWith("@");
}
var ElementRequiredContent = class extends Rule {
  documentation(context) {
    const { element, missing } = context;
    return {
      description: `The \`${element}\` element requires a \`${missing}\` to be present as content.`,
      url: "https://html-validate.org/rules/element-required-content.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      walk.depthFirst(doc, (node) => {
        if (!node.meta) {
          return;
        }
        const rules = node.meta.requiredContent;
        if (!rules) {
          return;
        }
        for (const missing of Validator.validateRequiredContent(node, rules)) {
          const context = {
            element: node.annotatedName,
            missing: `<${missing}>`
          };
          const tag = isCategory(missing) ? `${missing.slice(1)} element` : `<${missing}>`;
          const message = `${node.annotatedName} element must have ${tag} as content`;
          this.report(node, message, null, context);
        }
      });
    });
  }
};
var selector = ["h1", "h2", "h3", "h4", "h5", "h6"].join(",");
function hasImgAltText$1(node) {
  if (node.is("img")) {
    return hasAltText(node);
  } else if (node.is("svg")) {
    return node.textContent.trim() !== "";
  }
  return false;
}
var EmptyHeading = class extends Rule {
  documentation() {
    return {
      description: `Assistive technology such as screen readers require textual content in headings. Whitespace only is considered empty.`,
      url: "https://html-validate.org/rules/empty-heading.html"
    };
  }
  setup() {
    this.on("dom:ready", ({ document }) => {
      const headings = document.querySelectorAll(selector);
      for (const heading of headings) {
        this.validateHeading(heading);
      }
    });
  }
  validateHeading(heading) {
    const images = heading.querySelectorAll("img, svg");
    for (const child of images) {
      if (hasImgAltText$1(child)) {
        return;
      }
    }
    switch (classifyNodeText(heading, { ignoreHiddenRoot: true })) {
      case TextClassification.DYNAMIC_TEXT:
      case TextClassification.STATIC_TEXT:
        break;
      case TextClassification.EMPTY_TEXT:
        this.report(heading, `<${heading.tagName}> cannot be empty, must have text content`);
        break;
    }
  }
};
var EmptyTitle = class extends Rule {
  documentation() {
    return {
      description: [
        "The `<title>` element cannot be empty, it must have textual content.",
        "",
        "It is used to describe the document and is shown in the browser tab and titlebar.",
        "WCAG and SEO requires a descriptive title and preferably unique within the site.",
        "",
        "Whitespace is ignored."
      ].join("\n"),
      url: "https://html-validate.org/rules/empty-title.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.previous;
      if (node.tagName !== "title") return;
      switch (classifyNodeText(node)) {
        case TextClassification.DYNAMIC_TEXT:
        case TextClassification.STATIC_TEXT:
          break;
        case TextClassification.EMPTY_TEXT:
          {
            const message = `<${node.tagName}> cannot be empty, must have text content`;
            this.report(node, message, node.location);
          }
          break;
      }
    });
  }
};
var defaults$l = {
  allowArrayBrackets: true,
  allowCheckboxDefault: true,
  shared: ["radio", "button", "reset", "submit"]
};
var UNIQUE_CACHE_KEY = Symbol("form-elements-unique");
var SHARED_CACHE_KEY = Symbol("form-elements-shared");
function haveName(name) {
  return typeof name === "string" && name !== "";
}
function allowSharedName(node, shared) {
  const type2 = node.getAttribute("type");
  return Boolean(type2?.valueMatches(shared, false));
}
function isInputHidden(element) {
  return element.is("input") && element.getAttributeValue("type") === "hidden";
}
function isInputCheckbox(element) {
  return element.is("input") && element.getAttributeValue("type") === "checkbox";
}
function isCheckboxWithDefault(control, previous, options) {
  const { allowCheckboxDefault } = options;
  if (!allowCheckboxDefault) {
    return false;
  }
  if (!previous.potentialHiddenDefault) {
    return false;
  }
  if (!isInputCheckbox(control)) {
    return false;
  }
  return true;
}
function getDocumentation(context) {
  const trailer = "Each form control must have a unique name.";
  const { name } = context;
  switch (context.kind) {
    case "duplicate":
      return [`Duplicate form control name "${name}"`, trailer].join("\n");
    case "mix":
      return [
        `Form control name cannot mix regular name "{{ name }}" with array brackets "{{ name }}[]"`,
        trailer
      ].join("\n");
  }
}
var FormDupName = class extends Rule {
  constructor(options) {
    super({ ...defaults$l, ...options });
  }
  static schema() {
    return {
      allowArrayBrackets: {
        type: "boolean"
      },
      allowCheckboxDefault: {
        type: "boolean"
      },
      shared: {
        type: "array",
        items: {
          enum: ["radio", "checkbox", "submit", "button", "reset"]
        }
      }
    };
  }
  documentation(context) {
    return {
      description: getDocumentation(context),
      url: "https://html-validate.org/rules/form-dup-name.html"
    };
  }
  setup() {
    const selector2 = this.getSelector();
    const { shared } = this.options;
    this.on("dom:ready", (event) => {
      const { document } = event;
      const controls = document.querySelectorAll(selector2);
      const [sharedControls, uniqueControls] = partition(controls, (it) => {
        return allowSharedName(it, shared);
      });
      for (const control of uniqueControls) {
        const attr = control.getAttribute("name");
        const name = attr?.value;
        if (!attr || !haveName(name)) {
          continue;
        }
        const group = control.closest("form, template") ?? document.root;
        this.validateUniqueName(control, group, attr, name);
      }
      for (const control of sharedControls) {
        const attr = control.getAttribute("name");
        const name = attr?.value;
        if (!attr || !haveName(name)) {
          continue;
        }
        const group = control.closest("form, template") ?? document.root;
        this.validateSharedName(control, group, attr, name);
      }
    });
  }
  validateUniqueName(control, group, attr, name) {
    const elements = this.getUniqueElements(group);
    const { allowArrayBrackets } = this.options;
    if (allowArrayBrackets) {
      const isarray = name.endsWith("[]");
      const basename = isarray ? name.slice(0, -2) : name;
      const details = elements.get(basename);
      if (details && details.array !== isarray) {
        const context = {
          name: basename,
          kind: "mix"
        };
        this.report({
          node: control,
          location: attr.valueLocation,
          message: 'Cannot mix "{{ name }}[]" and "{{ name }}"',
          context
        });
        return;
      }
      if (!details && isarray) {
        elements.set(basename, {
          array: true,
          potentialHiddenDefault: false
        });
      }
      if (isarray) {
        return;
      }
    }
    const previous = elements.get(name);
    if (previous) {
      if (isCheckboxWithDefault(control, previous, this.options)) {
        previous.potentialHiddenDefault = false;
        return;
      }
      const context = {
        name,
        kind: "duplicate"
      };
      this.report({
        node: control,
        location: attr.valueLocation,
        message: 'Duplicate form control name "{{ name }}"',
        context
      });
    } else {
      elements.set(name, {
        array: false,
        potentialHiddenDefault: isInputHidden(control)
      });
    }
  }
  validateSharedName(control, group, attr, name) {
    const uniqueElements = this.getUniqueElements(group);
    const sharedElements = this.getSharedElements(group);
    const type2 = control.getAttributeValue("type") ?? "";
    if (uniqueElements.has(name) || sharedElements.has(name) && sharedElements.get(name) !== type2) {
      const context = {
        name,
        kind: "duplicate"
      };
      this.report({
        node: control,
        location: attr.valueLocation,
        message: 'Duplicate form control name "{{ name }}"',
        context
      });
    }
    sharedElements.set(name, type2);
  }
  getSelector() {
    const tags = this.getTagsWithProperty("formAssociated").filter((it) => {
      return this.isListedElement(it);
    });
    return tags.join(", ");
  }
  isListedElement(tagName) {
    const meta = this.getMetaFor(tagName);
    if (!meta?.formAssociated) {
      return false;
    }
    return meta.formAssociated.listed;
  }
  getUniqueElements(group) {
    const existing = group.cacheGet(UNIQUE_CACHE_KEY);
    if (existing) {
      return existing;
    } else {
      const elements = /* @__PURE__ */ new Map();
      group.cacheSet(UNIQUE_CACHE_KEY, elements);
      return elements;
    }
  }
  getSharedElements(group) {
    const existing = group.cacheGet(SHARED_CACHE_KEY);
    if (existing) {
      return existing;
    } else {
      const elements = /* @__PURE__ */ new Map();
      group.cacheSet(SHARED_CACHE_KEY, elements);
      return elements;
    }
  }
};
var defaults$k = {
  allowMultipleH1: false,
  minInitialRank: "h1",
  sectioningRoots: ["dialog", '[role="dialog"]', '[role="alertdialog"]']
};
function isRelevant$5(event) {
  const node = event.target;
  return Boolean(node.meta?.heading);
}
function extractLevel(node) {
  const match2 = /^[hH](\d)$/.exec(node.tagName);
  if (match2) {
    return parseInt(match2[1], 10);
  } else {
    return null;
  }
}
function parseMaxInitial(value) {
  if (value === false || value === "any") {
    return 6;
  }
  const match2 = /^h(\d)$/.exec(value);
  if (!match2) {
    return 1;
  }
  return parseInt(match2[1], 10);
}
var HeadingLevel = class extends Rule {
  minInitialRank;
  sectionRoots;
  stack = [];
  constructor(options) {
    super({ ...defaults$k, ...options });
    this.minInitialRank = parseMaxInitial(this.options.minInitialRank);
    this.sectionRoots = this.options.sectioningRoots.map((it) => new Compound(it));
    this.stack.push({
      node: null,
      current: 0,
      h1Count: 0
    });
  }
  static schema() {
    return {
      allowMultipleH1: {
        type: "boolean"
      },
      minInitialRank: {
        enum: ["h1", "h2", "h3", "h4", "h5", "h6", "any", false]
      },
      sectioningRoots: {
        items: {
          type: "string"
        },
        type: "array"
      }
    };
  }
  documentation() {
    const text = [];
    const modality = this.minInitialRank > 1 ? "should" : "must";
    text.push(`Headings ${modality} start at <h1> and can only increase one level at a time.`);
    text.push("The headings should form a table of contents and make sense on its own.");
    if (!this.options.allowMultipleH1) {
      text.push("");
      text.push(
        "Under the current configuration only a single <h1> can be present at a time in the document."
      );
    }
    return {
      description: text.join("\n"),
      url: "https://html-validate.org/rules/heading-level.html"
    };
  }
  setup() {
    this.on("tag:start", isRelevant$5, (event) => {
      this.onTagStart(event);
    });
    this.on("tag:ready", (event) => {
      this.onTagReady(event);
    });
    this.on("tag:end", (event) => {
      this.onTagClose(event);
    });
  }
  onTagStart(event) {
    const level = extractLevel(event.target);
    if (!level) return;
    const root = this.getCurrentRoot();
    if (!this.options.allowMultipleH1 && level === 1) {
      if (root.h1Count >= 1) {
        const location = sliceLocation(event.location, 1);
        this.report(event.target, `Multiple <h1> are not allowed`, location);
        return;
      }
      root.h1Count++;
    }
    if (level <= root.current) {
      root.current = level;
      return;
    }
    this.checkLevelIncrementation(root, event, level);
    root.current = level;
  }
  /**
   * Validate heading level was only incremented by one.
   */
  checkLevelIncrementation(root, event, level) {
    const expected = root.current + 1;
    if (level === expected) {
      return;
    }
    const isInitial = this.stack.length === 1 && expected === 1;
    if (isInitial && level <= this.minInitialRank) {
      return;
    }
    const location = sliceLocation(event.location, 1);
    if (root.current > 0) {
      const expectedTag = `<h${String(expected)}>`;
      const actualTag = `<h${String(level)}>`;
      const msg = `Heading level can only increase by one, expected ${expectedTag} but got ${actualTag}`;
      this.report(event.target, msg, location);
    } else {
      this.checkInitialLevel(event, location, level, expected);
    }
  }
  checkInitialLevel(event, location, level, expected) {
    const expectedTag = `<h${String(expected)}>`;
    const actualTag = `<h${String(level)}>`;
    if (this.stack.length === 1) {
      const msg = this.minInitialRank > 1 ? `Initial heading level must be <h${String(this.minInitialRank)}> or higher rank but got ${actualTag}` : `Initial heading level must be ${expectedTag} but got ${actualTag}`;
      this.report(event.target, msg, location);
    } else {
      const prevRoot = this.getPrevRoot();
      const prevRootExpected = prevRoot.current + 1;
      if (level > prevRootExpected) {
        if (expected === prevRootExpected) {
          const msg = `Initial heading level for sectioning root must be ${expectedTag} but got ${actualTag}`;
          this.report(event.target, msg, location);
        } else {
          const msg = `Initial heading level for sectioning root must be between ${expectedTag} and <h${String(prevRootExpected)}> but got ${actualTag}`;
          this.report(event.target, msg, location);
        }
      }
    }
  }
  /**
   * Check if the current element is a sectioning root and push a new root entry
   * on the stack if it is.
   */
  onTagReady(event) {
    const { target } = event;
    if (this.isSectioningRoot(target)) {
      this.stack.push({
        node: target.unique,
        current: 0,
        h1Count: 0
      });
    }
  }
  /**
   * Check if the current element being closed is the element which opened the
   * current sectioning root, in which case the entry is popped from the stack.
   */
  onTagClose(event) {
    const { previous: target } = event;
    const root = this.getCurrentRoot();
    if (target.unique !== root.node) {
      return;
    }
    this.stack.pop();
  }
  getPrevRoot() {
    return this.stack[this.stack.length - 2];
  }
  getCurrentRoot() {
    return this.stack[this.stack.length - 1];
  }
  isSectioningRoot(node) {
    const context = {
      scope: node
    };
    return this.sectionRoots.some((it) => it.match(node, context));
  }
};
var FOCUSABLE_CACHE = Symbol(isFocusable.name);
function isDisabled(element, meta) {
  if (!meta.formAssociated?.disablable) {
    return false;
  }
  const disabled = element.matches("[disabled]");
  if (disabled) {
    return true;
  }
  const fieldset = element.closest("fieldset[disabled]");
  if (fieldset) {
    return true;
  }
  return false;
}
function isFocusableImpl(element) {
  if (isHTMLHidden(element) || isInert(element) || isStyleHidden(element)) {
    return false;
  }
  const { tabIndex, meta } = element;
  if (tabIndex !== null) {
    return tabIndex >= 0;
  }
  if (!meta) {
    return false;
  }
  if (isDisabled(element, meta)) {
    return false;
  }
  return Boolean(meta.focusable);
}
function isFocusable(element) {
  const cached = element.cacheGet(FOCUSABLE_CACHE);
  if (cached) {
    return cached;
  }
  return element.cacheSet(FOCUSABLE_CACHE, isFocusableImpl(element));
}
var HiddenFocusable = class extends Rule {
  documentation(context) {
    const byParent = context === "parent" ? " In this case it is being hidden by an ancestor with `aria-hidden.`" : "";
    return {
      description: [
        `\`aria-hidden\` cannot be used on focusable elements.${byParent}`,
        "",
        "When focusable elements are hidden with `aria-hidden` they are still reachable using conventional means such as a mouse or keyboard but won't be exposed to assistive technology (AT).",
        "This is often confusing for users of AT such as screenreaders.",
        "",
        "To fix this either:",
        "  - Remove `aria-hidden`.",
        "  - Remove the element from the DOM instead.",
        '  - Use `tabindex="-1"` to remove the element from tab order.',
        "  - Use `hidden`, `inert` or similar means to hide or disable the element."
      ].join("\n"),
      url: "https://html-validate.org/rules/hidden-focusable.html"
    };
  }
  setup() {
    const focusable = this.getTagsWithProperty("focusable");
    const selector2 = ["[tabindex]", ...focusable].join(",");
    this.on("dom:ready", (event) => {
      const { document } = event;
      for (const element of document.querySelectorAll(selector2)) {
        if (isFocusable(element) && isAriaHidden(element)) {
          this.reportElement(element);
        }
      }
    });
  }
  reportElement(element) {
    const attribute = element.getAttribute("aria-hidden");
    const message = attribute ? `aria-hidden cannot be used on focusable elements` : `aria-hidden cannot be used on focusable elements (hidden by ancestor element)`;
    const location = attribute ? attribute.keyLocation : element.location;
    const context = attribute ? "self" : "parent";
    this.report({
      node: element,
      message,
      location,
      context
    });
  }
};
var defaults$j = {
  pattern: "kebabcase"
};
var IdPattern = class extends BasePatternRule {
  constructor(options) {
    super("id", { ...defaults$j, ...options });
  }
  static schema() {
    return BasePatternRule.schema();
  }
  documentation(context) {
    return {
      description: this.description(context),
      url: "https://html-validate.org/rules/id-pattern.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      const { target, key, value, valueLocation } = event;
      if (key.toLowerCase() !== "id") {
        return;
      }
      if (value instanceof DynamicValue) {
        return;
      }
      if (value === null) {
        return;
      }
      this.validateValue(target, value, valueLocation);
    });
  }
};
var restricted = /* @__PURE__ */ new Map([
  ["accept", ["file"]],
  ["alt", ["image"]],
  ["capture", ["file"]],
  ["checked", ["checkbox", "radio"]],
  ["dirname", ["text", "search"]],
  ["height", ["image"]],
  [
    "list",
    [
      "text",
      "search",
      "url",
      "tel",
      "email",
      "date",
      "month",
      "week",
      "time",
      "datetime-local",
      "number",
      "range",
      "color"
    ]
  ],
  ["max", ["date", "month", "week", "time", "datetime-local", "number", "range"]],
  ["maxlength", ["text", "search", "url", "tel", "email", "password"]],
  ["min", ["date", "month", "week", "time", "datetime-local", "number", "range"]],
  ["minlength", ["text", "search", "url", "tel", "email", "password"]],
  ["multiple", ["email", "file"]],
  ["pattern", ["text", "search", "url", "tel", "email", "password"]],
  ["placeholder", ["text", "search", "url", "tel", "email", "password", "number"]],
  [
    "readonly",
    [
      "text",
      "search",
      "url",
      "tel",
      "email",
      "password",
      "date",
      "month",
      "week",
      "time",
      "datetime-local",
      "number"
    ]
  ],
  [
    "required",
    [
      "text",
      "search",
      "url",
      "tel",
      "email",
      "password",
      "date",
      "month",
      "week",
      "time",
      "datetime-local",
      "number",
      "checkbox",
      "radio",
      "file"
    ]
  ],
  ["size", ["text", "search", "url", "tel", "email", "password"]],
  ["src", ["image"]],
  ["step", ["date", "month", "week", "time", "datetime-local", "number", "range"]],
  ["width", ["image"]]
]);
function isInput(event) {
  const { target } = event;
  return target.is("input");
}
var InputAttributes = class extends Rule {
  documentation(context) {
    const { attribute, type: type2 } = context;
    const summary = `Attribute \`${attribute}\` is not allowed on \`<input type="${type2}">\`
`;
    const details = `\`${attribute}\` can only be used when \`type\` is:`;
    const list = restricted.get(attribute)?.map((it) => `- \`${it}\``) ?? [];
    return {
      description: [summary, details, ...list].join("\n"),
      url: "https://html-validate.org/rules/input-attributes.html"
    };
  }
  setup() {
    this.on("tag:ready", isInput, (event) => {
      const { target } = event;
      const type2 = target.getAttribute("type");
      if (!type2 || type2.isDynamic || !type2.value) {
        return;
      }
      const typeValue = type2.value.toString();
      for (const attr of target.attributes) {
        const validTypes = restricted.get(attr.key);
        if (!validTypes) {
          continue;
        }
        if (validTypes.includes(typeValue)) {
          continue;
        }
        const context = {
          attribute: attr.key,
          type: typeValue
        };
        const message = `Attribute "${attr.key}" is not allowed on <input type="${typeValue}">`;
        this.report(target, message, attr.keyLocation, context);
      }
    });
  }
};
var HAS_ACCESSIBLE_TEXT_CACHE = Symbol(hasAccessibleName.name);
function isHidden(node, context) {
  const { reference } = context;
  if (reference?.isSameNode(node)) {
    return false;
  } else {
    return !inAccessibilityTree(node);
  }
}
function hasImgAltText(node, context) {
  if (node.is("img")) {
    return hasAltText(node);
  } else if (node.is("svg")) {
    return node.textContent.trim() !== "";
  } else {
    for (const img of node.querySelectorAll("img, svg")) {
      const hasName = hasAccessibleNameImpl(img, context);
      if (hasName) {
        return true;
      }
    }
    return false;
  }
}
function hasLabel(node) {
  const value = node.getAttributeValue("aria-label") ?? "";
  return Boolean(value.trim());
}
function isLabelledby(node, context) {
  const { document, reference } = context;
  if (reference) {
    return false;
  }
  const ariaLabelledby = node.ariaLabelledby;
  if (ariaLabelledby instanceof DynamicValue) {
    return true;
  }
  if (ariaLabelledby === null) {
    return false;
  }
  return ariaLabelledby.some((id) => {
    const selector2 = generateIdSelector(id);
    return document.querySelectorAll(selector2).some((child) => {
      return hasAccessibleNameImpl(child, {
        document,
        reference: child
      });
    });
  });
}
function hasAccessibleNameImpl(current, context) {
  const { reference } = context;
  if (isHidden(current, context)) {
    return false;
  }
  const ignoreHiddenRoot = Boolean(reference?.isSameNode(current));
  const text = classifyNodeText(current, { accessible: true, ignoreHiddenRoot });
  if (text !== TextClassification.EMPTY_TEXT) {
    return true;
  }
  if (hasImgAltText(current, context)) {
    return true;
  }
  if (hasLabel(current)) {
    return true;
  }
  if (isLabelledby(current, context)) {
    return true;
  }
  return false;
}
function hasAccessibleName(document, current) {
  if (current.cacheExists(HAS_ACCESSIBLE_TEXT_CACHE)) {
    return Boolean(current.cacheGet(HAS_ACCESSIBLE_TEXT_CACHE));
  }
  const result = hasAccessibleNameImpl(current, {
    document,
    reference: null
  });
  return current.cacheSet(HAS_ACCESSIBLE_TEXT_CACHE, result);
}
function isIgnored(node) {
  if (node.is("input")) {
    const type2 = node.getAttributeValue("type")?.toLowerCase();
    const ignored = ["hidden", "submit", "reset", "button"];
    return Boolean(type2 && ignored.includes(type2));
  }
  return false;
}
var InputMissingLabel = class extends Rule {
  documentation() {
    return {
      description: [
        "Each form element must have an a label or accessible name.",
        'Typically this is implemented using a `<label for="..">` element describing the purpose of the form element.',
        "",
        "This can be resolved in one of the following ways:",
        "",
        '  - Use an associated `<label for="..">` element.',
        "  - Use a nested `<label>` as parent element.",
        "  - Use `aria-label` or `aria-labelledby` attributes."
      ].join("\n"),
      url: "https://html-validate.org/rules/input-missing-label.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const root = event.document;
      for (const elem of root.querySelectorAll("input, textarea, select")) {
        this.validateInput(root, elem);
      }
    });
  }
  validateInput(root, elem) {
    if (!inAccessibilityTree(elem)) {
      return;
    }
    if (isIgnored(elem)) {
      return;
    }
    if (hasAccessibleName(root, elem)) {
      return;
    }
    let label = [];
    if ((label = findLabelById(root, elem.id)).length > 0) {
      this.validateLabel(root, elem, label);
      return;
    }
    if ((label = findLabelByParent(elem)).length > 0) {
      this.validateLabel(root, elem, label);
      return;
    }
    if (elem.hasAttribute("aria-label")) {
      this.report(elem, `<${elem.tagName}> element has aria-label but label has no text`);
    } else if (elem.hasAttribute("aria-labelledby")) {
      this.report(
        elem,
        `<${elem.tagName}> element has aria-labelledby but referenced element has no text`
      );
    } else {
      this.report(elem, `<${elem.tagName}> element does not have a <label>`);
    }
  }
  /**
   * Reports error if none of the labels are accessible.
   */
  validateLabel(root, elem, labels) {
    const visible = labels.filter(inAccessibilityTree);
    if (visible.length === 0) {
      this.report(elem, `<${elem.tagName}> element has <label> but <label> element is hidden`);
      return;
    }
    if (!labels.some((label) => hasAccessibleName(root, label))) {
      this.report(elem, `<${elem.tagName}> element has <label> but <label> has no text`);
    }
  }
};
function findLabelById(root, id) {
  if (!id) return [];
  return root.querySelectorAll(`label[for="${id}"]`);
}
function findLabelByParent(el) {
  let cur = el.parent;
  while (cur) {
    if (cur.is("label")) {
      return [cur];
    }
    cur = cur.parent;
  }
  return [];
}
var defaults$i = {
  maxlength: 70
};
var LongTitle = class extends Rule {
  maxlength;
  constructor(options) {
    super({ ...defaults$i, ...options });
    this.maxlength = this.options.maxlength;
  }
  static schema() {
    return {
      maxlength: {
        type: "number"
      }
    };
  }
  documentation() {
    return {
      description: `Search engines truncates titles with long text, possibly down-ranking the page in the process.`,
      url: "https://html-validate.org/rules/long-title.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.previous;
      if (node.tagName !== "title") return;
      const text = node.textContent;
      if (text.length > this.maxlength) {
        this.report(node, `title text cannot be longer than ${String(this.maxlength)} characters`);
      }
    });
  }
};
var defaults$h = {
  allowLongDelay: false
};
var MetaRefresh = class extends Rule {
  constructor(options) {
    super({ ...defaults$h, ...options });
  }
  documentation() {
    return {
      description: `Meta refresh directive must use the \`0;url=...\` format. Non-zero values for time interval is disallowed as people with assistive technology might be unable to read and understand the page content before automatically reloading. For the same reason skipping the url is disallowed as it would put the browser in an infinite loop reloading the same page over and over again.`,
      url: "https://html-validate.org/rules/meta-refresh.html"
    };
  }
  setup() {
    this.on("element:ready", ({ target }) => {
      if (!target.is("meta")) {
        return;
      }
      const httpEquiv = target.getAttributeValue("http-equiv");
      if (httpEquiv !== "refresh") {
        return;
      }
      const content = target.getAttribute("content");
      if (!content?.value || content.isDynamic) {
        return;
      }
      const location = content.valueLocation;
      const value = parseContent(content.value.toString());
      if (!value) {
        this.report(target, "Malformed meta refresh directive", location);
        return;
      }
      const { delay, url } = value;
      this.validateDelay(target, location, delay, url);
    });
  }
  validateDelay(target, location, delay, url) {
    const { allowLongDelay } = this.options;
    if (allowLongDelay && delay > 72e3) {
      return;
    }
    if (!url && delay === 0) {
      this.report(target, "Don't use instant meta refresh to reload the page", location);
      return;
    }
    if (delay !== 0) {
      const message = allowLongDelay ? "Meta refresh must be instant (0 second delay) or greater than 20 hours (72000 second delay)" : "Meta refresh must be instant (0 second delay)";
      this.report(target, message, location);
    }
  }
};
function parseContent(text) {
  const match2 = /^(\d+)(?:\s*;\s*url=(.*))?/i.exec(text);
  if (match2) {
    return {
      delay: parseInt(match2[1], 10),
      url: match2[2]
    };
  } else {
    return null;
  }
}
function getName(attr) {
  const name = attr.value;
  if (!name || name instanceof DynamicValue) {
    return null;
  }
  return name;
}
var MapDupName = class extends Rule {
  documentation() {
    return {
      description: "`<map>` must have a unique name, it cannot be the same name as another `<map>` element",
      url: "https://html-validate.org/rules/map-dup-name.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const maps = document.querySelectorAll("map[name]");
      const names = /* @__PURE__ */ new Set();
      for (const map of maps) {
        const attr = map.getAttribute("name");
        if (!attr) {
          continue;
        }
        const name = getName(attr);
        if (!name) {
          continue;
        }
        if (names.has(name)) {
          this.report({
            node: map,
            message: `<map> name must be unique`,
            location: attr.keyLocation
          });
        }
        names.add(name);
      }
    });
  }
};
function isRelevant$4(event) {
  return event.target.is("map");
}
function hasStaticValue(attr) {
  return Boolean(attr && !(attr.value instanceof DynamicValue));
}
var MapIdName = class extends Rule {
  documentation() {
    return {
      description: "When the `id` attribute is present on a `<map>` element it must be equal to the `name` attribute.",
      url: "https://html-validate.org/rules/map-id-name.html"
    };
  }
  setup() {
    this.on("tag:ready", isRelevant$4, (event) => {
      const { target } = event;
      const id = target.getAttribute("id");
      const name = target.getAttribute("name");
      if (!hasStaticValue(id) || !hasStaticValue(name)) {
        return;
      }
      if (id.value === name.value) {
        return;
      }
      this.report({
        node: event.target,
        message: `"id" and "name" attribute must be the same on <map> elements`,
        location: id.valueLocation ?? name.valueLocation
      });
    });
  }
};
var MissingDoctype = class extends Rule {
  documentation() {
    return {
      description: "Requires that the document contains a doctype.",
      url: "https://html-validate.org/rules/missing-doctype.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const dom = event.document;
      if (!dom.doctype) {
        this.report(dom.root, "Document is missing doctype");
      }
    });
  }
};
var MultipleLabeledControls = class extends Rule {
  labelable = "";
  documentation() {
    return {
      description: `A \`<label>\` element can only be associated with one control at a time.`,
      url: "https://html-validate.org/rules/multiple-labeled-controls.html"
    };
  }
  setup() {
    this.labelable = this.getTagsWithProperty("labelable").join(",");
    this.on("dom:ready", (event) => {
      const { document } = event;
      const labels = document.querySelectorAll("label");
      for (const label of labels) {
        const numControls = this.getNumLabledControls(label);
        if (numControls <= 1) {
          continue;
        }
        this.report(label, "<label> is associated with multiple controls", label.location);
      }
    });
  }
  getNumLabledControls(src) {
    const controls = src.querySelectorAll(this.labelable).filter((node) => node.meta?.labelable).map((node) => node.id);
    const attr = src.getAttribute("for");
    if (!attr || attr.isDynamic || !attr.value) {
      return controls.length;
    }
    const redundant = controls.includes(attr.value.toString());
    if (redundant) {
      return controls.length;
    }
    return controls.length + 1;
  }
};
var defaults$g = {
  pattern: "camelcase"
};
var NamePattern = class extends BasePatternRule {
  constructor(options) {
    super("name", { ...defaults$g, ...options });
  }
  static schema() {
    return BasePatternRule.schema();
  }
  documentation(context) {
    return {
      description: this.description(context),
      url: "https://html-validate.org/rules/name-pattern.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      const { target, key, value, valueLocation } = event;
      const { meta } = target;
      if (!meta?.formAssociated?.listed) {
        return;
      }
      if (key.toLowerCase() !== "name") {
        return;
      }
      if (value instanceof DynamicValue) {
        return;
      }
      if (value === null) {
        return;
      }
      const name = value.endsWith("[]") ? value.slice(0, -2) : value;
      this.validateValue(target, name, valueLocation);
    });
  }
};
var abstractRoles = [
  "command",
  "composite",
  "input",
  "landmark",
  "range",
  "roletype",
  "section",
  "sectionhead",
  "select",
  "structure",
  "widget",
  "window"
];
function isRelevant$3(event) {
  return event.key === "role";
}
var NoAbstractRole = class extends Rule {
  documentation(context) {
    return {
      description: [
        `Role \`"${context.role}"\` is abstract and must not be used.`,
        "",
        "WAI-ARIA defines a list of [abstract roles](https://www.w3.org/TR/wai-aria-1.2/#abstract_roles) which cannot be used by authors:",
        "",
        ...abstractRoles.map((it) => `- \`"${it}"\``),
        "",
        `Use one of the defined subclass roles for \`"${context.role}"\` instead.`
      ].join("\n"),
      url: "https://html-validate.org/rules/no-abstract-role.html"
    };
  }
  setup() {
    this.on("attr", isRelevant$3, (event) => {
      const roles2 = event.value;
      if (!roles2 || roles2 instanceof DynamicValue) {
        return;
      }
      const tokens = new DOMTokenList(roles2, event.valueLocation);
      for (const { item: role, location } of tokens.iterator()) {
        if (!abstractRoles.includes(role)) {
          continue;
        }
        this.report({
          node: event.target,
          message: `Role "{{ role }}" is abstract and must not be used`,
          location,
          context: {
            role
          }
        });
      }
    });
  }
};
var defaults$f = {
  include: null,
  exclude: null
};
var NoAutoplay = class extends Rule {
  constructor(options) {
    super({ ...defaults$f, ...options });
  }
  documentation(context) {
    return {
      description: [
        `The autoplay attribute is not allowed on <${context.tagName}>.`,
        "Autoplaying content can be disruptive for users and has accessibilty concerns.",
        "Prefer to let the user control playback."
      ].join("\n"),
      url: "https://html-validate.org/rules/no-autoplay.html"
    };
  }
  static schema() {
    return {
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      }
    };
  }
  setup() {
    this.on("attr", (event) => {
      if (event.key.toLowerCase() !== "autoplay") {
        return;
      }
      if (event.value && event.value instanceof DynamicValue) {
        return;
      }
      const tagName = event.target.tagName;
      if (this.isKeywordIgnored(tagName)) {
        return;
      }
      const context = { tagName };
      const location = event.location;
      this.report(
        event.target,
        `The autoplay attribute is not allowed on <${tagName}>`,
        location,
        context
      );
    });
  }
};
var NoConditionalComment = class extends Rule {
  documentation() {
    return {
      description: "Microsoft Internet Explorer previously supported using special HTML comments (conditional comments) for targeting specific versions of IE but since IE 10 it is deprecated and not supported in standards mode.",
      url: "https://html-validate.org/rules/no-conditional-comment.html"
    };
  }
  setup() {
    this.on("conditional", (event) => {
      this.report(event.parent, "Use of conditional comments are deprecated", event.location);
    });
  }
};
var NoDeprecatedAttr = class extends Rule {
  documentation() {
    return {
      description: "HTML5 deprecated many old attributes.",
      url: "https://html-validate.org/rules/no-deprecated-attr.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      const node = event.target;
      const meta = node.meta;
      const attr = event.key.toLowerCase();
      if (meta === null) {
        return;
      }
      const metaAttribute = meta.attributes[attr];
      if (!metaAttribute) {
        return;
      }
      const deprecated = metaAttribute.deprecated;
      if (deprecated) {
        this.report(
          node,
          `Attribute "${event.key}" is deprecated on <${node.tagName}> element`,
          event.keyLocation
        );
      }
    });
  }
};
var NoDupAttr = class extends Rule {
  documentation() {
    return {
      description: "HTML disallows two or more attributes with the same (case-insensitive) name.",
      url: "https://html-validate.org/rules/no-dup-attr.html"
    };
  }
  setup() {
    let attr = {};
    this.on("tag:start", () => {
      attr = {};
    });
    this.on("attr", (event) => {
      if (event.originalAttribute) {
        return;
      }
      const name = event.key.toLowerCase();
      if (name in attr) {
        this.report(event.target, `Attribute "${name}" duplicated`, event.keyLocation);
      }
      attr[event.key] = true;
    });
  }
};
var NoDupClass = class extends Rule {
  documentation() {
    return {
      description: "Prevents unnecessary duplication of class names.",
      url: "https://html-validate.org/rules/no-dup-class.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      if (event.key.toLowerCase() !== "class") {
        return;
      }
      const classes = new DOMTokenList(event.value, event.valueLocation);
      const unique = /* @__PURE__ */ new Set();
      classes.forEach((cur, index) => {
        if (unique.has(cur)) {
          const location = classes.location(index);
          this.report(event.target, `Class "${cur}" duplicated`, location);
        }
        unique.add(cur);
      });
    });
  }
};
var CACHE_KEY = Symbol("no-dup-id");
var NoDupID = class extends Rule {
  documentation() {
    return {
      description: "The ID of an element must be unique.",
      url: "https://html-validate.org/rules/no-dup-id.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const rootExisting = getExisting(document.root, document.root);
      const useRootExisting = !document.querySelector("template");
      const elements = document.querySelectorAll("[id]");
      for (const el of elements) {
        const attr = el.getAttribute("id");
        if (!attr) {
          continue;
        }
        if (!attr.value) {
          continue;
        }
        if (attr.isDynamic) {
          continue;
        }
        const id = attr.value.toString();
        const existing = useRootExisting ? rootExisting : getExisting(el, document.root);
        if (existing.has(id)) {
          this.report(el, `Duplicate ID "${id}"`, attr.valueLocation);
          continue;
        }
        existing.add(id);
      }
    });
  }
};
function getExisting(element, root) {
  const group = element.closest("template") ?? root;
  const existing = group.cacheGet(CACHE_KEY);
  if (existing) {
    return existing;
  } else {
    const existing2 = /* @__PURE__ */ new Set();
    return group.cacheSet(CACHE_KEY, existing2);
  }
}
function isRelevant$2(event) {
  return event.target.is("button");
}
var NoImplicitButtonType = class extends Rule {
  documentation() {
    return {
      description: [
        "`<button>` is missing recommended `type` attribute",
        "",
        "When the `type` attribute is omitted it defaults to `submit`.",
        "Submit buttons are triggered when a keyboard user presses <kbd>Enter</kbd>.",
        "",
        "As this may or may not be inteded this rule enforces that the `type` attribute be explicitly set to one of the valid types:",
        "",
        "- `button` - a generic button.",
        "- `submit` - a submit button.",
        "- `reset`- a button to reset form fields."
      ].join("\n"),
      url: "https://html-validate.org/rules/no-implicit-button-type.html"
    };
  }
  setup() {
    this.on("element:ready", isRelevant$2, (event) => {
      const { target } = event;
      const attr = target.getAttribute("type");
      if (!attr) {
        this.report({
          node: event.target,
          message: `<button> is missing recommended "type" attribute`
        });
      }
    });
  }
};
function isRelevant$1(event) {
  return event.target.is("input");
}
var NoImplicitInputType = class extends Rule {
  documentation() {
    return {
      description: ["`<input>` is missing recommended `type` attribute"].join("\n"),
      url: "https://html-validate.org/rules/no-implicit-input-type.html"
    };
  }
  setup() {
    this.on("element:ready", isRelevant$1, (event) => {
      const { target } = event;
      const attr = target.getAttribute("type");
      if (!attr) {
        this.report({
          node: event.target,
          message: `<input> is missing recommended "type" attribute`
        });
      }
    });
  }
};
var NoImplicitClose = class extends Rule {
  documentation() {
    return {
      description: `Some elements in HTML has optional end tags. When an optional tag is omitted a browser must handle it as if the end tag was present.

Omitted end tags can be ambigious for humans to read and many editors have trouble formatting the markup.`,
      url: "https://html-validate.org/rules/no-implicit-close.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const closed = event.previous;
      const by = event.target;
      if (!by) {
        return;
      }
      if (closed.closed !== NodeClosed.ImplicitClosed) {
        return;
      }
      const parent2 = closed.parent;
      const closedByParent = parent2 && parent2.tagName === by.tagName;
      const closedByDocument = closedByParent && parent2.isRootElement();
      const sameTag = closed.tagName === by.tagName;
      if (closedByDocument) {
        this.report(
          closed,
          `Element <${closed.tagName}> is implicitly closed by document ending`,
          closed.location
        );
      } else if (closedByParent) {
        this.report(
          closed,
          `Element <${closed.tagName}> is implicitly closed by parent </${by.tagName}>`,
          closed.location
        );
      } else if (sameTag) {
        this.report(
          closed,
          `Element <${closed.tagName}> is implicitly closed by sibling`,
          closed.location
        );
      } else {
        this.report(
          closed,
          `Element <${closed.tagName}> is implicitly closed by adjacent <${by.tagName}>`,
          closed.location
        );
      }
    });
  }
};
var defaults$e = {
  include: null,
  exclude: null,
  allowedProperties: ["display"]
};
var NoInlineStyle = class extends Rule {
  constructor(options) {
    super({ ...defaults$e, ...options });
  }
  static schema() {
    return {
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      allowedProperties: {
        items: {
          type: "string"
        },
        type: "array"
      }
    };
  }
  documentation() {
    const text = [
      "Inline style is not allowed.\n",
      "Inline style is a sign of unstructured CSS. Use class or ID with a separate stylesheet.\n"
    ];
    if (this.options.allowedProperties.length > 0) {
      text.push("Under the current configuration the following CSS properties are allowed:\n");
      text.push(this.options.allowedProperties.map((it) => `- \`${it}\``).join("\n"));
    }
    return {
      description: text.join("\n"),
      url: "https://html-validate.org/rules/no-inline-style.html"
    };
  }
  setup() {
    this.on(
      "attr",
      (event) => this.isRelevant(event),
      (event) => {
        const { value } = event;
        if (this.allPropertiesAllowed(value)) {
          return;
        }
        this.report(event.target, "Inline style is not allowed");
      }
    );
  }
  isRelevant(event) {
    if (event.key !== "style") {
      return false;
    }
    const { include, exclude } = this.options;
    const key = event.originalAttribute ?? event.key;
    if (include && !include.includes(key)) {
      return false;
    }
    if (exclude?.includes(key)) {
      return false;
    }
    return true;
  }
  allPropertiesAllowed(value) {
    const allowProperties = this.options.allowedProperties;
    if (allowProperties.length === 0) {
      return false;
    }
    const declarations = Object.keys(parseCssDeclaration(value));
    return declarations.length > 0 && declarations.every((it) => {
      return allowProperties.includes(it);
    });
  }
};
var ARIA = [
  { property: "aria-activedescendant", isList: false },
  { property: "aria-controls", isList: true },
  { property: "aria-describedby", isList: true },
  { property: "aria-details", isList: false },
  { property: "aria-errormessage", isList: false },
  { property: "aria-flowto", isList: true },
  { property: "aria-labelledby", isList: true },
  { property: "aria-owns", isList: true }
];
function idMissing(document, id) {
  const nodes = document.querySelectorAll(generateIdSelector(id));
  return nodes.length === 0;
}
var NoMissingReferences = class extends Rule {
  documentation(context) {
    return {
      description: `The element ID "${context.value}" referenced by the ${context.key} attribute must point to an existing element.`,
      url: "https://html-validate.org/rules/no-missing-references.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const document = event.document;
      for (const node of document.querySelectorAll("label[for]")) {
        const attr = node.getAttribute("for");
        this.validateReference(document, node, attr, false);
      }
      for (const node of document.querySelectorAll("input[list]")) {
        const attr = node.getAttribute("list");
        this.validateReference(document, node, attr, false);
      }
      for (const { property, isList } of ARIA) {
        for (const node of document.querySelectorAll(`[${property}]`)) {
          const attr = node.getAttribute(property);
          this.validateReference(document, node, attr, isList);
        }
      }
    });
  }
  validateReference(document, node, attr, isList) {
    if (!attr) {
      return;
    }
    const value = attr.value;
    if (value instanceof DynamicValue || value === null || value === "") {
      return;
    }
    if (isList) {
      this.validateList(document, node, attr, value);
    } else {
      this.validateSingle(document, node, attr, value);
    }
  }
  validateSingle(document, node, attr, id) {
    if (idMissing(document, id)) {
      const context = { key: attr.key, value: id };
      this.report(node, `Element references missing id "${id}"`, attr.valueLocation, context);
    }
  }
  validateList(document, node, attr, values) {
    const parsed = new DOMTokenList(values, attr.valueLocation);
    for (const entry of parsed.iterator()) {
      const id = entry.item;
      if (idMissing(document, id)) {
        const context = { key: attr.key, value: id };
        this.report(node, `Element references missing id "${id}"`, entry.location, context);
      }
    }
  }
};
var NoMultipleMain = class extends Rule {
  documentation() {
    return {
      description: [
        "Only a single visible `<main>` element can be present at in a document at a time.",
        "",
        "Multiple `<main>` can be present in the DOM as long the others are hidden using the HTML5 `hidden` attribute."
      ].join("\n"),
      url: "https://html-validate.org/rules/no-multiple-main.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const main = document.querySelectorAll("main").filter((cur) => !cur.hasAttribute("hidden"));
      main.shift();
      for (const elem of main) {
        this.report(elem, "Multiple <main> elements present in document");
      }
    });
  }
};
var defaults$d = {
  relaxed: false
};
var textRegexp = /([<>]|&(?![a-zA-Z0-9#]+;))/g;
var unquotedAttrRegexp = /([<>"'=`]|&(?![a-zA-Z0-9#]+;))/g;
var matchTemplate = /^(<%.*?%>|<\?.*?\?>|<\$.*?\$>)$/s;
var replacementTable = {
  '"': "&quot;",
  "&": "&amp;",
  "'": "&apos;",
  "<": "&lt;",
  "=": "&equals;",
  ">": "&gt;",
  "`": "&grave;"
};
var NoRawCharacters = class extends Rule {
  relaxed;
  constructor(options) {
    super({ ...defaults$d, ...options });
    this.relaxed = this.options.relaxed;
  }
  static schema() {
    return {
      relaxed: {
        type: "boolean"
      }
    };
  }
  documentation() {
    return {
      description: `Some characters such as \`<\`, \`>\` and \`&\` hold special meaning in HTML and must be escaped using a character reference (html entity).`,
      url: "https://html-validate.org/rules/no-raw-characters.html"
    };
  }
  setup() {
    this.on("element:ready", (event) => {
      const node = event.target;
      for (const child of node.childNodes) {
        if (child.nodeType !== NodeType.TEXT_NODE) {
          continue;
        }
        if (matchTemplate.exec(child.textContent)) {
          continue;
        }
        this.findRawChars(node, child.textContent, child.location, textRegexp);
      }
    });
    this.on("attr", (event) => {
      const { meta } = event;
      if (!event.value) {
        return;
      }
      if (event.quote) {
        return;
      }
      if (meta?.boolean) {
        return;
      }
      this.findRawChars(
        event.target,
        event.value.toString(),
        event.valueLocation,
        // eslint-disable-line @typescript-eslint/no-non-null-assertion -- technical debt, valueLocation is always set if a value is provided
        unquotedAttrRegexp
      );
    });
  }
  /**
   * Find raw special characters and report as errors.
   *
   * @param text - The full text to find unescaped raw characters in.
   * @param location - Location of text.
   * @param regexp - Regexp pattern to match using.
   */
  findRawChars(node, text, location, regexp2) {
    let match2;
    do {
      match2 = regexp2.exec(text);
      if (match2) {
        const char = match2[0];
        if (this.relaxed && char === "&") {
          continue;
        }
        const replacement2 = replacementTable[char];
        const charLocation = sliceLocation(location, match2.index, match2.index + 1);
        this.report(node, `Raw "${char}" must be encoded as "${replacement2}"`, charLocation);
      }
    } while (match2);
  }
};
var selectors$1 = ["input[aria-label]", "textarea[aria-label]", "select[aria-label]"];
var NoRedundantAriaLabel = class extends Rule {
  documentation() {
    return {
      description: "`aria-label` is redundant when an associated `<label>` element containing the same text exists.",
      url: "https://html-validate.org/rules/no-redundant-aria-label.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const elements = document.querySelectorAll(selectors$1.join(","));
      for (const element of elements) {
        const ariaLabel = element.getAttribute("aria-label");
        const id = element.id;
        if (!id) {
          continue;
        }
        const label = document.querySelector(`label[for="${id}"]`);
        if (!ariaLabel || !label || label.textContent.trim() !== ariaLabel.value) {
          continue;
        }
        const message = "aria-label is redundant when label containing same text exists";
        this.report({
          message,
          node: element,
          location: ariaLabel.keyLocation
        });
      }
    });
  }
};
var NoRedundantFor = class extends Rule {
  documentation() {
    return {
      description: `When the \`<label>\` element wraps the labelable control the \`for\` attribute is redundant and better left out.`,
      url: "https://html-validate.org/rules/no-redundant-for.html"
    };
  }
  setup() {
    this.on("element:ready", (event) => {
      const { target } = event;
      if (target.tagName !== "label") {
        return;
      }
      const attr = target.getAttribute("for");
      if (!attr || !isStaticAttribute(attr)) {
        return;
      }
      const id = attr.value;
      if (!id) {
        return;
      }
      const control = target.querySelector(generateIdSelector(id));
      if (!control) {
        return;
      }
      this.report(target, 'Redundant "for" attribute', attr.keyLocation);
    });
  }
};
var NoRedundantRole = class extends Rule {
  documentation(context) {
    const { role, tagName } = context;
    return {
      description: `Using the \`${role}\` role is redundant as it is already implied by the \`<${tagName}>\` element.`,
      url: "https://html-validate.org/rules/no-redundant-role.html"
    };
  }
  setup() {
    this.on("tag:ready", (event) => {
      const { target } = event;
      const role = target.getAttribute("role");
      if (!role?.value || role.value instanceof DynamicValue) {
        return;
      }
      const { meta } = target;
      if (!meta) {
        return;
      }
      const implicitRole = meta.aria.implicitRole(target._adapter);
      if (!implicitRole) {
        return;
      }
      if (role.value !== implicitRole) {
        return;
      }
      const context = {
        tagName: target.tagName,
        role: role.value
      };
      this.report(
        event.target,
        `Redundant role "${role.value}" on <${target.tagName}>`,
        role.valueLocation,
        context
      );
    });
  }
};
var xmlns = /^(.+):.+$/;
var defaults$c = {
  ignoreForeign: true,
  ignoreXML: true
};
var NoSelfClosing = class extends Rule {
  constructor(options) {
    super({ ...defaults$c, ...options });
  }
  static schema() {
    return {
      ignoreForeign: {
        type: "boolean"
      },
      ignoreXML: {
        type: "boolean"
      }
    };
  }
  documentation(tagName) {
    tagName = tagName || "element";
    return {
      description: `Self-closing elements are disallowed. Use regular end tag <${tagName}></${tagName}> instead of self-closing <${tagName}/>.`,
      url: "https://html-validate.org/rules/no-self-closing.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const active = event.previous;
      if (!isRelevant(active, this.options)) {
        return;
      }
      this.validateElement(active);
    });
  }
  validateElement(node) {
    if (node.closed !== NodeClosed.VoidSelfClosed) {
      return;
    }
    this.report(node, `<${node.tagName}> must not be self-closed`, null, node.tagName);
  }
};
function isRelevant(node, options) {
  if (xmlns.exec(node.tagName)) {
    return !options.ignoreXML;
  }
  if (!node.meta) {
    return true;
  }
  if (node.meta.void) {
    return false;
  }
  if (node.meta.foreign) {
    return !options.ignoreForeign;
  }
  return true;
}
var NoStyleTag2 = class extends Rule {
  documentation() {
    return {
      description: "Prefer to use external stylesheets with the `<link>` tag instead of inlining the styling.",
      url: "https://html-validate.org/rules/no-style-tag.html"
    };
  }
  setup() {
    this.on("tag:start", (event) => {
      const node = event.target;
      if (node.tagName === "style") {
        this.report(node, "Use external stylesheet with <link> instead of <style> tag");
      }
    });
  }
};
var NoTrailingWhitespace = class extends Rule {
  documentation() {
    return {
      description: "Lines with trailing whitespace cause unnessecary diff when using version control and usually serve no special purpose in HTML.",
      url: "https://html-validate.org/rules/no-trailing-whitespace.html"
    };
  }
  setup() {
    this.on("whitespace", (event) => {
      if (/^[ \t]+\r?\n$/.exec(event.text)) {
        this.report(null, "Trailing whitespace", event.location);
      }
    });
  }
};
var defaults$b = {
  include: null,
  exclude: null
};
var NoUnknownElements = class extends Rule {
  constructor(options) {
    super({ ...defaults$b, ...options });
  }
  static schema() {
    return {
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      }
    };
  }
  documentation(context) {
    const element = context ? ` <${context}>` : "";
    return {
      description: `An unknown element${element} was used. If this is a Custom Element you need to supply element metadata for it.`,
      url: "https://html-validate.org/rules/no-unknown-elements.html"
    };
  }
  setup() {
    this.on("tag:start", (event) => {
      const node = event.target;
      if (node.meta) {
        return;
      }
      if (this.isKeywordIgnored(node.tagName, keywordPatternMatcher)) {
        return;
      }
      this.report(node, `Unknown element <${node.tagName}>`, null, node.tagName);
    });
  }
};
var NoUnusedDisable = class extends Rule {
  documentation(context) {
    return {
      description: `\`${context.ruleId}\` rule is disabled but no error was reported.`,
      url: "https://html-validate.org/rules/no-unused-disable.html"
    };
  }
  setup() {
  }
  reportUnused(unused, options, location) {
    const tokens = new DOMTokenList(options.replace(/,/g, " "), location);
    for (const ruleId of unused) {
      const index = tokens.indexOf(ruleId);
      const tokenLocation = index >= 0 ? tokens.location(index) : location;
      this.report({
        node: null,
        message: '"{{ ruleId }}" rule is disabled but no error was reported',
        location: tokenLocation,
        context: {
          ruleId
        }
      });
    }
  }
};
var NoUtf8Bom = class extends Rule {
  documentation() {
    return {
      description: `This file is saved with the UTF-8 byte order mark (BOM) present. It is neither required or recommended to use.

Instead the document should be served with the \`Content-Type: application/javascript; charset=utf-8\` header.`,
      url: "https://html-validate.org/rules/no-utf8-bom.html"
    };
  }
  setup() {
    const unregister = this.on("token", (event) => {
      if (event.type === TokenType.UNICODE_BOM) {
        this.report(null, "File should be saved without UTF-8 BOM", event.location);
      }
      this.setEnabled(false);
      unregister();
    });
  }
};
var types2 = ["button", "submit", "reset", "image"];
var replacement = {
  button: '<button type="button">',
  submit: '<button type="submit">',
  reset: '<button type="reset">',
  image: '<button type="button">'
};
var defaults$a = {
  include: null,
  exclude: null
};
var PreferButton = class extends Rule {
  constructor(options) {
    super({ ...defaults$a, ...options });
  }
  static schema() {
    return {
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      }
    };
  }
  documentation(context) {
    const src = `<input type="${context.type}">`;
    const dst = replacement[context.type] || `<button>`;
    return {
      description: `Prefer to use \`${dst}\` instead of \`"${src}\`.`,
      url: "https://html-validate.org/rules/prefer-button.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      const node = event.target;
      if (node.tagName.toLowerCase() !== "input") {
        return;
      }
      if (event.key.toLowerCase() !== "type") {
        return;
      }
      if (!event.value || event.value instanceof DynamicValue) {
        return;
      }
      const type2 = event.value.toLowerCase();
      if (this.isKeywordIgnored(type2)) {
        return;
      }
      if (!types2.includes(type2)) {
        return;
      }
      const context = { type: type2 };
      const message = `Prefer to use <button> instead of <input type="${type2}"> when adding buttons`;
      this.report(node, message, event.valueLocation, context);
    });
  }
};
var defaults$9 = {
  mapping: {
    article: "article",
    banner: "header",
    button: "button",
    cell: "td",
    checkbox: "input",
    complementary: "aside",
    contentinfo: "footer",
    figure: "figure",
    form: "form",
    heading: "hN",
    input: "input",
    link: "a",
    list: "ul",
    listbox: "select",
    listitem: "li",
    main: "main",
    navigation: "nav",
    progressbar: "progress",
    radio: "input",
    region: "section",
    table: "table",
    textbox: "textarea"
  },
  include: null,
  exclude: null
};
var PreferNativeElement = class extends Rule {
  constructor(options) {
    super({ ...defaults$9, ...options });
  }
  static schema() {
    return {
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      mapping: {
        type: "object"
      }
    };
  }
  documentation(context) {
    return {
      description: `Instead of using the WAI-ARIA role "${context.role}" prefer to use the native <${context.replacement}> element.`,
      url: "https://html-validate.org/rules/prefer-native-element.html"
    };
  }
  setup() {
    const { mapping: mapping2 } = this.options;
    this.on("attr", (event) => {
      if (event.key.toLowerCase() !== "role") {
        return;
      }
      if (!event.value || event.value instanceof DynamicValue) {
        return;
      }
      const role = event.value.toLowerCase();
      if (this.isIgnored(role)) {
        return;
      }
      const replacement2 = mapping2[role];
      if (event.target.is(replacement2)) {
        return;
      }
      const context = { role, replacement: replacement2 };
      const location = this.getLocation(event);
      this.report(
        event.target,
        `Prefer to use the native <${replacement2}> element`,
        location,
        context
      );
    });
  }
  isIgnored(role) {
    const { mapping: mapping2 } = this.options;
    const replacement2 = mapping2[role];
    if (!replacement2) {
      return true;
    }
    return this.isKeywordIgnored(role);
  }
  getLocation(event) {
    const begin = event.location;
    const end = event.valueLocation;
    const quote = event.quote ? 1 : 0;
    const size = end.offset + end.size - begin.offset + quote;
    return {
      filename: begin.filename,
      line: begin.line,
      column: begin.column,
      offset: begin.offset,
      size
    };
  }
};
var PreferTbody = class extends Rule {
  documentation() {
    return {
      description: `While \`<tbody>\` is optional is relays semantic information about its contents. Where applicable it should also be combined with \`<thead>\` and \`<tfoot>\`.`,
      url: "https://html-validate.org/rules/prefer-tbody.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      for (const table2 of doc.querySelectorAll("table")) {
        if (table2.querySelector("> tbody")) {
          continue;
        }
        const tr = table2.querySelectorAll("> tr");
        if (tr.length >= 1) {
          this.report(tr[0], "Prefer to wrap <tr> elements in <tbody>");
        }
      }
    });
  }
};
var defaults$8 = {
  tags: ["script", "style"]
};
var RequireCSPNonce = class extends Rule {
  constructor(options) {
    super({ ...defaults$8, ...options });
  }
  static schema() {
    return {
      tags: {
        type: "array",
        items: {
          enum: ["script", "style"],
          type: "string"
        }
      }
    };
  }
  documentation() {
    return {
      description: [
        "Required Content-Security-Policy (CSP) nonce is missing or empty.",
        "",
        "This is set by the `nonce` attribute and must match the `Content-Security-Policy` header.",
        "For instance, if the header contains `script-src 'nonce-r4nd0m'` the `nonce` attribute must be set to `nonce=\"r4nd0m\">`",
        "",
        "The nonce should be unique per each request and set to a cryptography secure random token.",
        "It is used to prevent cross site scripting (XSS) by preventing malicious actors from injecting scripts onto the page."
      ].join("\n"),
      url: "https://html-validate.org/rules/require-csp-nonce.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const { tags } = this.options;
      const node = event.previous;
      if (!tags.includes(node.tagName)) {
        return;
      }
      const nonce = node.getAttribute("nonce")?.value;
      if (nonce && nonce !== "") {
        return;
      }
      if (node.is("script") && node.hasAttribute("src")) {
        return;
      }
      const message = `required CSP nonce is missing`;
      this.report(node, message, node.location);
    });
  }
};
var defaults$7 = {
  target: "all",
  include: null,
  exclude: null
};
var crossorigin = new RegExp("^(\\w+://|//)");
var supportSri = {
  link: "href",
  script: "src"
};
var supportedRel = ["stylesheet", "preload", "modulepreload"];
var supportedPreload = ["style", "script"];
function linkSupportsSri(node) {
  const rel = node.getAttribute("rel");
  if (typeof rel?.value !== "string") {
    return false;
  }
  if (!supportedRel.includes(rel.value)) {
    return false;
  }
  if (rel.value === "preload") {
    const as = node.getAttribute("as");
    return typeof as?.value === "string" && supportedPreload.includes(as.value);
  }
  return true;
}
var RequireSri = class extends Rule {
  target;
  constructor(options) {
    super({ ...defaults$7, ...options });
    this.target = this.options.target;
  }
  static schema() {
    return {
      target: {
        enum: ["all", "crossorigin"],
        type: "string"
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      }
    };
  }
  documentation() {
    return {
      description: `Subresource Integrity (SRI) \`integrity\` attribute is required to prevent tampering or manipulation from Content Delivery Networks (CDN), rouge proxies,  malicious entities, etc.`,
      url: "https://html-validate.org/rules/require-sri.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.previous;
      if (!(this.supportSri(node) && this.needSri(node))) {
        return;
      }
      if (node.hasAttribute("integrity")) {
        return;
      }
      this.report(
        node,
        `SRI "integrity" attribute is required on <${node.tagName}> element`,
        node.location
      );
    });
  }
  supportSri(node) {
    return Object.keys(supportSri).includes(node.tagName);
  }
  needSri(node) {
    if (node.is("link") && !linkSupportsSri(node)) {
      return false;
    }
    const attr = this.elementSourceAttr(node);
    if (!attr) {
      return false;
    }
    if (attr.value === null || attr.value === "" || attr.isDynamic) {
      return false;
    }
    const url = attr.value.toString();
    if (this.target === "all" || crossorigin.test(url)) {
      return !this.isIgnored(url);
    }
    return false;
  }
  elementSourceAttr(node) {
    const key = supportSri[node.tagName];
    return node.getAttribute(key);
  }
  isIgnored(url) {
    return this.isKeywordIgnored(url, (list, it) => {
      return list.some((pattern) => it.includes(pattern));
    });
  }
};
var ScriptElement = class extends Rule {
  documentation() {
    return {
      description: "The end tag for `<script>` is a hard requirement and must never be omitted even when using the `src` attribute.",
      url: "https://html-validate.org/rules/script-element.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.target;
      if (!node || node.tagName !== "script") {
        return;
      }
      if (node.closed !== NodeClosed.EndTag) {
        this.report(node, `End tag for <${node.tagName}> must not be omitted`);
      }
    });
  }
};
var javascript = [
  "",
  "application/ecmascript",
  "application/javascript",
  "text/ecmascript",
  "text/javascript"
];
var ScriptType = class extends Rule {
  documentation() {
    return {
      description: "While valid the HTML5 standard encourages authors to omit the type element for JavaScript resources.",
      url: "https://html-validate.org/rules/script-type.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.previous;
      if (node.tagName !== "script") {
        return;
      }
      const attr = node.getAttribute("type");
      if (!attr || attr.isDynamic) {
        return;
      }
      const value = attr.value ? attr.value.toString() : "";
      if (!this.isJavascript(value)) {
        return;
      }
      this.report(
        node,
        '"type" attribute is unnecessary for javascript resources',
        attr.keyLocation
      );
    });
  }
  isJavascript(mime) {
    const type2 = mime.replace(/;.*/, "");
    return javascript.includes(type2);
  }
};
var SvgFocusable = class extends Rule {
  documentation() {
    return {
      description: `Inline SVG elements in IE are focusable by default which may cause issues with tab-ordering. The \`focusable\` attribute should explicitly be set to avoid unintended behaviour.`,
      url: "https://html-validate.org/rules/svg-focusable.html"
    };
  }
  setup() {
    this.on("element:ready", (event) => {
      if (event.target.is("svg")) {
        this.validate(event.target);
      }
    });
  }
  validate(svg) {
    if (svg.hasAttribute("focusable")) {
      return;
    }
    this.report(svg, `<${svg.tagName}> is missing required "focusable" attribute`);
  }
};
var defaults$6 = {
  characters: [
    { pattern: " ", replacement: "&nbsp;", description: "non-breaking space" },
    { pattern: "-", replacement: "&#8209;", description: "non-breaking hyphen" }
  ],
  ignoreClasses: [],
  ignoreStyle: true
};
function constructRegex(characters) {
  const disallowed = characters.map((it) => {
    return it.pattern;
  }).join("|");
  const pattern = `(${disallowed})`;
  return new RegExp(pattern, "g");
}
function getText(node) {
  const match2 = /^(\s*)(.*)$/.exec(node.textContent);
  const [, leading, text] = match2;
  return [leading.length, text.trimEnd()];
}
function matchAll(text, regexp2) {
  const copy = new RegExp(regexp2);
  const matches = [];
  let match2;
  while (match2 = copy.exec(text)) {
    matches.push(match2);
  }
  return matches;
}
var TelNonBreaking = class extends Rule {
  regex;
  constructor(options) {
    super({ ...defaults$6, ...options });
    this.regex = constructRegex(this.options.characters);
  }
  static schema() {
    return {
      characters: {
        type: "array",
        items: {
          type: "object",
          additionalProperties: false,
          properties: {
            pattern: {
              type: "string"
            },
            replacement: {
              type: "string"
            },
            description: {
              type: "string"
            }
          }
        }
      },
      ignoreClasses: {
        type: "array",
        items: {
          type: "string"
        }
      },
      ignoreStyle: {
        type: "boolean"
      }
    };
  }
  documentation(context) {
    const { characters } = this.options;
    const replacements = characters.map((it) => {
      return `  - \`${it.pattern}\` - replace with \`${it.replacement}\` (${it.description}).`;
    });
    return {
      description: [
        `The \`${context.pattern}\` character should be replaced with \`${context.replacement}\` character (${context.description}) when used in a telephone number.`,
        "",
        "Unless non-breaking characters is used there could be a line break inserted at that character.",
        "Line breaks make is harder to read and understand the telephone number.",
        "",
        "The following characters should be avoided:",
        "",
        ...replacements
      ].join("\n"),
      url: "https://html-validate.org/rules/tel-non-breaking.html"
    };
  }
  setup() {
    this.on("element:ready", this.isRelevant, (event) => {
      const { target } = event;
      if (this.isIgnored(target)) {
        return;
      }
      this.walk(target, target);
    });
  }
  isRelevant(event) {
    const { target } = event;
    if (!target.is("a")) {
      return false;
    }
    const attr = target.getAttribute("href");
    if (!attr?.valueMatches(/^tel:/, false)) {
      return false;
    }
    return true;
  }
  isIgnoredClass(node) {
    const { ignoreClasses } = this.options;
    const { classList } = node;
    return ignoreClasses.some((it) => classList.contains(it));
  }
  isIgnoredStyle(node) {
    const { ignoreStyle } = this.options;
    const { style } = node;
    if (!ignoreStyle) {
      return false;
    }
    if (style["white-space"] === "nowrap" || style["white-space"] === "pre") {
      return true;
    }
    return false;
  }
  isIgnored(node) {
    return this.isIgnoredClass(node) || this.isIgnoredStyle(node);
  }
  walk(anchor, node) {
    for (const child of node.childNodes) {
      if (isTextNode(child)) {
        this.detectDisallowed(anchor, child);
      } else if (isElementNode(child)) {
        this.walk(anchor, child);
      }
    }
  }
  detectDisallowed(anchor, node) {
    const [offset, text] = getText(node);
    const matches = matchAll(text, this.regex);
    for (const match2 of matches) {
      const detected = match2[0];
      const entry = this.options.characters.find((it) => it.pattern === detected);
      if (!entry) {
        throw new Error(`Failed to find entry for "${detected}" when searching text "${text}"`);
      }
      const message = `"${detected}" should be replaced with "${entry.replacement}" (${entry.description}) in telephone number`;
      const begin = offset + match2.index;
      const end = begin + detected.length;
      const location = sliceLocation(node.location, begin, end);
      const context = entry;
      this.report(anchor, message, location, context);
    }
  }
};
function hasNonEmptyAttribute(node, key) {
  const attr = node.getAttribute(key);
  return Boolean(attr?.valueMatches(/.+/, true));
}
function hasDefaultText(node) {
  if (!node.is("input")) {
    return false;
  }
  if (node.hasAttribute("value")) {
    return false;
  }
  const type2 = node.getAttribute("type");
  return Boolean(type2?.valueMatches(/submit|reset/, false));
}
function isNonEmptyText(node) {
  if (isTextNode(node)) {
    return node.isDynamic || node.textContent.trim() !== "";
  } else {
    return false;
  }
}
function haveAccessibleText(node) {
  if (!inAccessibilityTree(node)) {
    return false;
  }
  const haveText = node.childNodes.some((child) => isNonEmptyText(child));
  if (haveText) {
    return true;
  }
  if (hasNonEmptyAttribute(node, "aria-label")) {
    return true;
  }
  if (hasNonEmptyAttribute(node, "aria-labelledby")) {
    return true;
  }
  if (node.is("img") && hasNonEmptyAttribute(node, "alt")) {
    return true;
  }
  if (hasDefaultText(node)) {
    return true;
  }
  return node.childElements.some((child) => {
    return haveAccessibleText(child);
  });
}
var TextContent = class _TextContent extends Rule {
  documentation(context) {
    const doc = {
      description: `The textual content for this element is not valid.`,
      url: "https://html-validate.org/rules/text-content.html"
    };
    switch (context.textContent) {
      case TextContent$1.NONE:
        doc.description = `The \`<${context.tagName}>\` element must not have textual content.`;
        break;
      case TextContent$1.REQUIRED:
        doc.description = `The \`<${context.tagName}>\` element must have textual content.`;
        break;
      case TextContent$1.ACCESSIBLE:
        doc.description = `The \`<${context.tagName}>\` element must have accessible text.`;
        break;
    }
    return doc;
  }
  static filter(event) {
    const { target } = event;
    if (!target.meta) {
      return false;
    }
    const { textContent } = target.meta;
    if (!textContent || textContent === TextContent$1.DEFAULT) {
      return false;
    }
    return true;
  }
  setup() {
    this.on("element:ready", _TextContent.filter, (event) => {
      const target = event.target;
      const { textContent } = target.meta;
      switch (textContent) {
        case TextContent$1.NONE:
          this.validateNone(target);
          break;
        case TextContent$1.REQUIRED:
          this.validateRequired(target);
          break;
        case TextContent$1.ACCESSIBLE:
          this.validateAccessible(target);
          break;
      }
    });
  }
  /**
   * Validate element has empty text (inter-element whitespace is not considered text)
   */
  validateNone(node) {
    if (classifyNodeText(node) === TextClassification.EMPTY_TEXT) {
      return;
    }
    this.reportError(node, node.meta, `${node.annotatedName} must not have text content`);
  }
  /**
   * Validate element has any text (inter-element whitespace is not considered text)
   */
  validateRequired(node) {
    if (classifyNodeText(node) !== TextClassification.EMPTY_TEXT) {
      return;
    }
    this.reportError(node, node.meta, `${node.annotatedName} must have text content`);
  }
  /**
   * Validate element has accessible text (either regular text or text only
   * exposed in accessibility tree via aria-label or similar)
   */
  validateAccessible(node) {
    if (!inAccessibilityTree(node)) {
      return;
    }
    if (haveAccessibleText(node)) {
      return;
    }
    this.reportError(node, node.meta, `${node.annotatedName} must have accessible text`);
  }
  reportError(node, meta, message) {
    this.report(node, message, null, {
      tagName: node.tagName,
      textContent: meta.textContent
    });
  }
};
var roles = ["complementary", "contentinfo", "form", "banner", "main", "navigation", "region"];
var selectors = [
  "aside",
  "footer",
  "form",
  "header",
  "main",
  "nav",
  "section",
  ...roles.map((it) => `[role="${it}"]`)
  /* <search> does not (yet?) require a unique name */
];
function getTextFromReference(document, id) {
  if (!id || id instanceof DynamicValue) {
    return id;
  }
  const selector2 = `#${id}`;
  const ref = document.querySelector(selector2);
  if (ref) {
    return ref.textContent;
  } else {
    return selector2;
  }
}
function groupBy(values, callback) {
  const result = {};
  for (const value of values) {
    const key = callback(value);
    if (key in result) {
      result[key].push(value);
    } else {
      result[key] = [value];
    }
  }
  return result;
}
function getTextEntryFromElement(document, node) {
  const ariaLabel = node.getAttribute("aria-label");
  if (ariaLabel) {
    return {
      node,
      text: ariaLabel.value,
      location: ariaLabel.keyLocation
    };
  }
  const ariaLabelledby = node.getAttribute("aria-labelledby");
  if (ariaLabelledby) {
    const text = getTextFromReference(document, ariaLabelledby.value);
    return {
      node,
      text,
      location: ariaLabelledby.keyLocation
    };
  }
  return {
    node,
    text: null,
    location: node.location
  };
}
function isExcluded(entry) {
  const { node, text } = entry;
  if (text === null) {
    return !(node.is("form") || node.is("section"));
  }
  return true;
}
var UniqueLandmark = class extends Rule {
  documentation() {
    return {
      description: [
        "When the same type of landmark is present more than once in the same document each must be uniquely identifiable with a non-empty and unique name.",
        "For instance, if the document has two `<nav>` elements each of them need an accessible name to be distinguished from each other.",
        "",
        "The following elements / roles are considered landmarks:",
        "",
        '  - `aside` or `[role="complementary"]`',
        '  - `footer` or `[role="contentinfo"]`',
        '  - `form` or `[role="form"]`',
        '  - `header` or `[role="banner"]`',
        '  - `main` or `[role="main"]`',
        '  - `nav` or `[role="navigation"]`',
        '  - `section` or `[role="region"]`',
        "",
        "To fix this either:",
        "",
        "  - Add `aria-label`.",
        "  - Add `aria-labelledby`.",
        "  - Remove one of the landmarks."
      ].join("\n"),
      url: "https://html-validate.org/rules/unique-landmark.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const elements = document.querySelectorAll(selectors.join(",")).filter((it) => typeof it.role === "string" && roles.includes(it.role));
      const grouped = groupBy(elements, (it) => it.role);
      for (const nodes of Object.values(grouped)) {
        if (nodes.length <= 1) {
          continue;
        }
        const entries = nodes.map((it) => getTextEntryFromElement(document, it));
        const filteredEntries = entries.filter(isExcluded);
        for (const entry of filteredEntries) {
          if (entry.text instanceof DynamicValue) {
            continue;
          }
          const dup = entries.filter((it) => it.text === entry.text).length > 1;
          if (!entry.text || dup) {
            const message = `Landmarks must have a non-empty and unique accessible name (aria-label or aria-labelledby)`;
            const location = entry.location;
            this.report({
              node: entry.node,
              message,
              location
            });
          }
        }
      }
    });
  }
};
var defaults$5 = {
  ignoreCase: false,
  requireSemicolon: true
};
var regexp$1 = /&(?:[a-z0-9]+|#x?[0-9a-f]+)(;|[^a-z0-9]|$)/gi;
var lowercaseEntities = entities.map((it) => it.toLowerCase());
function isNumerical(entity) {
  return entity.startsWith("&#");
}
function getLocation(location, entity, match2) {
  const index = match2.index ?? 0;
  return sliceLocation(location, index, index + entity.length);
}
function getDescription(context, options) {
  const url = "https://html.spec.whatwg.org/multipage/named-characters.html";
  let message;
  if (context.terminated) {
    message = `Unrecognized character reference \`${context.entity}\`.`;
  } else {
    message = `Character reference \`${context.entity}\` must be terminated by a semicolon.`;
  }
  return [
    message,
    `HTML5 defines a set of [valid character references](${url}) but this is not a valid one.`,
    "",
    "Ensure that:",
    "",
    "1. The character is one of the listed names.",
    ...options.ignoreCase ? [] : ["1. The case is correct (names are case sensitive)."],
    ...options.requireSemicolon ? ["1. The name is terminated with a `;`."] : []
  ].join("\n");
}
var UnknownCharReference = class extends Rule {
  constructor(options) {
    super({ ...defaults$5, ...options });
  }
  static schema() {
    return {
      ignoreCase: {
        type: "boolean"
      },
      requireSemicolon: {
        type: "boolean"
      }
    };
  }
  documentation(context) {
    return {
      description: getDescription(context, this.options),
      url: "https://html-validate.org/rules/unrecognized-char-ref.html"
    };
  }
  setup() {
    this.on("element:ready", (event) => {
      const node = event.target;
      for (const child of node.childNodes) {
        if (child.nodeType !== NodeType.TEXT_NODE) {
          continue;
        }
        this.findCharacterReferences(node, child.textContent, child.location, {
          isAttribute: false
        });
      }
    });
    this.on("attr", (event) => {
      if (!event.value) {
        return;
      }
      this.findCharacterReferences(event.target, event.value.toString(), event.valueLocation, {
        isAttribute: true
      });
    });
  }
  get entities() {
    if (this.options.ignoreCase) {
      return lowercaseEntities;
    } else {
      return entities;
    }
  }
  findCharacterReferences(node, text, location, { isAttribute }) {
    const isQuerystring = isAttribute && text.includes("?");
    for (const match2 of this.getMatches(text)) {
      this.validateCharacterReference(node, location, match2, { isQuerystring });
    }
  }
  validateCharacterReference(node, location, foobar, { isQuerystring }) {
    const { requireSemicolon } = this.options;
    const { match: match2, entity, raw, terminated } = foobar;
    if (isNumerical(entity)) {
      return;
    }
    if (isQuerystring && !terminated) {
      return;
    }
    const found = this.entities.includes(entity);
    if (found && (terminated || !requireSemicolon)) {
      return;
    }
    if (found && !terminated) {
      const entityLocation2 = getLocation(location, entity, match2);
      const message2 = `Character reference "{{ entity }}" must be terminated by a semicolon`;
      const context2 = {
        entity: raw,
        terminated: false
      };
      this.report(node, message2, entityLocation2, context2);
      return;
    }
    const entityLocation = getLocation(location, entity, match2);
    const message = `Unrecognized character reference "{{ entity }}"`;
    const context = {
      entity: raw,
      terminated: true
    };
    this.report(node, message, entityLocation, context);
  }
  *getMatches(text) {
    let match2;
    do {
      match2 = regexp$1.exec(text);
      if (match2) {
        const terminator = match2[1];
        const terminated = terminator === ";";
        const needSlice = terminator !== ";" && terminator.length > 0;
        const entity = needSlice ? match2[0].slice(0, -1) : match2[0];
        if (this.options.ignoreCase) {
          yield { match: match2, entity: entity.toLowerCase(), raw: entity, terminated };
        } else {
          yield { match: match2, entity, raw: entity, terminated };
        }
      }
    } while (match2);
  }
};
var expectedOrder = ["section", "hint", "contact", "field1", "field2", "webauthn"];
var fieldNames1 = [
  "name",
  "honorific-prefix",
  "given-name",
  "additional-name",
  "family-name",
  "honorific-suffix",
  "nickname",
  "username",
  "new-password",
  "current-password",
  "one-time-code",
  "organization-title",
  "organization",
  "street-address",
  "address-line1",
  "address-line2",
  "address-line3",
  "address-level4",
  "address-level3",
  "address-level2",
  "address-level1",
  "country",
  "country-name",
  "postal-code",
  "cc-name",
  "cc-given-name",
  "cc-additional-name",
  "cc-family-name",
  "cc-number",
  "cc-exp",
  "cc-exp-month",
  "cc-exp-year",
  "cc-csc",
  "cc-type",
  "transaction-currency",
  "transaction-amount",
  "language",
  "bday",
  "bday-day",
  "bday-month",
  "bday-year",
  "sex",
  "url",
  "photo"
];
var fieldNames2 = [
  "tel",
  "tel-country-code",
  "tel-national",
  "tel-area-code",
  "tel-local",
  "tel-local-prefix",
  "tel-local-suffix",
  "tel-extension",
  "email",
  "impp"
];
var fieldNameGroup = {
  name: "text",
  "honorific-prefix": "text",
  "given-name": "text",
  "additional-name": "text",
  "family-name": "text",
  "honorific-suffix": "text",
  nickname: "text",
  username: "username",
  "new-password": "password",
  // eslint-disable-line sonarjs/no-hardcoded-passwords -- false positive, it is not used as a password
  "current-password": "password",
  // eslint-disable-line sonarjs/no-hardcoded-passwords -- false positive, it is not used as a password
  "one-time-code": "password",
  "organization-title": "text",
  organization: "text",
  "street-address": "multiline",
  "address-line1": "text",
  "address-line2": "text",
  "address-line3": "text",
  "address-level4": "text",
  "address-level3": "text",
  "address-level2": "text",
  "address-level1": "text",
  country: "text",
  "country-name": "text",
  "postal-code": "text",
  "cc-name": "text",
  "cc-given-name": "text",
  "cc-additional-name": "text",
  "cc-family-name": "text",
  "cc-number": "text",
  "cc-exp": "month",
  "cc-exp-month": "numeric",
  "cc-exp-year": "numeric",
  "cc-csc": "text",
  "cc-type": "text",
  "transaction-currency": "text",
  "transaction-amount": "numeric",
  language: "text",
  bday: "date",
  "bday-day": "numeric",
  "bday-month": "numeric",
  "bday-year": "numeric",
  sex: "text",
  url: "url",
  photo: "url",
  tel: "tel",
  "tel-country-code": "text",
  "tel-national": "text",
  "tel-area-code": "text",
  "tel-local": "text",
  "tel-local-prefix": "text",
  "tel-local-suffix": "text",
  "tel-extension": "text",
  email: "username",
  impp: "url"
};
var disallowedInputTypes = ["checkbox", "radio", "file", "submit", "image", "reset", "button"];
function matchSection(token) {
  return token.startsWith("section-");
}
function matchHint(token) {
  return token === "shipping" || token === "billing";
}
function matchFieldNames1(token) {
  return fieldNames1.includes(token);
}
function matchContact(token) {
  const haystack = ["home", "work", "mobile", "fax", "pager"];
  return haystack.includes(token);
}
function matchFieldNames2(token) {
  return fieldNames2.includes(token);
}
function matchWebauthn(token) {
  return token === "webauthn";
}
function matchToken(token) {
  if (matchSection(token)) {
    return "section";
  }
  if (matchHint(token)) {
    return "hint";
  }
  if (matchFieldNames1(token)) {
    return "field1";
  }
  if (matchFieldNames2(token)) {
    return "field2";
  }
  if (matchContact(token)) {
    return "contact";
  }
  if (matchWebauthn(token)) {
    return "webauthn";
  }
  return null;
}
function getControlGroups(type2) {
  const allGroups = [
    "text",
    "multiline",
    "password",
    "url",
    "username",
    "tel",
    "numeric",
    "month",
    "date"
  ];
  const mapping2 = {
    hidden: allGroups,
    text: allGroups.filter((it) => it !== "multiline"),
    search: allGroups.filter((it) => it !== "multiline"),
    password: ["password"],
    url: ["url"],
    email: ["username"],
    tel: ["tel"],
    number: ["numeric"],
    month: ["month"],
    date: ["date"]
  };
  return mapping2[type2] ?? [];
}
function isDisallowedType(node, type2) {
  if (!node.is("input")) {
    return false;
  }
  return disallowedInputTypes.includes(type2);
}
function getTerminalMessage(context) {
  switch (context.msg) {
    case 0:
      return "autocomplete attribute cannot be used on {{ what }}";
    case 1:
      return '"{{ value }}" cannot be used on {{ what }}';
    case 2:
      return '"{{ second }}" must appear before "{{ first }}"';
    case 3:
      return '"{{ token }}" is not a valid autocomplete token or field name';
    case 4:
      return '"{{ second }}" cannot be combined with "{{ first }}"';
    case 5:
      return "autocomplete attribute is missing field name";
  }
}
function getMarkdownMessage(context) {
  switch (context.msg) {
    case 0:
      return [
        `\`autocomplete\` attribute cannot be used on \`${context.what}\``,
        "",
        "The following input types cannot use the `autocomplete` attribute:",
        "",
        ...disallowedInputTypes.map((it) => `- \`${it}\``)
      ].join("\n");
    case 1: {
      const message = `\`"${context.value}"\` cannot be used on \`${context.what}\``;
      if (context.type === "form") {
        return [
          message,
          "",
          'The `<form>` element can only use the values `"on"` and `"off"`.'
        ].join("\n");
      }
      if (context.type === "hidden") {
        return [
          message,
          "",
          '`<input type="hidden">` cannot use the values `"on"` and `"off"`.'
        ].join("\n");
      }
      const controlGroups = getControlGroups(context.type);
      const currentGroup = fieldNameGroup[context.value];
      return [
        message,
        "",
        `\`${context.what}\` allows autocomplete fields from the following group${controlGroups.length > 1 ? "s" : ""}:`,
        "",
        ...controlGroups.map((it) => `- ${it}`),
        "",
        `The field \`"${context.value}"\` belongs to the group /${currentGroup}/ which cannot be used with this input type.`
      ].join("\n");
    }
    case 2:
      return [
        `\`"${context.second}"\` must appear before \`"${context.first}"\``,
        "",
        "The autocomplete tokens must appear in the following order:",
        "",
        "- Optional section name (`section-` prefix).",
        "- Optional `shipping` or `billing` token.",
        "- Optional `home`, `work`, `mobile`, `fax` or `pager` token (for fields supporting it).",
        "- Field name",
        "- Optional `webauthn` token."
      ].join("\n");
    case 3:
      return `\`"${context.token}"\` is not a valid autocomplete token or field name`;
    case 4:
      return `\`"${context.second}"\` cannot be combined with \`"${context.first}"\``;
    case 5:
      return "Autocomplete attribute is missing field name";
  }
}
var ValidAutocomplete = class extends Rule {
  documentation(context) {
    return {
      description: getMarkdownMessage(context),
      url: "https://html-validate.org/rules/valid-autocomplete.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const elements = document.querySelectorAll("[autocomplete]");
      for (const element of elements) {
        const autocomplete = element.getAttribute("autocomplete");
        if (autocomplete.value === null || autocomplete.value instanceof DynamicValue) {
          continue;
        }
        const location = autocomplete.valueLocation;
        const value = autocomplete.value.toLowerCase();
        const tokens = new DOMTokenList(value, location);
        if (tokens.length === 0) {
          continue;
        }
        this.validate(element, value, tokens, autocomplete.keyLocation, location);
      }
    });
  }
  validate(node, value, tokens, keyLocation, valueLocation) {
    switch (node.tagName) {
      case "form":
        this.validateFormAutocomplete(node, value, valueLocation);
        break;
      case "input":
      case "textarea":
      case "select":
        this.validateControlAutocomplete(node, tokens, keyLocation);
        break;
    }
  }
  validateControlAutocomplete(node, tokens, keyLocation) {
    const type2 = node.getAttributeValue("type") ?? "text";
    const mantle = type2 !== "hidden" ? "expectation" : "anchor";
    if (isDisallowedType(node, type2)) {
      const context = {
        msg: 0,
        what: `<input type="${type2}">`
      };
      this.report({
        node,
        message: getTerminalMessage(context),
        location: keyLocation,
        context
      });
      return;
    }
    if (tokens.includes("on") || tokens.includes("off")) {
      this.validateOnOff(node, mantle, tokens);
      return;
    }
    this.validateTokens(node, tokens, keyLocation);
  }
  validateFormAutocomplete(node, value, location) {
    const trimmed = value.trim();
    if (["on", "off"].includes(trimmed)) {
      return;
    }
    const context = {
      msg: 1,
      type: "form",
      value: trimmed,
      what: "<form>"
    };
    this.report({
      node,
      message: getTerminalMessage(context),
      location,
      context
    });
  }
  validateOnOff(node, mantle, tokens) {
    const index = tokens.findIndex((it) => it === "on" || it === "off");
    const value = tokens.item(index);
    const location = tokens.location(index);
    if (tokens.length > 1) {
      const context = {
        msg: 4,
        /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- it must be present of it wouldn't be found */
        first: tokens.item(index > 0 ? 0 : 1),
        second: value
      };
      this.report({
        node,
        message: getTerminalMessage(context),
        location,
        context
      });
    }
    switch (mantle) {
      case "expectation":
        return;
      case "anchor": {
        const context = {
          msg: 1,
          type: "hidden",
          value,
          what: `<input type="hidden">`
        };
        this.report({
          node,
          message: getTerminalMessage(context),
          location: tokens.location(0),
          context
        });
      }
    }
  }
  validateTokens(node, tokens, keyLocation) {
    const order = [];
    for (const { item, location } of tokens.iterator()) {
      const tokenType = matchToken(item);
      if (tokenType) {
        order.push(tokenType);
      } else {
        const context = {
          msg: 3,
          token: item
        };
        this.report({
          node,
          message: getTerminalMessage(context),
          location,
          context
        });
        return;
      }
    }
    const fieldTokens = order.map((it) => it === "field1" || it === "field2");
    this.validateFieldPresence(node, tokens, fieldTokens, keyLocation);
    this.validateContact(node, tokens, order);
    this.validateOrder(node, tokens, order);
    this.validateControlGroup(node, tokens, fieldTokens);
  }
  /**
   * Ensure that exactly one field name is present from the two field lists.
   */
  validateFieldPresence(node, tokens, fieldTokens, keyLocation) {
    const numFields = fieldTokens.filter(Boolean).length;
    if (numFields === 0) {
      const context = {
        msg: 5
        /* MissingField */
      };
      this.report({
        node,
        message: getTerminalMessage(context),
        location: keyLocation,
        context
      });
    } else if (numFields > 1) {
      const a = fieldTokens.indexOf(true);
      const b = fieldTokens.lastIndexOf(true);
      const context = {
        msg: 4,
        /* eslint-disable @typescript-eslint/no-non-null-assertion -- it must be present of it wouldn't be found */
        first: tokens.item(a),
        second: tokens.item(b)
        /* eslint-enable @typescript-eslint/no-non-null-assertion */
      };
      this.report({
        node,
        message: getTerminalMessage(context),
        location: tokens.location(b),
        context
      });
    }
  }
  /**
   * Ensure contact token is only used with field names from the second list.
   */
  validateContact(node, tokens, order) {
    if (order.includes("contact") && order.includes("field1")) {
      const a = order.indexOf("field1");
      const b = order.indexOf("contact");
      const context = {
        msg: 4,
        /* eslint-disable @typescript-eslint/no-non-null-assertion -- it must be present of it wouldn't be found */
        first: tokens.item(a),
        second: tokens.item(b)
        /* eslint-enable @typescript-eslint/no-non-null-assertion */
      };
      this.report({
        node,
        message: getTerminalMessage(context),
        location: tokens.location(b),
        context
      });
    }
  }
  validateOrder(node, tokens, order) {
    const indicies = order.map((it) => expectedOrder.indexOf(it));
    for (let i = 0; i < indicies.length - 1; i++) {
      if (indicies[0] > indicies[i + 1]) {
        const context = {
          msg: 2,
          /* eslint-disable @typescript-eslint/no-non-null-assertion -- it must be present of it wouldn't be found */
          first: tokens.item(i),
          second: tokens.item(i + 1)
          /* eslint-enable @typescript-eslint/no-non-null-assertion */
        };
        this.report({
          node,
          message: getTerminalMessage(context),
          location: tokens.location(i + 1),
          context
        });
      }
    }
  }
  validateControlGroup(node, tokens, fieldTokens) {
    const numFields = fieldTokens.filter(Boolean).length;
    if (numFields === 0) {
      return;
    }
    if (!node.is("input")) {
      return;
    }
    const attr = node.getAttribute("type");
    const type2 = attr?.value ?? "text";
    if (type2 instanceof DynamicValue) {
      return;
    }
    const controlGroups = getControlGroups(type2);
    const fieldIndex = fieldTokens.indexOf(true);
    const fieldToken = tokens.item(fieldIndex);
    const fieldGroup = fieldNameGroup[fieldToken];
    if (!controlGroups.includes(fieldGroup)) {
      const context = {
        msg: 1,
        type: type2,
        value: fieldToken,
        what: `<input type="${type2}">`
      };
      this.report({
        node,
        message: getTerminalMessage(context),
        location: tokens.location(fieldIndex),
        context
      });
    }
  }
};
var defaults$4 = {
  relaxed: false
};
var ValidID = class extends Rule {
  constructor(options) {
    super({ ...defaults$4, ...options });
  }
  static schema() {
    return {
      relaxed: {
        type: "boolean"
      }
    };
  }
  documentation(context) {
    const { relaxed } = this.options;
    const { kind, id } = context;
    const message = this.messages[kind].replace(`"{{ id }}"`, "`{{ id }}`").replace("id", "ID").replace(/^(.)/, (m) => m.toUpperCase());
    const relaxedDescription = relaxed ? [] : [
      "  - ID must begin with a letter",
      "  - ID must only contain letters, digits, `-` and `_`"
    ];
    return {
      description: [
        `${interpolate(message, { id })}.`,
        "",
        "Under the current configuration the following rules are applied:",
        "",
        "  - ID must not be empty",
        "  - ID must not contain any whitespace characters",
        ...relaxedDescription
      ].join("\n"),
      url: "https://html-validate.org/rules/valid-id.html"
    };
  }
  setup() {
    this.on("attr", this.isRelevant, (event) => {
      const { value } = event;
      if (value === null || value instanceof DynamicValue) {
        return;
      }
      if (value === "") {
        const context = { kind: 1, id: value };
        this.report(event.target, this.messages[context.kind], event.location, context);
        return;
      }
      if (/\s/.exec(value)) {
        const context = { kind: 2, id: value };
        this.report(event.target, this.messages[context.kind], event.valueLocation, context);
        return;
      }
      const { relaxed } = this.options;
      if (relaxed) {
        return;
      }
      if (/^[^\p{L}]/u.exec(value)) {
        const context = { kind: 3, id: value };
        this.report(event.target, this.messages[context.kind], event.valueLocation, context);
        return;
      }
      if (/[^\p{L}\p{N}_-]/u.exec(value)) {
        const context = { kind: 4, id: value };
        this.report(event.target, this.messages[context.kind], event.valueLocation, context);
      }
    });
  }
  get messages() {
    return {
      [
        1
        /* EMPTY */
      ]: `element id "{{ id }}" must not be empty`,
      [
        2
        /* WHITESPACE */
      ]: `element id "{{ id }}" must not contain whitespace`,
      [
        3
        /* LEADING_CHARACTER */
      ]: `element id "{{ id }}" must begin with a letter`,
      [
        4
        /* DISALLOWED_CHARACTER */
      ]: `element id "{{ id }}" must only contain letters, digits, dash and underscore characters`
    };
  }
  isRelevant(event) {
    return event.key === "id";
  }
};
var VoidContent = class extends Rule {
  documentation(tagName) {
    const doc = {
      description: "HTML void elements cannot have any content and must not have content or end tag.",
      url: "https://html-validate.org/rules/void-content.html"
    };
    if (tagName) {
      doc.description = `<${tagName}> is a void element and must not have content or end tag.`;
    }
    return doc;
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.target;
      if (!node) {
        return;
      }
      if (!node.voidElement) {
        return;
      }
      if (node.closed === NodeClosed.EndTag) {
        this.report(
          null,
          `End tag for <${node.tagName}> must be omitted`,
          node.location,
          node.tagName
        );
      }
    });
  }
};
var defaults$3 = {
  style: "omit"
};
var VoidStyle = class extends Rule {
  style;
  constructor(options) {
    super({ ...defaults$3, ...options });
    this.style = parseStyle(this.options.style);
  }
  static schema() {
    return {
      style: {
        enum: ["omit", "selfclose", "selfclosing"],
        type: "string"
      }
    };
  }
  documentation(context) {
    const [desc, end] = styleDescription(context.style);
    return {
      description: `The current configuration requires void elements to ${desc}, use <${context.tagName}${end}> instead.`,
      url: "https://html-validate.org/rules/void-style.html"
    };
  }
  setup() {
    const { style } = this;
    const validateStyle = {
      [
        1
        /* AlwaysOmit */
      ]: this.validateOmitted.bind(this),
      [
        2
        /* AlwaysSelfclose */
      ]: this.validateSelfClosed.bind(this)
    }[style];
    this.on("tag:end", (event) => {
      const active = event.previous;
      if (active.meta) {
        validateStyle(active);
      }
    });
  }
  validateOmitted(node) {
    if (!node.voidElement) {
      return;
    }
    if (node.closed !== NodeClosed.VoidSelfClosed) {
      return;
    }
    this.reportError(
      node,
      `Expected omitted end tag <${node.tagName}> instead of self-closing element <${node.tagName}/>`
    );
  }
  validateSelfClosed(node) {
    if (!node.voidElement) {
      return;
    }
    if (node.closed !== NodeClosed.VoidOmitted) {
      return;
    }
    this.reportError(
      node,
      `Expected self-closing element <${node.tagName}/> instead of omitted end-tag <${node.tagName}>`
    );
  }
  reportError(node, message) {
    const context = {
      style: this.style,
      tagName: node.tagName
    };
    super.report(node, message, null, context);
  }
};
function parseStyle(name) {
  switch (name) {
    case "omit":
      return 1;
    case "selfclose":
    case "selfclosing":
      return 2;
    /* istanbul ignore next: covered by schema validation */
    default:
      throw new Error(`Invalid style "${name}" for "void-style" rule`);
  }
}
function styleDescription(style) {
  switch (style) {
    case 1:
      return ["omit end tag", ""];
    case 2:
      return ["be self-closed", "/"];
    // istanbul ignore next: will only happen if new styles are added, otherwise this isn't reached
    default:
      throw new Error(`Unknown style`);
  }
}
var H30 = class extends Rule {
  documentation() {
    return {
      description: "WCAG 2.1 requires each `<a href>` anchor link to have a text describing the purpose of the link using either plain text or an `<img>` with the `alt` attribute set.",
      url: "https://html-validate.org/rules/wcag/h30.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const links = event.document.getElementsByTagName("a");
      for (const link of links) {
        if (!link.hasAttribute("href")) {
          continue;
        }
        if (!inAccessibilityTree(link)) {
          continue;
        }
        const textClassification = classifyNodeText(link, { ignoreHiddenRoot: true });
        if (textClassification !== TextClassification.EMPTY_TEXT) {
          continue;
        }
        const images = link.querySelectorAll("img");
        if (images.some((image) => hasAltText(image))) {
          continue;
        }
        const labels = link.querySelectorAll("[aria-label]");
        if (hasAriaLabel(link) || labels.some((cur) => hasAriaLabel(cur))) {
          continue;
        }
        this.report(link, "Anchor link must have a text describing its purpose");
      }
    });
  }
};
var H32 = class extends Rule {
  documentation() {
    return {
      description: "WCAG 2.1 requires each `<form>` element to have at least one submit button.",
      url: "https://html-validate.org/rules/wcag/h32.html"
    };
  }
  setup() {
    const formTags = this.getTagsWithProperty("form");
    const formSelector = formTags.join(",");
    this.on("dom:ready", (event) => {
      const { document } = event;
      const forms = document.querySelectorAll(formSelector);
      for (const form of forms) {
        if (hasNestedSubmit(form)) {
          continue;
        }
        if (hasAssociatedSubmit(document, form)) {
          continue;
        }
        this.report(form, `<${form.tagName}> element must have a submit button`);
      }
    });
  }
};
function isSubmit(node) {
  const type2 = node.getAttribute("type");
  return !type2 || type2.valueMatches(/submit|image/);
}
function isAssociated(id, node) {
  const form = node.getAttribute("form");
  return Boolean(form?.valueMatches(id, true));
}
function hasNestedSubmit(form) {
  const matches = form.querySelectorAll("button,input").filter(isSubmit).filter((node) => !node.hasAttribute("form"));
  return matches.length > 0;
}
function hasAssociatedSubmit(document, form) {
  const { id } = form;
  if (!id) {
    return false;
  }
  const matches = document.querySelectorAll("button[form],input[form]").filter(isSubmit).filter((node) => isAssociated(id, node));
  return matches.length > 0;
}
var H36 = class extends Rule {
  documentation() {
    return {
      description: [
        "WCAG 2.1 requires all images used as submit buttons to have a non-empty textual description using the `alt` attribute.",
        'The alt text cannot be empty (`alt=""`).'
      ].join("\n"),
      url: "https://html-validate.org/rules/wcag/h36.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.previous;
      if (node.tagName !== "input") return;
      if (node.getAttributeValue("type") !== "image") {
        return;
      }
      if (!inAccessibilityTree(node)) {
        return;
      }
      if (!hasAltText(node)) {
        const message = "image used as submit button must have non-empty alt text";
        const alt = node.getAttribute("alt");
        this.report({
          node,
          message,
          location: alt ? alt.keyLocation : node.location
        });
      }
    });
  }
};
var defaults$2 = {
  allowEmpty: true,
  alias: []
};
var H37 = class extends Rule {
  constructor(options) {
    super({ ...defaults$2, ...options });
    if (!Array.isArray(this.options.alias)) {
      this.options.alias = [this.options.alias];
    }
  }
  static schema() {
    return {
      alias: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "string"
          }
        ]
      },
      allowEmpty: {
        type: "boolean"
      }
    };
  }
  documentation() {
    return {
      description: "Both HTML5 and WCAG 2.0 requires images to have a alternative text for each image.",
      url: "https://html-validate.org/rules/wcag/h37.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const nodes = document.querySelectorAll("img");
      for (const node of nodes) {
        this.validateNode(node);
      }
    });
  }
  validateNode(node) {
    if (!inAccessibilityTree(node)) {
      return;
    }
    if (Boolean(node.getAttributeValue("alt")) || node.hasAttribute("alt") && this.options.allowEmpty) {
      return;
    }
    for (const attr of this.options.alias) {
      if (node.getAttribute(attr)) {
        return;
      }
    }
    const tag = node.annotatedName;
    if (node.hasAttribute("alt")) {
      const attr = node.getAttribute("alt");
      this.report(node, `${tag} cannot have empty "alt" attribute`, attr.keyLocation);
    } else {
      this.report(node, `${tag} is missing required "alt" attribute`, node.location);
    }
  }
};
var defaults$1 = {
  strict: false
};
var { enum: validScopes } = html5.th.attributes?.scope;
var joinedScopes = naturalJoin(validScopes);
var td = 0;
var th = 1;
function getShape(cells) {
  const rows = cells.length;
  const cols = cells[0].length;
  return { rows, cols };
}
function isSimpleTable(table2) {
  const haveHeadersAttr = table2.querySelector("> tr > [headers], > tbody > tr > [headers]");
  if (haveHeadersAttr) {
    return false;
  }
  const rows = table2.querySelectorAll("> tr, > thead > tr, > tbody > tr");
  if (rows.length === 0) {
    return false;
  }
  const cells = rows.map((tr) => tr.querySelectorAll("> *").map((el) => el.is("th") ? th : td));
  if (cells[0].length === 0) {
    return false;
  }
  const numColumns = cells[0].length;
  if (!cells.every((row) => row.length === numColumns)) {
    return false;
  }
  const shape = getShape(cells);
  const headersPerRow = cells.map((row) => row.reduce((sum, cell) => sum + cell, 0));
  const headersPerColumn = Array(shape.cols).fill(0).map((_, index) => {
    return cells.reduce((sum, it) => sum + it[index], 0);
  });
  const [firstRow, ...otherRows] = headersPerRow;
  if (firstRow === shape.cols && otherRows.every((row) => row === 0)) {
    return true;
  }
  const [firstCol, ...otherCols] = headersPerColumn;
  const haveThead = Boolean(table2.querySelector("> thead"));
  if (firstCol === shape.rows && otherCols.every((col) => col === 0) && !haveThead) {
    return true;
  }
  return false;
}
var H63 = class extends Rule {
  constructor(options) {
    super({ ...defaults$1, ...options });
  }
  static schema() {
    return {
      strict: {
        type: "boolean"
      }
    };
  }
  documentation() {
    return {
      description: "H63: Using the scope attribute to associate header cells and data cells in data tables",
      url: "https://html-validate.org/rules/wcag/h63.html"
    };
  }
  setup() {
    const { strict } = this.options;
    this.on("element:ready", (event) => {
      const node = event.target;
      if (!node.is("table")) {
        return;
      }
      if (strict || !isSimpleTable(node)) {
        this.validateTable(node);
      }
    });
  }
  validateTable(node) {
    for (const th2 of node.querySelectorAll("th")) {
      const scope2 = th2.getAttribute("scope");
      const value = scope2?.value;
      if (value instanceof DynamicValue) {
        continue;
      }
      if (value && validScopes.includes(value)) {
        continue;
      }
      const message = `<th> element must have a valid scope attribute: ${joinedScopes}`;
      const location = scope2?.valueLocation ?? scope2?.keyLocation ?? th2.location;
      this.report(th2, message, location);
    }
  }
};
var H67 = class extends Rule {
  documentation() {
    return {
      description: "A decorative image cannot have a title attribute. Either remove `title` or add a descriptive `alt` text.",
      url: "https://html-validate.org/rules/wcag/h67.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.target;
      if (!node || node.tagName !== "img") {
        return;
      }
      const title2 = node.getAttribute("title");
      if (!title2 || title2.value === "") {
        return;
      }
      const alt = node.getAttributeValue("alt");
      if (alt && alt !== "") {
        return;
      }
      this.report(node, "<img> with empty alt text cannot have title attribute", title2.keyLocation);
    });
  }
};
var H71 = class extends Rule {
  documentation() {
    return {
      description: "H71: Providing a description for groups of form controls using fieldset and legend elements",
      url: "https://html-validate.org/rules/wcag/h71.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const fieldsets = document.querySelectorAll(this.selector);
      for (const fieldset of fieldsets) {
        this.validate(fieldset);
      }
    });
  }
  validate(fieldset) {
    const legend = fieldset.querySelectorAll("> legend");
    if (legend.length === 0) {
      this.reportNode(fieldset);
    }
  }
  reportNode(node) {
    super.report(node, `${node.annotatedName} must have a <legend> as the first child`);
  }
  get selector() {
    return this.getTagsDerivedFrom("fieldset").join(",");
  }
};
var bundledRules$1 = {
  "wcag/h30": H30,
  "wcag/h32": H32,
  "wcag/h36": H36,
  "wcag/h37": H37,
  "wcag/h63": H63,
  "wcag/h67": H67,
  "wcag/h71": H71
};
var bundledRules = {
  "allowed-links": AllowedLinks,
  "area-alt": AreaAlt,
  "aria-hidden-body": AriaHiddenBody,
  "aria-label-misuse": AriaLabelMisuse,
  "attr-case": AttrCase,
  "attr-delimiter": AttrDelimiter,
  "attr-pattern": AttrPattern,
  "attr-quotes": AttrQuotes,
  "attr-spacing": AttrSpacing,
  "attribute-allowed-values": AttributeAllowedValues,
  "attribute-boolean-style": AttributeBooleanStyle,
  "attribute-empty-style": AttributeEmptyStyle,
  "attribute-misuse": AttributeMisuse,
  "class-pattern": ClassPattern,
  "close-attr": CloseAttr,
  "close-order": CloseOrder,
  deprecated: Deprecated,
  "deprecated-rule": DeprecatedRule,
  "doctype-html": NoStyleTag$1,
  "doctype-style": DoctypeStyle,
  "element-case": ElementCase,
  "element-name": ElementName,
  "element-permitted-content": ElementPermittedContent,
  "element-permitted-occurrences": ElementPermittedOccurrences,
  "element-permitted-order": ElementPermittedOrder,
  "element-permitted-parent": ElementPermittedParent,
  "element-required-ancestor": ElementRequiredAncestor,
  "element-required-attributes": ElementRequiredAttributes,
  "element-required-content": ElementRequiredContent,
  "empty-heading": EmptyHeading,
  "empty-title": EmptyTitle,
  "form-dup-name": FormDupName,
  "heading-level": HeadingLevel,
  "hidden-focusable": HiddenFocusable,
  "id-pattern": IdPattern,
  "input-attributes": InputAttributes,
  "input-missing-label": InputMissingLabel,
  "long-title": LongTitle,
  "map-dup-name": MapDupName,
  "map-id-name": MapIdName,
  "meta-refresh": MetaRefresh,
  "missing-doctype": MissingDoctype,
  "multiple-labeled-controls": MultipleLabeledControls,
  "name-pattern": NamePattern,
  "no-abstract-role": NoAbstractRole,
  "no-autoplay": NoAutoplay,
  "no-conditional-comment": NoConditionalComment,
  "no-deprecated-attr": NoDeprecatedAttr,
  "no-dup-attr": NoDupAttr,
  "no-dup-class": NoDupClass,
  "no-dup-id": NoDupID,
  "no-implicit-button-type": NoImplicitButtonType,
  "no-implicit-input-type": NoImplicitInputType,
  "no-implicit-close": NoImplicitClose,
  "no-inline-style": NoInlineStyle,
  "no-missing-references": NoMissingReferences,
  "no-multiple-main": NoMultipleMain,
  "no-raw-characters": NoRawCharacters,
  "no-redundant-aria-label": NoRedundantAriaLabel,
  "no-redundant-for": NoRedundantFor,
  "no-redundant-role": NoRedundantRole,
  "no-self-closing": NoSelfClosing,
  "no-style-tag": NoStyleTag2,
  "no-trailing-whitespace": NoTrailingWhitespace,
  "no-unknown-elements": NoUnknownElements,
  "no-unused-disable": NoUnusedDisable,
  "no-utf8-bom": NoUtf8Bom,
  "prefer-button": PreferButton,
  "prefer-native-element": PreferNativeElement,
  "prefer-tbody": PreferTbody,
  "require-csp-nonce": RequireCSPNonce,
  "require-sri": RequireSri,
  "script-element": ScriptElement,
  "script-type": ScriptType,
  "svg-focusable": SvgFocusable,
  "tel-non-breaking": TelNonBreaking,
  "text-content": TextContent,
  "unique-landmark": UniqueLandmark,
  "unrecognized-char-ref": UnknownCharReference,
  "valid-autocomplete": ValidAutocomplete,
  "valid-id": ValidID,
  "void-content": VoidContent,
  "void-style": VoidStyle,
  ...bundledRules$1
};
function dumpTree(root) {
  const lines = [];
  function decoration(node) {
    let output = "";
    if (node.id) {
      output += `#${node.id}`;
    }
    if (node.hasAttribute("class")) {
      output += `.${node.classList.join(".")}`;
    }
    return output;
  }
  function writeNode(node, level, indent, sibling) {
    const numSiblings = node.parent ? node.parent.childElements.length : 0;
    const lastSibling = sibling === numSiblings - 1;
    if (node.parent) {
      const b = lastSibling ? "\u2514" : "\u251C";
      lines.push(`${indent}${b}\u2500\u2500 ${node.tagName}${decoration(node)}`);
    } else {
      lines.push("(root)");
    }
    node.childElements.forEach((child, index) => {
      const s = lastSibling ? " " : "\u2502";
      const i = level > 0 ? `${indent}${s}   ` : "";
      writeNode(child, level + 1, i, index);
    });
  }
  writeNode(root, 0, "", 0);
  return lines;
}
function isThenable(value) {
  return value && typeof value === "object" && "then" in value && typeof value.then === "function";
}
var ruleIds = new Set(Object.keys(bundledRules));
var defaultConfig = {};
var config$5 = {
  rules: {
    "area-alt": ["error", { accessible: true }],
    "aria-hidden-body": "error",
    "aria-label-misuse": ["error", { allowAnyNamable: false }],
    "deprecated-rule": "warn",
    "empty-heading": "error",
    "empty-title": "error",
    "hidden-focusable": "error",
    "meta-refresh": "error",
    "multiple-labeled-controls": "error",
    "no-abstract-role": "error",
    "no-autoplay": ["error", { include: ["audio", "video"] }],
    "no-dup-id": "error",
    "no-implicit-button-type": "error",
    "no-redundant-aria-label": "error",
    "no-redundant-for": "error",
    "no-redundant-role": "error",
    "prefer-native-element": "error",
    "svg-focusable": "off",
    "text-content": "error",
    "unique-landmark": "error",
    "valid-autocomplete": "error",
    "wcag/h30": "error",
    "wcag/h32": "error",
    "wcag/h36": "error",
    "wcag/h37": "error",
    "wcag/h63": "error",
    "wcag/h67": "error",
    "wcag/h71": "error"
  }
};
var config$4 = {
  rules: {
    /* doctype is usually not included when fetching source code from browser */
    "missing-doctype": "off",
    /* some frameworks (such as jQuery) often uses inline style, e.g. for
     * showing/hiding elements so it is counter-productive to check for inline
     * style. If anything it should be used on original sorce code only. */
    "no-inline-style": "off",
    /* scripts will often add markup with trailing whitespace */
    "no-trailing-whitespace": "off",
    /* browser normalizes boolean attributes */
    "attribute-boolean-style": "off",
    "attribute-empty-style": "off",
    /* the browser will often do what it wants, out of users control */
    "void-style": "off",
    "no-self-closing": "off"
  }
};
var config$3 = {
  rules: {
    "input-missing-label": "error",
    "heading-level": "error",
    "missing-doctype": "error",
    "no-missing-references": "error",
    "require-sri": "error"
  }
};
var config$2 = {
  rules: {
    "attr-quotes": "off",
    "doctype-style": "off",
    "void-style": "off"
  }
};
var config$1 = {
  rules: {
    "area-alt": ["error", { accessible: true }],
    "aria-hidden-body": "error",
    "aria-label-misuse": ["error", { allowAnyNamable: false }],
    "attr-case": "error",
    "attr-delimiter": "error",
    "attr-quotes": "error",
    "attr-spacing": "error",
    "attribute-allowed-values": "error",
    "attribute-boolean-style": "error",
    "attribute-empty-style": "error",
    "attribute-misuse": "error",
    "close-attr": "error",
    "close-order": "error",
    deprecated: "error",
    "deprecated-rule": "warn",
    "doctype-html": "error",
    "doctype-style": "error",
    "element-case": "error",
    "element-name": "error",
    "element-permitted-content": "error",
    "element-permitted-occurrences": "error",
    "element-permitted-order": "error",
    "element-permitted-parent": "error",
    "element-required-ancestor": "error",
    "element-required-attributes": "error",
    "element-required-content": "error",
    "empty-heading": "error",
    "empty-title": "error",
    "form-dup-name": "error",
    "hidden-focusable": "error",
    "input-attributes": "error",
    "long-title": "error",
    "map-dup-name": "error",
    "map-id-name": "error",
    "meta-refresh": "error",
    "multiple-labeled-controls": "error",
    "no-abstract-role": "error",
    "no-autoplay": ["error", { include: ["audio", "video"] }],
    "no-conditional-comment": "error",
    "no-deprecated-attr": "error",
    "no-dup-attr": "error",
    "no-dup-class": "error",
    "no-dup-id": "error",
    "no-implicit-button-type": "error",
    "no-implicit-input-type": "error",
    "no-implicit-close": "error",
    "no-inline-style": "error",
    "no-multiple-main": "error",
    "no-raw-characters": "error",
    "no-redundant-aria-label": "error",
    "no-redundant-for": "error",
    "no-redundant-role": "error",
    "no-self-closing": "error",
    "no-trailing-whitespace": "error",
    "no-utf8-bom": "error",
    "no-unused-disable": "error",
    "prefer-button": "error",
    "prefer-native-element": "error",
    "prefer-tbody": "error",
    "script-element": "error",
    "script-type": "error",
    "svg-focusable": "off",
    "tel-non-breaking": "error",
    "text-content": "error",
    "unique-landmark": "error",
    "unrecognized-char-ref": "error",
    "valid-autocomplete": "error",
    "valid-id": ["error", { relaxed: false }],
    void: "off",
    "void-content": "error",
    "void-style": "error",
    "wcag/h30": "error",
    "wcag/h32": "error",
    "wcag/h36": "error",
    "wcag/h37": "error",
    "wcag/h63": "error",
    "wcag/h67": "error",
    "wcag/h71": "error"
  }
};
var config = {
  rules: {
    "area-alt": ["error", { accessible: false }],
    "aria-label-misuse": ["error", { allowAnyNamable: true }],
    "attr-spacing": "error",
    "attribute-allowed-values": "error",
    "attribute-misuse": "error",
    "close-attr": "error",
    "close-order": "error",
    deprecated: "error",
    "deprecated-rule": "warn",
    "doctype-html": "error",
    "element-name": "error",
    "element-permitted-content": "error",
    "element-permitted-occurrences": "error",
    "element-permitted-order": "error",
    "element-permitted-parent": "error",
    "element-required-ancestor": "error",
    "element-required-attributes": "error",
    "element-required-content": "error",
    "map-dup-name": "error",
    "map-id-name": "error",
    "multiple-labeled-controls": "error",
    "no-abstract-role": "error",
    "no-deprecated-attr": "error",
    "no-dup-attr": "error",
    "no-dup-id": "error",
    "no-multiple-main": "error",
    "no-raw-characters": ["error", { relaxed: true }],
    "no-unused-disable": "error",
    "script-element": "error",
    "unrecognized-char-ref": "error",
    "valid-autocomplete": "error",
    "valid-id": ["error", { relaxed: true }],
    "void-content": "error"
  }
};
var presets = {
  "html-validate:a11y": config$5,
  "html-validate:browser": config$4,
  "html-validate:document": config$3,
  "html-validate:prettier": config$2,
  "html-validate:recommended": config$1,
  "html-validate:standard": config
};
var ResolvedConfig = class {
  metaTable;
  plugins;
  rules;
  transformers;
  /** The original data this resolved configuration was created from */
  original;
  /**
   * @internal
   */
  cache;
  /**
   * @internal
   */
  constructor({ metaTable, plugins, rules, transformers }, original) {
    this.metaTable = metaTable;
    this.plugins = plugins;
    this.rules = rules;
    this.transformers = transformers;
    this.cache = /* @__PURE__ */ new Map();
    this.original = original;
  }
  /**
   * Returns the (merged) configuration data used to create this resolved
   * configuration.
   */
  getConfigData() {
    return this.original;
  }
  getMetaTable() {
    return this.metaTable;
  }
  getPlugins() {
    return this.plugins;
  }
  getRules() {
    return this.rules;
  }
  /**
   * Returns true if a transformer matches given filename.
   *
   * @public
   */
  canTransform(filename) {
    return Boolean(this.findTransformer(filename));
  }
  /**
   * @internal
   */
  findTransformer(filename) {
    const match2 = this.transformers.find((entry) => entry.pattern.test(filename));
    return match2 ?? null;
  }
};
function haveResolver(key, value) {
  return key in value;
}
function haveConfigResolver(value) {
  return haveResolver("resolveConfig", value);
}
function haveElementsResolver(value) {
  return haveResolver("resolveElements", value);
}
function havePluginResolver(value) {
  return haveResolver("resolvePlugin", value);
}
function haveTransformerResolver(value) {
  return haveResolver("resolveTransformer", value);
}
function resolveConfig(resolvers, id, options) {
  for (const resolver2 of resolvers.filter(haveConfigResolver)) {
    const config2 = resolver2.resolveConfig(id, options);
    if (isThenable(config2)) {
      return resolveConfigAsync(resolvers, id, options);
    }
    if (config2) {
      return config2;
    }
  }
  throw new UserError(`Failed to load configuration from "${id}"`);
}
async function resolveConfigAsync(resolvers, id, options) {
  for (const resolver2 of resolvers.filter(haveConfigResolver)) {
    const config2 = await resolver2.resolveConfig(id, options);
    if (config2) {
      return config2;
    }
  }
  throw new UserError(`Failed to load configuration from "${id}"`);
}
function resolveElements(resolvers, id, options) {
  for (const resolver2 of resolvers.filter(haveElementsResolver)) {
    const elements = resolver2.resolveElements(id, options);
    if (isThenable(elements)) {
      return resolveElementsAsync(resolvers, id, options);
    }
    if (elements) {
      return elements;
    }
  }
  throw new UserError(`Failed to load elements from "${id}"`);
}
async function resolveElementsAsync(resolvers, id, options) {
  for (const resolver2 of resolvers.filter(haveElementsResolver)) {
    const elements = await resolver2.resolveElements(id, options);
    if (elements) {
      return elements;
    }
  }
  throw new UserError(`Failed to load elements from "${id}"`);
}
function resolvePlugin(resolvers, id, options) {
  for (const resolver2 of resolvers.filter(havePluginResolver)) {
    const plugin = resolver2.resolvePlugin(id, options);
    if (isThenable(plugin)) {
      return resolvePluginAsync(resolvers, id, options);
    }
    if (plugin) {
      return plugin;
    }
  }
  throw new UserError(`Failed to load plugin from "${id}"`);
}
async function resolvePluginAsync(resolvers, id, options) {
  for (const resolver2 of resolvers.filter(havePluginResolver)) {
    const plugin = await resolver2.resolvePlugin(id, options);
    if (plugin) {
      return plugin;
    }
  }
  throw new UserError(`Failed to load plugin from "${id}"`);
}
function resolveTransformer(resolvers, id, options) {
  for (const resolver2 of resolvers.filter(haveTransformerResolver)) {
    const transformer = resolver2.resolveTransformer(id, options);
    if (isThenable(transformer)) {
      return resolveTransformerAsync(resolvers, id, options);
    }
    if (transformer) {
      return transformer;
    }
  }
  throw new UserError(`Failed to load transformer from "${id}"`);
}
async function resolveTransformerAsync(resolvers, id, options) {
  for (const resolver2 of resolvers.filter(haveTransformerResolver)) {
    const transformer = await resolver2.resolveTransformer(id, options);
    if (transformer) {
      return transformer;
    }
  }
  throw new UserError(`Failed to load transformer from "${id}"`);
}
var ajv = new import_ajv.default({ strict: true, strictTuples: true, strictTypes: true });
ajv.addMetaSchema(ajvSchemaDraft);
ajv.addKeyword(ajvFunctionKeyword);
var validator = ajv.compile(configurationSchema);
function overwriteMerge(_a, b) {
  return b;
}
function mergeInternal(base, rhs) {
  const dst = deepmerge(base, { ...rhs, rules: {} });
  if (rhs.rules) {
    dst.rules = deepmerge(dst.rules, rhs.rules, { arrayMerge: overwriteMerge });
  }
  const root = Boolean(base.root) || Boolean(rhs.root);
  if (root) {
    dst.root = root;
  }
  return dst;
}
function toArray$1(value) {
  if (Array.isArray(value)) {
    return value;
  } else {
    return [value];
  }
}
function transformerEntries(transform) {
  return Object.entries(transform).map(([pattern, value]) => {
    const regex = new RegExp(pattern);
    if (typeof value === "string") {
      return { kind: "import", pattern: regex, name: value };
    } else {
      return { kind: "function", pattern: regex, function: value };
    }
  });
}
var Config = class _Config {
  config;
  configurations;
  resolvers;
  metaTable;
  plugins;
  transformers = [];
  /**
   * Create a new blank configuration. See also `Config.defaultConfig()`.
   */
  static empty() {
    return new _Config([], {
      extends: [],
      rules: {},
      plugins: [],
      transform: {}
    });
  }
  /**
   * Create configuration from object.
   */
  static fromObject(resolvers, options, filename = null) {
    _Config.validate(options, filename);
    return _Config.create(resolvers, options);
  }
  /**
   * Read configuration from filename.
   *
   * Note: this reads configuration data from a file. If you intent to load
   * configuration for a file to validate use `ConfigLoader.fromTarget()`.
   *
   * @internal
   * @param filename - The file to read from
   */
  static fromFile(resolvers, filename) {
    const configData = resolveConfig(toArray$1(resolvers), filename, { cache: false });
    if (isThenable(configData)) {
      return configData.then((configData2) => _Config.fromObject(resolvers, configData2, filename));
    } else {
      return _Config.fromObject(resolvers, configData, filename);
    }
  }
  /**
   * Validate configuration data.
   *
   * Throws SchemaValidationError if invalid.
   *
   * @internal
   */
  static validate(configData, filename = null) {
    const valid = validator(configData);
    if (!valid) {
      throw new SchemaValidationError(
        filename,
        `Invalid configuration`,
        configData,
        configurationSchema,
        /* istanbul ignore next: will be set when a validation error has occurred */
        validator.errors ?? []
      );
    }
    if (configData.rules) {
      const normalizedRules = _Config.getRulesObject(configData.rules);
      for (const [ruleId, [, ruleOptions]] of normalizedRules.entries()) {
        const cls = bundledRules[ruleId];
        const path5 = `/rules/${ruleId}/1`;
        Rule.validateOptions(cls, ruleId, path5, ruleOptions, filename, configData);
      }
    }
  }
  /**
   * Load a default configuration object.
   */
  static defaultConfig() {
    return new _Config([], defaultConfig);
  }
  /**
   * @internal
   */
  static create(resolvers, options) {
    const instance = new _Config(resolvers, options);
    const plugins = instance.loadPlugins(instance.config.plugins ?? []);
    if (isThenable(plugins)) {
      return plugins.then((plugins2) => {
        return instance.init(options, plugins2);
      });
    } else {
      return instance.init(options, plugins);
    }
  }
  init(options, plugins) {
    this.plugins = plugins;
    this.configurations = this.loadConfigurations(this.plugins);
    this.extendMeta(this.plugins);
    const update = (extendedConfig2) => {
      this.config = extendedConfig2;
      this.config.extends = [];
      if (options.rules) {
        this.config = mergeInternal(this.config, { rules: options.rules });
      }
      return this;
    };
    const extendedConfig = this.extendConfig(this.config.extends ?? []);
    if (isThenable(extendedConfig)) {
      return extendedConfig.then((extended) => update(extended));
    } else {
      return update(extendedConfig);
    }
  }
  /**
   * @internal
   */
  constructor(resolvers, options) {
    const initial = {
      extends: [],
      plugins: [],
      rules: {},
      transform: {}
    };
    this.config = mergeInternal(initial, options);
    this.configurations = /* @__PURE__ */ new Map();
    this.resolvers = toArray$1(resolvers);
    this.metaTable = null;
    this.plugins = [];
    this.transformers = transformerEntries(this.config.transform ?? {});
  }
  /**
   * Returns true if this configuration is marked as "root".
   */
  isRootFound() {
    return Boolean(this.config.root);
  }
  /**
   * Returns a new configuration as a merge of the two. Entries from the passed
   * object takes priority over this object.
   *
   * @public
   * @param rhs - Configuration to merge with this one.
   */
  merge(resolvers, rhs) {
    const instance = new _Config(resolvers, mergeInternal(this.config, rhs.config));
    const plugins = instance.loadPlugins(instance.config.plugins ?? []);
    if (isThenable(plugins)) {
      return plugins.then((plugins2) => {
        instance.plugins = plugins2;
        instance.configurations = instance.loadConfigurations(instance.plugins);
        instance.extendMeta(instance.plugins);
        return instance;
      });
    } else {
      instance.plugins = plugins;
      instance.configurations = instance.loadConfigurations(instance.plugins);
      instance.extendMeta(instance.plugins);
      return instance;
    }
  }
  extendConfig(entries) {
    if (entries.length === 0) {
      return this.config;
    }
    let base = {};
    for (const entry of entries) {
      let extended;
      if (this.configurations.has(entry)) {
        extended = this.configurations.get(entry);
      } else {
        const loadedConfig = _Config.fromFile(this.resolvers, entry);
        if (isThenable(loadedConfig)) {
          return this.extendConfigAsync(entries);
        }
        extended = loadedConfig.config;
      }
      base = mergeInternal(base, extended);
    }
    return mergeInternal(base, this.config);
  }
  async extendConfigAsync(entries) {
    let base = {};
    for (const entry of entries) {
      let extended;
      if (this.configurations.has(entry)) {
        extended = this.configurations.get(entry);
      } else {
        const loadedConfig = await _Config.fromFile(this.resolvers, entry);
        extended = loadedConfig.config;
      }
      base = mergeInternal(base, extended);
    }
    return mergeInternal(base, this.config);
  }
  /**
   * Get element metadata.
   *
   * @internal
   */
  getMetaTable() {
    if (this.metaTable) {
      return this.metaTable;
    }
    const metaTable = new MetaTable();
    for (const plugin of this.getPlugins()) {
      if (plugin.elementSchema) {
        metaTable.extendValidationSchema(plugin.elementSchema);
      }
    }
    const source = Array.from(this.config.elements ?? ["html5"]);
    const loadEntry = (entry) => {
      const result = this.getElementsFromEntry(entry);
      if (isThenable(result)) {
        return result.then((result2) => {
          const [obj, filename] = result2;
          metaTable.loadFromObject(obj, filename);
          const next2 = source.shift();
          if (next2) {
            return loadEntry(next2);
          }
        });
      } else {
        const [obj, filename] = result;
        metaTable.loadFromObject(obj, filename);
        const next2 = source.shift();
        if (next2) {
          return loadEntry(next2);
        }
      }
    };
    const next = source.shift();
    if (next) {
      const result = loadEntry(next);
      if (isThenable(result)) {
        return result.then(() => {
          metaTable.init();
          return this.metaTable = metaTable;
        });
      }
    }
    metaTable.init();
    return this.metaTable = metaTable;
  }
  getElementsFromEntry(entry) {
    if (typeof entry !== "string") {
      return [entry, null];
    }
    const bundled = bundledElements[entry];
    if (bundled) {
      return [bundled, null];
    }
    try {
      const obj = resolveElements(this.resolvers, entry, { cache: false });
      if (isThenable(obj)) {
        return obj.then((obj2) => {
          return [obj2, entry];
        });
      } else {
        return [obj, entry];
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      throw new ConfigError(
        `Failed to load elements from "${entry}": ${message}`,
        ensureError(err)
      );
    }
  }
  /**
   * Get a copy of internal configuration data.
   *
   * @internal primary purpose is unittests
   */
  /* istanbul ignore next: used for testing only */
  get() {
    return { ...this.config };
  }
  /**
   * Get all configured rules, their severity and options.
   *
   * @internal
   */
  getRules() {
    return _Config.getRulesObject(this.config.rules ?? {});
  }
  static getRulesObject(src) {
    const rules = /* @__PURE__ */ new Map();
    for (const [ruleId, data] of Object.entries(src)) {
      let options = data;
      if (!Array.isArray(options)) {
        options = [options, {}];
      } else if (options.length === 1) {
        options = [options[0], {}];
      }
      const severity = parseSeverity(options[0]);
      rules.set(ruleId, [severity, options[1]]);
    }
    return rules;
  }
  /**
   * Get all configured plugins.
   *
   * @internal
   */
  getPlugins() {
    return this.plugins;
  }
  /**
   * Get all configured transformers.
   *
   * @internal
   */
  getTransformers() {
    return this.transformers;
  }
  loadPlugins(plugins) {
    const loaded = [];
    const loading = Array.from(plugins);
    const loadPlugin = (entry, index) => {
      if (typeof entry !== "string") {
        const plugin = entry;
        plugin.name = plugin.name || `:unnamedPlugin@${String(index + 1)}`;
        plugin.originalName = `:unnamedPlugin@${String(index + 1)}`;
        loaded.push(plugin);
        const next2 = loading.shift();
        if (next2) {
          return loadPlugin(next2, index + 1);
        }
      } else {
        try {
          const plugin = resolvePlugin(this.resolvers, entry, { cache: true });
          if (isThenable(plugin)) {
            return plugin.then((plugin2) => {
              plugin2.name = plugin2.name || entry;
              plugin2.originalName = entry;
              loaded.push(plugin2);
              const next2 = loading.shift();
              if (next2) {
                return loadPlugin(next2, index + 1);
              }
            });
          } else {
            plugin.name = plugin.name || entry;
            plugin.originalName = entry;
            loaded.push(plugin);
            const next2 = loading.shift();
            if (next2) {
              return loadPlugin(next2, index + 1);
            }
          }
        } catch (err) {
          const message = err instanceof Error ? err.message : String(err);
          throw new ConfigError(`Failed to load plugin "${entry}": ${message}`, ensureError(err));
        }
      }
    };
    const next = loading.shift();
    if (next) {
      const result = loadPlugin(next, 0);
      if (isThenable(result)) {
        return result.then(() => {
          return loaded;
        });
      }
    }
    return loaded;
  }
  loadConfigurations(plugins) {
    const configs = /* @__PURE__ */ new Map();
    for (const [name, config2] of Object.entries(presets)) {
      _Config.validate(config2, name);
      configs.set(name, config2);
    }
    for (const plugin of plugins) {
      for (const [name, config2] of Object.entries(plugin.configs ?? {})) {
        if (!config2) continue;
        _Config.validate(config2, name);
        configs.set(`${plugin.name}:${name}`, config2);
        if (plugin.name !== plugin.originalName) {
          configs.set(`${plugin.originalName}:${name}`, config2);
        }
      }
    }
    return configs;
  }
  extendMeta(plugins) {
    for (const plugin of plugins) {
      if (!plugin.elementSchema) {
        continue;
      }
      const { properties: properties2 } = plugin.elementSchema;
      if (!properties2) {
        continue;
      }
      for (const [raw, schema2] of Object.entries(properties2)) {
        const key = raw;
        if (schema2.copyable && !MetaCopyableProperty.includes(key)) {
          MetaCopyableProperty.push(key);
        }
      }
    }
  }
  /**
   * Resolve all configuration and return a [[ResolvedConfig]] instance.
   *
   * A resolved configuration will merge all extended configs and load all
   * plugins and transformers, and normalize the rest of the configuration.
   *
   * @public
   */
  resolve() {
    const resolveData = this.resolveData();
    if (isThenable(resolveData)) {
      return resolveData.then((resolveData2) => {
        return new ResolvedConfig(resolveData2, this.get());
      });
    } else {
      return new ResolvedConfig(resolveData, this.get());
    }
  }
  /**
   * Same as [[resolve]] but returns the raw configuration data instead of
   * [[ResolvedConfig]] instance. Mainly used for testing.
   *
   * @internal
   */
  resolveData() {
    const metaTable = this.getMetaTable();
    if (isThenable(metaTable)) {
      return metaTable.then((metaTable2) => {
        return {
          metaTable: metaTable2,
          plugins: this.getPlugins(),
          rules: this.getRules(),
          transformers: this.transformers
        };
      });
    } else {
      return {
        metaTable,
        plugins: this.getPlugins(),
        rules: this.getRules(),
        transformers: this.transformers
      };
    }
  }
};
var ConfigLoader = class {
  _globalConfig;
  _configData;
  resolvers;
  /**
   * Create a new ConfigLoader.
   *
   * @param resolvers - Sorted list of resolvers to use (in order).
   * @param configData - Default configuration (which all configurations will inherit from).
   */
  constructor(resolvers, configData) {
    this.resolvers = resolvers;
    this._configData = configData;
    this._globalConfig = null;
  }
  /**
   * Set a new default configuration on this loader. Resets cached global
   * configuration.
   *
   * @internal
   */
  setConfigData(configData) {
    this._configData = configData;
    this._globalConfig = null;
  }
  /**
   * Get the global configuration.
   *
   * @returns A promise resolving to the global configuration.
   */
  getGlobalConfig() {
    if (this._globalConfig) {
      return this._globalConfig;
    }
    const config2 = this._configData ? this.loadFromObject(this._configData) : this.defaultConfig();
    if (isThenable(config2)) {
      return config2.then((config22) => {
        this._globalConfig = config22;
        return this._globalConfig;
      });
    } else {
      this._globalConfig = config2;
      return this._globalConfig;
    }
  }
  /**
   * Get the global configuration.
   *
   * The synchronous version does not support async resolvers.
   *
   * @returns The global configuration.
   */
  getGlobalConfigSync() {
    if (this._globalConfig) {
      return this._globalConfig;
    }
    const config2 = this._configData ? this.loadFromObject(this._configData) : this.defaultConfig();
    if (isThenable(config2)) {
      throw new UserError("Cannot load async config from sync function");
    }
    this._globalConfig = config2;
    return this._globalConfig;
  }
  /**
   * @internal
   */
  getResolvers() {
    return this.resolvers;
  }
  /**
   * @internal For testing only
   */
  async _getGlobalConfig() {
    const config2 = await this.getGlobalConfig();
    return config2.get();
  }
  empty() {
    return Config.empty();
  }
  /**
   * Load configuration from object.
   */
  loadFromObject(options, filename) {
    return Config.fromObject(this.resolvers, options, filename);
  }
  /**
   * Load configuration from filename.
   */
  loadFromFile(filename) {
    return Config.fromFile(this.resolvers, filename);
  }
};
var defaultResolvers = [];
function hasResolver(value) {
  return Array.isArray(value[0]);
}
var StaticConfigLoader = class extends ConfigLoader {
  constructor(...args) {
    if (hasResolver(args)) {
      const [resolvers, config2] = args;
      super(resolvers, config2);
    } else {
      const [config2] = args;
      super(defaultResolvers, config2);
    }
  }
  /**
   * Set a new configuration for this loader.
   *
   * @public
   * @since 8.20.0
   * @param config - New configuration to use.
   */
  setConfig(config2) {
    this.setConfigData(config2);
  }
  getConfigFor(_handle, configOverride) {
    const override = this.loadFromObject(configOverride ?? {});
    if (isThenable(override)) {
      return override.then((override2) => this._resolveConfig(override2));
    } else {
      return this._resolveConfig(override);
    }
  }
  flushCache() {
  }
  defaultConfig() {
    return this.loadFromObject({
      extends: ["html-validate:recommended"],
      elements: ["html5"]
    });
  }
  _resolveConfig(override) {
    if (override.isRootFound()) {
      return override.resolve();
    }
    const globalConfig = this.getGlobalConfig();
    if (isThenable(globalConfig)) {
      return globalConfig.then((globalConfig2) => {
        const merged = globalConfig2.merge(this.resolvers, override);
        if (isThenable(merged)) {
          return merged.then((merged2) => {
            return merged2.resolve();
          });
        } else {
          return merged.resolve();
        }
      });
    } else {
      const merged = globalConfig.merge(this.resolvers, override);
      if (isThenable(merged)) {
        return merged.then((merged2) => {
          return merged2.resolve();
        });
      } else {
        return merged.resolve();
      }
    }
  }
};
var EventHandler = class {
  listeners;
  constructor() {
    this.listeners = {};
  }
  /**
   * Add an event listener.
   *
   * @param event - Event names (comma separated) or '*' for any event.
   * @param callback - Called any time even triggers.
   * @returns Unregistration function.
   */
  on(event, callback) {
    const { listeners } = this;
    const names = event.split(",").map((it) => it.trim());
    for (const name of names) {
      const list = listeners[name] ?? [];
      listeners[name] = list;
      list.push(callback);
    }
    return () => {
      for (const name of names) {
        const list = listeners[name];
        this.listeners[name] = list.filter((fn) => fn !== callback);
      }
    };
  }
  /**
   * Add a onetime event listener. The listener will automatically be removed
   * after being triggered once.
   *
   * @param event - Event names (comma separated) or '*' for any event.
   * @param callback - Called any time even triggers.
   * @returns Unregistration function.
   */
  once(event, callback) {
    const deregister = this.on(event, (event2, data) => {
      callback(event2, data);
      deregister();
    });
    return deregister;
  }
  /**
   * Trigger event causing all listeners to be called.
   *
   * @param event - Event name.
   * @param data - Event data.
   */
  trigger(event, data) {
    for (const listener of this.getCallbacks(event)) {
      listener.call(null, event, data);
    }
  }
  getCallbacks(event) {
    const { listeners } = this;
    const callbacks = listeners[event] ?? [];
    const global = listeners["*"] ?? [];
    return [...callbacks, ...global];
  }
};
var version = "10.0.0";
function freeze(src) {
  return {
    ...src,
    selector: src.selector()
  };
}
function isThenableArray(value) {
  if (value.length === 0) {
    return false;
  }
  return isThenable(value[0]);
}
var Reporter = class {
  result;
  constructor() {
    this.result = {};
  }
  static merge(reports) {
    if (isThenable(reports)) {
      return reports.then((reports2) => this.merge(reports2));
    }
    if (isThenableArray(reports)) {
      return Promise.all(reports).then((reports2) => this.merge(reports2));
    }
    const valid = reports.every((report) => report.valid);
    const merged = {};
    reports.forEach((report) => {
      report.results.forEach((result) => {
        const key = result.filePath;
        if (key in merged) {
          merged[key].messages = [...merged[key].messages, ...result.messages];
        } else {
          merged[key] = { ...result };
        }
      });
    });
    const results = Object.values(merged).map((result) => {
      result.errorCount = countErrors(result.messages);
      result.warningCount = countWarnings(result.messages);
      return result;
    });
    return {
      valid,
      results,
      errorCount: sumErrors(results),
      warningCount: sumWarnings(results)
    };
  }
  add(rule, message, severity, node, location, context) {
    if (!(location.filename in this.result)) {
      this.result[location.filename] = [];
    }
    const ruleUrl = rule.documentation(context)?.url;
    const entry = {
      ruleId: rule.name,
      severity,
      message,
      offset: location.offset,
      line: location.line,
      column: location.column,
      size: location.size || 0,
      selector() {
        return node ? node.generateSelector() : null;
      }
    };
    if (ruleUrl) {
      entry.ruleUrl = ruleUrl;
    }
    if (context) {
      entry.context = context;
    }
    this.result[location.filename].push(entry);
  }
  addManual(filename, message) {
    if (!(filename in this.result)) {
      this.result[filename] = [];
    }
    this.result[filename].push(message);
  }
  save(sources) {
    const report = {
      valid: this.isValid(),
      results: Object.keys(this.result).map((filePath) => {
        const messages = Array.from(this.result[filePath], freeze).sort(messageSort);
        const source = (sources ?? []).find((source2) => filePath === source2.filename);
        return {
          filePath,
          messages,
          errorCount: countErrors(messages),
          warningCount: countWarnings(messages),
          source: source ? source.originalData ?? source.data : null
        };
      }),
      errorCount: 0,
      warningCount: 0
    };
    report.errorCount = sumErrors(report.results);
    report.warningCount = sumWarnings(report.results);
    return report;
  }
  isValid() {
    const numErrors = Object.values(this.result).reduce((sum, messages) => {
      return sum + countErrors(messages);
    }, 0);
    return numErrors === 0;
  }
};
function countErrors(messages) {
  return messages.filter((m) => m.severity === Number(Severity.ERROR)).length;
}
function countWarnings(messages) {
  return messages.filter((m) => m.severity === Number(Severity.WARN)).length;
}
function sumErrors(results) {
  return results.reduce((sum, result) => {
    return sum + result.errorCount;
  }, 0);
}
function sumWarnings(results) {
  return results.reduce((sum, result) => {
    return sum + result.warningCount;
  }, 0);
}
function messageSort(a, b) {
  if (a.line < b.line) {
    return -1;
  }
  if (a.line > b.line) {
    return 1;
  }
  if (a.column < b.column) {
    return -1;
  }
  if (a.column > b.column) {
    return 1;
  }
  return 0;
}
var regexp = /<!(?:--)?\[(.*?)\](?:--)?>/g;
function* parseConditionalComment(comment, commentLocation) {
  let match2;
  while ((match2 = regexp.exec(comment)) !== null) {
    const expression = match2[1];
    const begin = match2.index;
    const end = begin + match2[0].length;
    const location = sliceLocation(commentLocation, begin, end, comment);
    yield {
      expression,
      location
    };
  }
}
var ParserError = class extends Error {
  location;
  constructor(location, message) {
    super(message);
    this.location = location;
  }
};
function isAttrValueToken(token) {
  return Boolean(token && token.type === TokenType.ATTR_VALUE);
}
function svgShouldRetainTag(foreignTagName, tagName) {
  return foreignTagName === "svg" && ["title", "desc"].includes(tagName);
}
function isValidDirective(action) {
  const validActions = ["enable", "disable", "disable-block", "disable-next"];
  return validActions.includes(action);
}
var Parser = class {
  event;
  metaTable;
  currentNamespace = "";
  dom;
  /**
   * Create a new parser instance.
   *
   * @public
   * @param config - Configuration
   */
  constructor(config2) {
    this.event = new EventHandler();
    this.dom = null;
    this.metaTable = config2.getMetaTable();
  }
  /**
   * Parse HTML markup.
   *
   * @public
   * @param source - HTML markup.
   * @returns DOM tree representing the HTML markup.
   */
  parseHtml(source) {
    if (typeof source === "string") {
      source = {
        data: source,
        filename: "inline",
        line: 1,
        column: 1,
        offset: 0
      };
    }
    this.trigger("parse:begin", {
      location: null
    });
    this.dom = new DOMTree({
      filename: source.filename,
      offset: source.offset,
      line: source.line,
      column: source.column,
      size: 0
    });
    this.trigger("dom:load", {
      source,
      location: null
    });
    const lexer = new Lexer();
    const tokenStream = lexer.tokenize(source);
    let it = this.next(tokenStream);
    while (!it.done) {
      const token = it.value;
      this.consume(source, token, tokenStream);
      it = this.next(tokenStream);
    }
    this.dom.resolveMeta(this.metaTable);
    this.dom.root.cacheEnable();
    this.trigger("dom:ready", {
      document: this.dom,
      source,
      /* disable location for this event so rules can use implicit node location
       * instead */
      location: null
    });
    this.trigger("parse:end", {
      location: null
    });
    return this.dom.root;
  }
  /**
   * Detect optional end tag.
   *
   * Some tags have optional end tags (e.g. <ul><li>foo<li>bar</ul> is
   * valid). The parser handles this by checking if the element on top of the
   * stack when is allowed to omit.
   */
  closeOptional(token) {
    const active = this.dom.getActive();
    if (!active.meta?.implicitClosed) {
      return false;
    }
    const tagName = token.data[2];
    const open = !token.data[1];
    const meta = active.meta.implicitClosed;
    if (open) {
      return meta.includes(tagName);
    } else {
      if (active.is(tagName)) {
        return false;
      }
      return Boolean(active.parent && active.parent.is(tagName) && meta.includes(active.tagName));
    }
  }
  /**
   * @internal
   */
  /* eslint-disable-next-line complexity -- there isn't really a good other way to structure this method (that is still readable) */
  consume(source, token, tokenStream) {
    switch (token.type) {
      case TokenType.UNICODE_BOM:
        break;
      case TokenType.TAG_OPEN:
        this.consumeTag(source, token, tokenStream);
        break;
      case TokenType.WHITESPACE:
        this.trigger("whitespace", {
          text: token.data[0],
          location: token.location
        });
        this.appendText(token.data[0], token.location);
        break;
      case TokenType.DIRECTIVE:
        this.consumeDirective(token);
        break;
      case TokenType.CONDITIONAL:
        this.consumeConditional(token);
        break;
      case TokenType.COMMENT:
        this.consumeComment(token);
        break;
      case TokenType.DOCTYPE_OPEN:
        this.consumeDoctype(token, tokenStream);
        break;
      case TokenType.TEXT:
      case TokenType.TEMPLATING:
        this.appendText(token.data[0], token.location);
        break;
      case TokenType.EOF:
        this.closeTree(source, token.location);
        break;
    }
  }
  /**
   * @internal
   */
  /* eslint-disable-next-line complexity -- technical debt, chould be refactored a bit */
  consumeTag(source, startToken, tokenStream) {
    const tokens = Array.from(
      this.consumeUntil(tokenStream, TokenType.TAG_CLOSE, startToken.location)
    );
    const endToken = tokens.slice(-1)[0];
    const closeOptional = this.closeOptional(startToken);
    const parent2 = closeOptional ? this.dom.getActive().parent : this.dom.getActive();
    const node = HtmlElement.fromTokens(
      startToken,
      endToken,
      parent2,
      this.metaTable,
      this.currentNamespace
    );
    const isStartTag = !startToken.data[1];
    const isClosing = !isStartTag || node.closed !== NodeClosed.Open;
    const isForeign = node.meta?.foreign;
    if (closeOptional) {
      const active = this.dom.getActive();
      active.closed = NodeClosed.ImplicitClosed;
      this.closeElement(source, node, active, startToken.location);
      this.dom.popActive();
    }
    if (isStartTag) {
      this.dom.pushActive(node);
      this.trigger("tag:start", {
        target: node,
        location: startToken.location
      });
    }
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      switch (token.type) {
        case TokenType.WHITESPACE:
          break;
        case TokenType.ATTR_NAME:
          this.consumeAttribute(source, node, token, tokens[i + 1]);
          break;
      }
    }
    if (isStartTag) {
      this.trigger("tag:ready", {
        target: node,
        location: endToken.location
      });
    }
    if (isClosing) {
      const active = this.dom.getActive();
      if (!isStartTag) {
        node.closed = NodeClosed.EndTag;
      }
      this.closeElement(source, node, active, endToken.location);
      const mismatched = node.tagName !== active.tagName;
      const voidClosed = !isStartTag && node.voidElement;
      if (!voidClosed && !mismatched) {
        this.dom.popActive();
      }
    } else if (isForeign) {
      this.discardForeignBody(source, node.tagName, tokenStream, startToken.location);
    }
  }
  /**
   * @internal
   */
  closeElement(source, node, active, location) {
    this.processElement(active, source);
    const event = {
      target: node,
      previous: active,
      location
    };
    this.trigger("tag:end", event);
    if (node && node.tagName !== active.tagName && active.closed !== NodeClosed.ImplicitClosed) {
      return;
    }
    if (!active.isRootElement()) {
      this.trigger("element:ready", {
        target: active,
        location: active.location
      });
    }
  }
  processElement(node, source) {
    node.cacheEnable();
    if (source.hooks?.processElement) {
      const processElement = source.hooks.processElement;
      const metaTable = this.metaTable;
      const context = {
        getMetaFor(tagName) {
          return metaTable.getMetaFor(tagName);
        }
      };
      processElement.call(context, node);
    }
  }
  /**
   * Discard tokens until the end tag for the foreign element is found.
   *
   * @internal
   */
  discardForeignBody(source, foreignTagName, tokenStream, errorLocation) {
    let nested = 1;
    let startToken;
    let endToken;
    do {
      const tokens = Array.from(this.consumeUntil(tokenStream, TokenType.TAG_OPEN, errorLocation));
      const [last] = tokens.slice(-1);
      const [, tagClosed, tagName] = last.data;
      if (!tagClosed && svgShouldRetainTag(foreignTagName, tagName)) {
        const oldNamespace = this.currentNamespace;
        this.currentNamespace = "svg";
        this.consumeTag(source, last, tokenStream);
        this.consumeUntilMatchingTag(source, tokenStream, tagName);
        this.currentNamespace = oldNamespace;
        continue;
      }
      if (tagName !== foreignTagName) {
        continue;
      }
      const endTokens = Array.from(
        this.consumeUntil(tokenStream, TokenType.TAG_CLOSE, last.location)
      );
      endToken = endTokens.slice(-1)[0];
      const selfClosed = endToken.data[0] === "/>";
      if (tagClosed) {
        startToken = last;
        nested--;
      } else if (!selfClosed) {
        nested++;
      }
    } while (nested > 0);
    if (!startToken || !endToken) {
      return;
    }
    const active = this.dom.getActive();
    const node = HtmlElement.fromTokens(startToken, endToken, active, this.metaTable);
    this.closeElement(source, node, active, endToken.location);
    this.dom.popActive();
  }
  /**
   * @internal
   */
  consumeAttribute(source, node, token, next) {
    const { meta } = node;
    const keyLocation = this.getAttributeKeyLocation(token);
    const valueLocation = this.getAttributeValueLocation(next);
    const location = this.getAttributeLocation(token, next);
    const haveValue = isAttrValueToken(next);
    const attrData = {
      key: token.data[1],
      value: null,
      quote: null
    };
    if (haveValue) {
      const [, , value, quote] = next.data;
      attrData.value = value;
      attrData.quote = quote ?? null;
    }
    let processAttribute = (attr) => [attr];
    if (source.hooks?.processAttribute) {
      processAttribute = source.hooks.processAttribute;
    }
    let iterator;
    const legacy = processAttribute.call({}, attrData);
    if (typeof legacy[Symbol.iterator] !== "function") {
      iterator = [attrData];
    } else {
      iterator = legacy;
    }
    for (const attr of iterator) {
      const event = {
        target: node,
        key: attr.key,
        value: attr.value,
        quote: attr.quote,
        originalAttribute: attr.originalAttribute,
        location,
        keyLocation,
        valueLocation,
        meta: meta?.attributes[attr.key] ?? null
      };
      this.trigger("attr", event);
      node.setAttribute(attr.key, attr.value, keyLocation, valueLocation, attr.originalAttribute);
    }
  }
  /**
   * Takes attribute key token an returns location.
   */
  getAttributeKeyLocation(token) {
    return token.location;
  }
  /**
   * Take attribute value token and return a new location referring to only the
   * value.
   *
   * foo="bar"    foo='bar'    foo=bar    foo      foo=""
   *      ^^^          ^^^         ^^^    (null)   (null)
   */
  getAttributeValueLocation(token) {
    if (!token || token.type !== TokenType.ATTR_VALUE || token.data[2] === "") {
      return null;
    }
    const quote = token.data[3];
    if (quote) {
      return sliceLocation(token.location, 2, -1);
    } else {
      return sliceLocation(token.location, 1);
    }
  }
  /**
   * Take attribute key and value token an returns a new location referring to
   * an aggregate location covering key, quotes if present and value.
   */
  getAttributeLocation(key, value) {
    const begin = key.location;
    const end = value && value.type === TokenType.ATTR_VALUE ? value.location : void 0;
    return {
      filename: begin.filename,
      line: begin.line,
      column: begin.column,
      size: begin.size + (end?.size ?? 0),
      offset: begin.offset
    };
  }
  /**
   * @internal
   */
  consumeDirective(token) {
    const [text, preamble, action, separator1, directive, postamble] = token.data;
    if (!postamble.startsWith("]")) {
      throw new ParserError(token.location, `Missing end bracket "]" on directive "${text}"`);
    }
    const match2 = /^(.*?)(?:(\s*(?:--|:)\s*)(.*))?$/.exec(directive);
    if (!match2) {
      throw new Error(`Failed to parse directive "${text}"`);
    }
    if (!isValidDirective(action)) {
      throw new ParserError(token.location, `Unknown directive "${action}"`);
    }
    const [, data, separator2, comment] = match2;
    const prefix = "html-validate-";
    const actionOffset = preamble.length;
    const optionsOffset = actionOffset + action.length + separator1.length;
    const commentOffset = optionsOffset + data.length + (separator2 || "").length;
    const location = sliceLocation(
      token.location,
      preamble.length - prefix.length - 1,
      -postamble.length + 1
    );
    const actionLocation = sliceLocation(
      token.location,
      actionOffset,
      actionOffset + action.length
    );
    const optionsLocation = data ? sliceLocation(token.location, optionsOffset, optionsOffset + data.length) : void 0;
    const commentLocation = comment ? sliceLocation(token.location, commentOffset, commentOffset + comment.length) : void 0;
    this.trigger("directive", {
      action,
      data,
      comment: comment || "",
      location,
      actionLocation,
      optionsLocation,
      commentLocation
    });
  }
  /**
   * Consumes conditional comment in tag form.
   *
   * See also the related [[consumeCommend]] method.
   *
   * @internal
   */
  consumeConditional(token) {
    const element = this.dom.getActive();
    this.trigger("conditional", {
      condition: token.data[1],
      location: token.location,
      parent: element
    });
  }
  /**
   * Consumes comment token.
   *
   * Tries to find IE conditional comments and emits conditional token if
   * found. See also the related [[consumeConditional]] method.
   *
   * @internal
   */
  consumeComment(token) {
    const comment = token.data[0];
    const element = this.dom.getActive();
    for (const conditional of parseConditionalComment(comment, token.location)) {
      this.trigger("conditional", {
        condition: conditional.expression,
        location: conditional.location,
        parent: element
      });
    }
  }
  /**
   * Consumes doctype tokens. Emits doctype event.
   *
   * @internal
   */
  consumeDoctype(startToken, tokenStream) {
    const tokens = Array.from(
      this.consumeUntil(tokenStream, TokenType.DOCTYPE_CLOSE, startToken.location)
    );
    const doctype = tokens[0];
    const value = doctype.data[0];
    this.dom.doctype = value;
    this.trigger("doctype", {
      tag: startToken.data[1],
      value,
      valueLocation: tokens[0].location,
      location: startToken.location
    });
  }
  /**
   * Return a list of tokens found until the expected token was found.
   *
   * @internal
   * @param errorLocation - What location to use if an error occurs
   */
  *consumeUntil(tokenStream, search, errorLocation) {
    let it = this.next(tokenStream);
    while (!it.done) {
      const token = it.value;
      yield token;
      if (token.type === search) return;
      it = this.next(tokenStream);
    }
    throw new ParserError(
      errorLocation,
      `stream ended before ${TokenType[search]} token was found`
    );
  }
  /**
   * Consumes tokens until a matching close-tag is found. Tags are appended to
   * the document.
   *
   * @internal
   */
  consumeUntilMatchingTag(source, tokenStream, searchTag) {
    let numOpen = 1;
    let it = this.next(tokenStream);
    while (!it.done) {
      const token = it.value;
      this.consume(source, token, tokenStream);
      if (token.type === TokenType.TAG_OPEN) {
        const [, close, tagName] = token.data;
        if (tagName === searchTag) {
          if (close) {
            numOpen--;
          } else {
            numOpen++;
          }
          if (numOpen === 0) {
            return;
          }
        }
      }
      it = this.next(tokenStream);
    }
  }
  next(tokenStream) {
    const it = tokenStream.next();
    if (!it.done) {
      const token = it.value;
      this.trigger("token", {
        location: token.location,
        type: token.type,
        data: Array.from(token.data),
        token
      });
    }
    return it;
  }
  on(event, listener) {
    return this.event.on(event, listener);
  }
  once(event, listener) {
    return this.event.once(event, listener);
  }
  /**
   * Defer execution. Will call function sometime later.
   *
   * @internal
   * @param cb - Callback to execute later.
   */
  defer(cb) {
    this.event.once("*", cb);
  }
  trigger(event, data) {
    if (typeof data.location === "undefined") {
      throw new Error("Triggered event must contain location");
    }
    this.event.trigger(event, data);
  }
  /**
   * @internal
   */
  getEventHandler() {
    return this.event;
  }
  /**
   * Appends a text node to the current element on the stack.
   */
  appendText(text, location) {
    this.dom.getActive().appendText(text, location);
  }
  /**
   * Trigger close events for any still open elements.
   */
  closeTree(source, location) {
    let active;
    const documentElement = this.dom.root;
    while ((active = this.dom.getActive()) && !active.isRootElement()) {
      if (active.meta?.implicitClosed) {
        active.closed = NodeClosed.ImplicitClosed;
        this.closeElement(source, documentElement, active, location);
      } else {
        this.closeElement(source, null, active, location);
      }
      this.dom.popActive();
    }
  }
};
var blockerCounter = 1;
function createBlocker() {
  const id = blockerCounter++;
  return id;
}
var Engine = class {
  report;
  config;
  ParserClass;
  availableRules;
  constructor(config2, ParserClass) {
    this.report = new Reporter();
    this.config = config2;
    this.ParserClass = ParserClass;
    const result = this.initPlugins(this.config);
    this.availableRules = {
      ...bundledRules,
      ...result.availableRules
    };
  }
  /**
   * Lint sources and return report
   *
   * @param sources - Sources to lint.
   * @returns Report output.
   */
  lint(sources) {
    for (const source of sources) {
      const parser = this.instantiateParser();
      const { rules } = this.setupPlugins(source, this.config, parser);
      const noUnusedDisable = rules["no-unused-disable"];
      const directiveContext = {
        rules,
        reportUnused(rules2, unused, options, location2) {
          if (!rules2.has(noUnusedDisable.name)) {
            noUnusedDisable.reportUnused(unused, options, location2);
          }
        }
      };
      const location = {
        filename: source.filename,
        line: 1,
        column: 1,
        offset: 0,
        size: 1
      };
      const configEvent = {
        location,
        config: this.config,
        rules
      };
      parser.trigger("config:ready", configEvent);
      const { hooks: _, ...sourceData } = source;
      const sourceEvent = {
        location,
        source: sourceData
      };
      parser.trigger("source:ready", sourceEvent);
      parser.on("directive", (_2, event) => {
        this.processDirective(event, parser, directiveContext);
      });
      try {
        parser.parseHtml(source);
      } catch (e) {
        if (e instanceof InvalidTokenError || e instanceof ParserError) {
          this.reportError("parser-error", e.message, e.location);
        } else {
          throw e;
        }
      }
    }
    return this.report.save(sources);
  }
  /**
   * Returns a list of all events generated while parsing the source.
   *
   * For verbosity, token events are ignored (use [[dumpTokens]] to inspect
   * token stream).
   */
  dumpEvents(source) {
    const parser = this.instantiateParser();
    const lines = [];
    parser.on("*", (event, data) => {
      if (event === "token") {
        return;
      }
      lines.push({ event, data });
    });
    source.forEach((src) => parser.parseHtml(src));
    return lines;
  }
  dumpTokens(source) {
    const lexer = new Lexer();
    const lines = [];
    for (const src of source) {
      for (const token of lexer.tokenize(src)) {
        const data = token.data[0] ?? "";
        const filename = token.location.filename;
        const line = String(token.location.line);
        const column = String(token.location.column);
        lines.push({
          token: TokenType[token.type],
          data,
          location: `${filename}:${line}:${column}`
        });
      }
    }
    return lines;
  }
  dumpTree(source) {
    const parser = this.instantiateParser();
    const root = parser.parseHtml(source[0]);
    return dumpTree(root);
  }
  /**
   * Get rule documentation.
   */
  getRuleDocumentation({
    ruleId,
    context
  }) {
    const rules = this.config.getRules();
    const ruleData = rules.get(ruleId);
    if (ruleData) {
      const [, options] = ruleData;
      const rule = this.instantiateRule(ruleId, options);
      return rule.documentation(context);
    } else {
      return null;
    }
  }
  /**
   * Create a new parser instance with the current configuration.
   *
   * @internal
   */
  instantiateParser() {
    return new this.ParserClass(this.config);
  }
  processDirective(event, parser, context) {
    const rules = event.data.split(",").map((name) => name.trim()).map((name) => context.rules[name]).filter((rule) => {
      return Boolean(rule);
    });
    const location = event.optionsLocation ?? event.location;
    switch (event.action) {
      case "enable":
        this.processEnableDirective(rules, parser);
        break;
      case "disable":
        this.processDisableDirective(rules, parser);
        break;
      case "disable-block":
        this.processDisableBlockDirective(context, rules, parser, event.data, location);
        break;
      case "disable-next":
        this.processDisableNextDirective(context, rules, parser, event.data, location);
        break;
    }
  }
  processEnableDirective(rules, parser) {
    for (const rule of rules) {
      rule.setEnabled(true);
      if (rule.getSeverity() === Severity.DISABLED) {
        rule.setServerity(Severity.ERROR);
      }
    }
    parser.on("tag:start", (_event, data) => {
      data.target.enableRules(rules.map((rule) => rule.name));
    });
  }
  processDisableDirective(rules, parser) {
    for (const rule of rules) {
      rule.setEnabled(false);
    }
    parser.on("tag:start", (_event, data) => {
      data.target.disableRules(rules.map((rule) => rule.name));
    });
  }
  processDisableBlockDirective(context, rules, parser, options, location) {
    const ruleIds2 = new Set(rules.map((it) => it.name));
    const unused = new Set(ruleIds2);
    const blocker = createBlocker();
    let directiveBlock = null;
    for (const rule of rules) {
      rule.block(blocker);
    }
    const unregisterOpen = parser.on("tag:start", (_event, data) => {
      directiveBlock ??= data.target.parent?.unique ?? null;
      data.target.blockRules(ruleIds2, blocker);
    });
    const unregisterClose = parser.on("tag:end", (_event, data) => {
      const lastNode = directiveBlock === null;
      const parentClosed = directiveBlock === data.previous.unique;
      if (lastNode || parentClosed) {
        unregisterClose();
        unregisterOpen();
        for (const rule of rules) {
          rule.unblock(blocker);
        }
      }
    });
    parser.on("rule:error", (_event, data) => {
      if (data.blockers.includes(blocker)) {
        unused.delete(data.ruleId);
      }
    });
    parser.on("parse:end", () => {
      context.reportUnused(ruleIds2, unused, options, location);
    });
  }
  processDisableNextDirective(context, rules, parser, options, location) {
    const ruleIds2 = new Set(rules.map((it) => it.name));
    const unused = new Set(ruleIds2);
    const blocker = createBlocker();
    for (const rule of rules) {
      rule.block(blocker);
    }
    const unregister = parser.on("tag:start", (_event, data) => {
      data.target.blockRules(ruleIds2, blocker);
    });
    parser.on("rule:error", (_event, data) => {
      if (data.blockers.includes(blocker)) {
        unused.delete(data.ruleId);
      }
    });
    parser.on("parse:end", () => {
      context.reportUnused(ruleIds2, unused, options, location);
    });
    parser.once("tag:ready, tag:end, attr", () => {
      unregister();
      parser.defer(() => {
        for (const rule of rules) {
          rule.unblock(blocker);
        }
      });
    });
  }
  /*
   * Initialize all plugins. This should only be done once for all sessions.
   */
  initPlugins(config2) {
    for (const plugin of config2.getPlugins()) {
      if (plugin.init) {
        plugin.init();
      }
    }
    return {
      availableRules: this.initRules(config2)
    };
  }
  /**
   * Initializes all rules from plugins and returns an object with a mapping
   * between rule name and its constructor.
   */
  initRules(config2) {
    const availableRules = {};
    for (const plugin of config2.getPlugins()) {
      for (const [name, rule] of Object.entries(plugin.rules ?? {})) {
        if (!rule) continue;
        availableRules[name] = rule;
      }
    }
    return availableRules;
  }
  /**
   * Setup all plugins for this session.
   */
  setupPlugins(source, config2, parser) {
    const eventHandler = parser.getEventHandler();
    for (const plugin of config2.getPlugins()) {
      if (plugin.setup) {
        plugin.setup(source, eventHandler);
      }
    }
    return {
      rules: this.setupRules(config2, parser)
    };
  }
  /**
   * Load and setup all rules for current configuration.
   */
  setupRules(config2, parser) {
    const rules = {};
    for (const [ruleId, [severity, options]] of config2.getRules().entries()) {
      rules[ruleId] = this.loadRule(ruleId, config2, severity, options, parser, this.report);
    }
    return rules;
  }
  /**
   * Load and setup a rule using current config.
   */
  loadRule(ruleId, config2, severity, options, parser, report) {
    const meta = config2.getMetaTable();
    const rule = this.instantiateRule(ruleId, options);
    rule.name = ruleId;
    rule.init(parser, report, severity, meta);
    if (rule.setup) {
      rule.setup();
    }
    return rule;
  }
  instantiateRule(name, options) {
    if (this.availableRules[name]) {
      const RuleConstructor = this.availableRules[name];
      return new RuleConstructor(options);
    } else {
      return this.missingRule(name);
    }
  }
  missingRule(name) {
    return new class MissingRule extends Rule {
      setup() {
        this.on("dom:load", () => {
          this.report(null, `Definition for rule '${name}' was not found`);
        });
      }
    }();
  }
  reportError(ruleId, message, location) {
    this.report.addManual(location.filename, {
      ruleId,
      severity: Severity.ERROR,
      message,
      offset: location.offset,
      line: location.line,
      column: location.column,
      size: location.size,
      selector: () => null
    });
  }
};
function getNamedTransformerFromPlugin(name, plugins, pluginName, key) {
  const plugin = plugins.find((cur) => cur.name === pluginName);
  if (!plugin) {
    throw new ConfigError(`No plugin named "${pluginName}" has been loaded`);
  }
  if (!plugin.transformer) {
    throw new ConfigError(`Plugin does not expose any transformers`);
  }
  if (typeof plugin.transformer === "function") {
    throw new ConfigError(
      `Transformer "${name}" refers to named transformer but plugin exposes only unnamed, use "${pluginName}" instead.`
    );
  }
  const transformer = plugin.transformer[key];
  if (!transformer) {
    throw new ConfigError(`Plugin "${pluginName}" does not expose a transformer named "${key}".`);
  }
  return transformer;
}
function getTransformerFromModule(resolvers, name) {
  return resolveTransformer(resolvers, name, { cache: true });
}
function getUnnamedTransformerFromPlugin(name, plugin) {
  if (!plugin.transformer) {
    throw new ConfigError(`Plugin does not expose any transformers`);
  }
  if (typeof plugin.transformer !== "function") {
    if (plugin.transformer.default) {
      return plugin.transformer.default;
    }
    throw new ConfigError(
      `Transformer "${name}" refers to unnamed transformer but plugin exposes only named.`
    );
  }
  return plugin.transformer;
}
var TRANSFORMER_API = {
  VERSION: 1
};
function validateTransformer(transformer) {
  const version2 = transformer.api ?? 0;
  if (version2 !== TRANSFORMER_API.VERSION) {
    throw new ConfigError(
      `Transformer uses API version ${String(version2)} but only version ${String(TRANSFORMER_API.VERSION)} is supported`
    );
  }
}
function loadTransformerFunction(resolvers, name, plugins) {
  const match2 = /(.*):(.*)/.exec(name);
  if (match2) {
    const [, pluginName, key] = match2;
    return getNamedTransformerFromPlugin(name, plugins, pluginName, key);
  }
  const plugin = plugins.find((cur) => cur.name === name);
  if (plugin) {
    return getUnnamedTransformerFromPlugin(name, plugin);
  }
  return getTransformerFromModule(resolvers, name);
}
function getTransformerFunction(resolvers, name, plugins) {
  try {
    const transformer = loadTransformerFunction(resolvers, name, plugins);
    if (isThenable(transformer)) {
      return transformer.then((transformer2) => {
        validateTransformer(transformer2);
        return transformer2;
      });
    } else {
      validateTransformer(transformer);
      return transformer;
    }
  } catch (err) {
    if (err instanceof ConfigError) {
      throw new ConfigError(`Failed to load transformer "${name}": ${err.message}`, err);
    } else {
      throw new ConfigError(`Failed to load transformer "${name}"`, ensureError(err));
    }
  }
}
function getCachedTransformerFunction(cache2, resolvers, name, plugins) {
  const cached = cache2.get(name);
  if (cached) {
    return cached;
  } else {
    const transformer = getTransformerFunction(resolvers, name, plugins);
    if (isThenable(transformer)) {
      return transformer.then((transformer2) => {
        cache2.set(name, transformer2);
        return transformer2;
      });
    } else {
      cache2.set(name, transformer);
      return transformer;
    }
  }
}
function isIterable(value) {
  return Boolean(value && typeof value === "object" && Symbol.iterator in value);
}
function toArray(value) {
  return isIterable(value) ? Array.from(value) : [value];
}
function isNonThenableArray(value) {
  return !value.some(isThenable);
}
var asyncInSyncTransformError = "Cannot use async transformer from sync function";
async function transformSource(resolvers, config2, source, filename) {
  const { cache: cache2 } = config2;
  const transformer = config2.findTransformer(filename ?? source.filename);
  const context = {
    hasChain(filename2) {
      return config2.canTransform(filename2);
    },
    chain(source2, filename2) {
      return transformSource(resolvers, config2, source2, filename2);
    }
  };
  if (!transformer) {
    return Promise.resolve([source]);
  }
  const fn = transformer.kind === "import" ? await getCachedTransformerFunction(cache2, resolvers, transformer.name, config2.getPlugins()) : transformer.function;
  const name = transformer.kind === "import" ? transformer.name : transformer.function.name;
  try {
    const result = await fn.call(context, source);
    const transformedSources = await Promise.all(toArray(result));
    for (const source2 of transformedSources) {
      source2.transformedBy ??= [];
      source2.transformedBy.push(name);
    }
    return transformedSources;
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    throw new NestedError(`When transforming "${source.filename}": ${message}`, ensureError(err));
  }
}
function transformSourceSync(resolvers, config2, source, filename) {
  const { cache: cache2 } = config2;
  const transformer = config2.findTransformer(filename ?? source.filename);
  const context = {
    hasChain(filename2) {
      return config2.canTransform(filename2);
    },
    chain(source2, filename2) {
      return transformSourceSync(resolvers, config2, source2, filename2);
    }
  };
  if (!transformer) {
    return [source];
  }
  const fn = transformer.kind === "import" ? getCachedTransformerFunction(cache2, resolvers, transformer.name, config2.getPlugins()) : transformer.function;
  const name = transformer.kind === "import" ? transformer.name : transformer.function.name;
  if (isThenable(fn)) {
    throw new UserError(asyncInSyncTransformError);
  }
  try {
    const result = fn.call(context, source);
    if (isThenable(result)) {
      throw new UserError(asyncInSyncTransformError);
    }
    const transformedSources = toArray(result);
    if (!isNonThenableArray(transformedSources)) {
      throw new UserError(asyncInSyncTransformError);
    }
    for (const source2 of transformedSources) {
      source2.transformedBy ??= [];
      source2.transformedBy.push(name);
    }
    return transformedSources;
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    throw new NestedError(`When transforming "${source.filename}": ${message}`, ensureError(err));
  }
}
function transformFilename(resolvers, config2, filename, fs4) {
  const stdin = 0;
  const src = filename !== "/dev/stdin" ? filename : stdin;
  const output = fs4.readFileSync(src, { encoding: "utf8" });
  const data = typeof output === "string" ? output : output.toString("utf8");
  const source = {
    data,
    filename,
    line: 1,
    column: 1,
    offset: 0,
    originalData: data
  };
  return transformSource(resolvers, config2, source, filename);
}
function transformFilenameSync(resolvers, config2, filename, fs4) {
  const stdin = 0;
  const src = filename !== "/dev/stdin" ? filename : stdin;
  const output = fs4.readFileSync(src, { encoding: "utf8" });
  const data = typeof output === "string" ? output : output.toString("utf8");
  const source = {
    data,
    filename,
    line: 1,
    column: 1,
    offset: 0,
    originalData: data
  };
  return transformSourceSync(resolvers, config2, source, filename);
}
var entities2 = {
  ">": "&gt;",
  "<": "&lt;",
  "'": "&apos;",
  '"': "&quot;",
  "&": "&amp;"
};
function xmlescape(src) {
  return src.toString().replace(/[><'"&]/g, (match2) => {
    return entities2[match2];
  });
}
function getMessageType(message) {
  switch (message.severity) {
    case 2:
      return "error";
    case 1:
      return "warning";
    default:
      return "error";
  }
}
function checkstyleFormatter(results) {
  let output = "";
  output += `<?xml version="1.0" encoding="utf-8"?>
`;
  output += `<checkstyle version="4.3">
`;
  results.forEach((result) => {
    const messages = result.messages;
    output += `  <file name="${xmlescape(result.filePath)}">
`;
    messages.forEach((message) => {
      const ruleId = xmlescape(`htmlvalidate.rules.${message.ruleId}`);
      output += "    ";
      output += [
        `<error line="${xmlescape(message.line)}"`,
        `column="${xmlescape(message.column)}"`,
        `severity="${xmlescape(getMessageType(message))}"`,
        `message="${xmlescape(message.message)} (${message.ruleId})"`,
        `source="${ruleId}" />`
      ].join(" ");
      output += "\n";
    });
    output += "  </file>\n";
  });
  output += "</checkstyle>\n";
  return output;
}
var formatter$3 = checkstyleFormatter;
var defaults = {
  showLink: true,
  showSummary: true,
  showSelector: false
};
var NEWLINE2 = /\r\n|[\n\r\u2028\u2029]/;
function getMarkerLines2(loc, source) {
  const startLoc = {
    ...loc.start
  };
  const endLoc = {
    ...startLoc,
    ...loc.end
  };
  const linesAbove = 2;
  const linesBelow = 3;
  const startLine = startLoc.line;
  const startColumn = startLoc.column;
  const endLine = endLoc.line;
  const endColumn = endLoc.column;
  const start = Math.max(startLine - (linesAbove + 1), 0);
  const end = Math.min(source.length, endLine + linesBelow);
  const lineDiff = endLine - startLine;
  const markerLines = {};
  if (lineDiff) {
    for (let i = 0; i <= lineDiff; i++) {
      const lineNumber = i + startLine;
      if (!startColumn) {
        markerLines[lineNumber] = true;
      } else if (i === 0) {
        const sourceLength = source[lineNumber - 1].length;
        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
      } else if (i === lineDiff) {
        markerLines[lineNumber] = [0, endColumn];
      } else {
        const sourceLength = source[lineNumber - i].length;
        markerLines[lineNumber] = [0, sourceLength];
      }
    }
  } else {
    if (startColumn === endColumn) {
      if (startColumn) {
        markerLines[startLine] = [startColumn, 0];
      } else {
        markerLines[startLine] = true;
      }
    } else {
      markerLines[startLine] = [startColumn, endColumn - startColumn];
    }
  }
  return { start, end, markerLines };
}
function codeFrameColumns2(rawLines, loc) {
  const lines = rawLines.split(NEWLINE2);
  const { start, end, markerLines } = getMarkerLines2(loc, lines);
  const numberMaxWidth = String(end).length;
  return rawLines.split(NEWLINE2, end).slice(start, end).map((line, index) => {
    const number = start + 1 + index;
    const paddedNumber = ` ${String(number)}`.slice(-numberMaxWidth);
    const gutter = ` ${paddedNumber} |`;
    const hasMarker = markerLines[number];
    if (hasMarker) {
      let markerLine = "";
      if (Array.isArray(hasMarker)) {
        const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
        const numberOfMarkers = hasMarker[1] || 1;
        markerLine = [
          "\n ",
          gutter.replace(/\d/g, " "),
          " ",
          markerSpacing,
          "^".repeat(numberOfMarkers)
        ].join("");
      }
      return [">", gutter, line.length > 0 ? ` ${line}` : "", markerLine].join("");
    } else {
      return [" ", gutter, line.length > 0 ? ` ${line}` : ""].join("");
    }
  }).join("\n");
}
function pluralize2(word, count) {
  return count === 1 ? word : `${word}s`;
}
function formatFilePath(filePath, line, column) {
  if (line && column) {
    filePath += `:${String(line)}:${String(column)}`;
  }
  return kleur_default.green(filePath);
}
function getStartLocation(message) {
  return {
    line: message.line,
    column: message.column
  };
}
function getEndLocation(message, source) {
  let line = message.line;
  let column = message.column;
  for (let i = 0; i < message.size; i++) {
    if (source.charAt(message.offset + i) === "\n") {
      line++;
      column = 0;
    } else {
      column++;
    }
  }
  return { line, column };
}
function formatMessage(message, parentResult, options) {
  const type2 = message.severity === 2 ? kleur_default.red("error") : kleur_default.yellow("warning");
  const msg = kleur_default.bold(message.message.replace(/([^ ])\.$/, "$1"));
  const ruleId = kleur_default.dim(`(${message.ruleId})`);
  const filePath = formatFilePath(parentResult.filePath, message.line, message.column);
  const sourceCode = parentResult.source;
  const firstLine = [
    `${type2}:`,
    msg,
    ruleId ? ruleId : "",
    sourceCode ? `at ${filePath}:` : `at ${filePath}`
  ].filter(String).join(" ");
  const result = [firstLine];
  if (sourceCode) {
    const output = codeFrameColumns2(sourceCode, {
      start: getStartLocation(message),
      end: getEndLocation(message, sourceCode)
    });
    result.push(output);
  }
  if (options.showSelector) {
    result.push(`${kleur_default.bold("Selector:")} ${message.selector ?? "-"}`);
  }
  if (options.showLink && message.ruleUrl) {
    result.push(`${kleur_default.bold("Details:")} ${message.ruleUrl}`);
  }
  return result.join("\n");
}
function formatSummary(errors, warnings) {
  const summaryColor = errors > 0 ? "red" : "yellow";
  const summary = [];
  if (errors > 0) {
    summary.push(`${String(errors)} ${pluralize2("error", errors)}`);
  }
  if (warnings > 0) {
    summary.push(`${String(warnings)} ${pluralize2("warning", warnings)}`);
  }
  return kleur_default[summaryColor]().bold(`${summary.join(" and ")} found.`);
}
function codeframe(results, options) {
  const merged = { ...defaults, ...options };
  let errors = 0;
  let warnings = 0;
  const resultsWithMessages = results.filter((result) => result.messages.length > 0);
  let output = resultsWithMessages.reduce((resultsOutput, result) => {
    const messages = result.messages.map((message) => {
      return `${formatMessage(message, result, merged)}

`;
    });
    errors += result.errorCount;
    warnings += result.warningCount;
    return resultsOutput.concat(messages);
  }, []).join("\n");
  if (merged.showSummary) {
    output += "\n";
    output += formatSummary(errors, warnings);
    output += "\n";
  }
  return errors + warnings > 0 ? output : "";
}
function jsonFormatter(results) {
  return JSON.stringify(results);
}
var formatter$2 = jsonFormatter;
function linkSummary(results) {
  const urls = results.reduce((result, it) => {
    const urls2 = it.messages.map((error) => error.ruleUrl).filter((error) => Boolean(error));
    return [...result, ...urls2];
  }, []);
  const unique = Array.from(new Set(urls));
  if (unique.length === 0) {
    return "";
  }
  const lines = unique.map((url) => `  ${url}
`);
  return `
${kleur_default.bold("More information")}:
${lines.join("")}
`;
}
function stylish2(results) {
  const errors = stylish(
    results.map((it) => ({
      ...it,
      fixableErrorCount: 0,
      fixableWarningCount: 0
    }))
  );
  const links = linkSummary(results);
  return `${errors}${links}`;
}
var formatter$1 = stylish2;
function textFormatter(results) {
  let output = "";
  let total = 0;
  results.forEach((result) => {
    const messages = result.messages;
    if (messages.length === 0) {
      return;
    }
    total += messages.length;
    output += messages.map((message) => {
      let messageType;
      if (message.severity === 2) {
        messageType = "error";
      } else {
        messageType = "warning";
      }
      const line = String(message.line);
      const column = String(message.column);
      const location = `${result.filePath}:${line}:${column}`;
      return `${location}: ${messageType} [${message.ruleId}] ${message.message}
`;
    }).join("");
  });
  return total > 0 ? output : "";
}
var formatter = textFormatter;
var availableFormatters = {
  checkstyle: formatter$3,
  codeframe,
  json: formatter$2,
  stylish: formatter$1,
  text: formatter
};
function getFormatter(name) {
  return availableFormatters[name] ?? null;
}
var ignore$1 = { exports: {} };
var hasRequiredIgnore;
function requireIgnore() {
  if (hasRequiredIgnore) return ignore$1.exports;
  hasRequiredIgnore = 1;
  (function(module2) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    const UNDEFINED = void 0;
    const EMPTY = "";
    const SPACE = " ";
    const ESCAPE = "\\";
    const REGEX_TEST_BLANK_LINE = /^\s+$/;
    const REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    const REGEX_SPLITALL_CRLF = /\r?\n/g;
    const REGEX_TEST_INVALID_PATH = /^\.{0,2}\/|^\.{1,2}$/;
    const REGEX_TEST_TRAILING_SLASH = /\/$/;
    const SLASH = "/";
    let TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    const KEY_IGNORE = TMP_KEY_IGNORE;
    const define2 = (object, key, value) => {
      Object.defineProperty(object, key, { value });
      return value;
    };
    const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    const RETURN_FALSE = () => false;
    const sanitizeRange = (range2) => range2.replace(
      REGEX_REGEXP_RANGE,
      (match2, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match2 : EMPTY
    );
    const cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    const REPLACERS = [
      [
        // Remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        () => EMPTY
      ],
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a ) -> (a)
        // (a \ ) -> (a  )
        /((?:\\\\)*?)(\\?\s+)$/,
        (_, m1, m2) => m1 + (m2.indexOf("\\") === 0 ? SPACE : EMPTY)
      ],
      // Replace (\ ) with ' '
      // (\ ) -> ' '
      // (\\ ) -> '\\ '
      // (\\\ ) -> '\\ '
      [
        /(\\+?)\s/g,
        (_, m1) => {
          const { length } = m1;
          return m1.slice(0, length - length % 2) + SPACE;
        }
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match2) => `\\${match2}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match2, leadEscape, range2, endEscape, close) => leadEscape === ESCAPE ? `\\[${range2}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range2)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match2) => /\/$/.test(match2) ? `${match2}$` : `${match2}(?=$|\\/$)`
      ]
    ];
    const REGEX_REPLACE_TRAILING_WILDCARD = /(^|\\\/)?\\\*$/;
    const MODE_IGNORE = "regex";
    const MODE_CHECK_IGNORE = "checkRegex";
    const UNDERSCORE = "_";
    const TRAILING_WILD_CARD_REPLACERS = {
      [MODE_IGNORE](_, p1) {
        const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      },
      [MODE_CHECK_IGNORE](_, p1) {
        const prefix = p1 ? `${p1}[^/]*` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      }
    };
    const makeRegexPrefix = (pattern) => REPLACERS.reduce(
      (prev, [matcher, replacer]) => prev.replace(matcher, replacer.bind(pattern)),
      pattern
    );
    const isString = (subject) => typeof subject === "string";
    const checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
    const splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF).filter(Boolean);
    class IgnoreRule {
      constructor(pattern, mark, body, ignoreCase, negative, prefix) {
        this.pattern = pattern;
        this.mark = mark;
        this.negative = negative;
        define2(this, "body", body);
        define2(this, "ignoreCase", ignoreCase);
        define2(this, "regexPrefix", prefix);
      }
      get regex() {
        const key = UNDERSCORE + MODE_IGNORE;
        if (this[key]) {
          return this[key];
        }
        return this._make(MODE_IGNORE, key);
      }
      get checkRegex() {
        const key = UNDERSCORE + MODE_CHECK_IGNORE;
        if (this[key]) {
          return this[key];
        }
        return this._make(MODE_CHECK_IGNORE, key);
      }
      _make(mode, key) {
        const str = this.regexPrefix.replace(
          REGEX_REPLACE_TRAILING_WILDCARD,
          // It does not need to bind pattern
          TRAILING_WILD_CARD_REPLACERS[mode]
        );
        const regex = this.ignoreCase ? new RegExp(str, "i") : new RegExp(str);
        return define2(this, key, regex);
      }
    }
    const createRule = ({
      pattern,
      mark
    }, ignoreCase) => {
      let negative = false;
      let body = pattern;
      if (body.indexOf("!") === 0) {
        negative = true;
        body = body.substr(1);
      }
      body = body.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regexPrefix = makeRegexPrefix(body);
      return new IgnoreRule(
        pattern,
        mark,
        body,
        ignoreCase,
        negative,
        regexPrefix
      );
    };
    class RuleManager {
      constructor(ignoreCase) {
        this._ignoreCase = ignoreCase;
        this._rules = [];
      }
      _add(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules._rules);
          this._added = true;
          return;
        }
        if (isString(pattern)) {
          pattern = {
            pattern
          };
        }
        if (checkPattern(pattern.pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._add, this);
        return this._added;
      }
      // Test one single path without recursively checking parent directories
      //
      // - checkUnignored `boolean` whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // - check `string` either `MODE_IGNORE` or `MODE_CHECK_IGNORE`
      // @returns {TestResult} true if a file is ignored
      test(path5, checkUnignored, mode) {
        let ignored = false;
        let unignored = false;
        let matchedRule;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule[mode].test(path5);
          if (!matched) {
            return;
          }
          ignored = !negative;
          unignored = negative;
          matchedRule = negative ? UNDEFINED : rule;
        });
        const ret = {
          ignored,
          unignored
        };
        if (matchedRule) {
          ret.rule = matchedRule;
        }
        return ret;
      }
    }
    const throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    const checkPath = (path5, originalPath, doThrow) => {
      if (!isString(path5)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path5) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path5)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    const isNotRelative = (path5) => REGEX_TEST_INVALID_PATH.test(path5);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    class Ignore2 {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = new RuleManager(ignoreCase);
        this._strictPathCheck = !allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      add(pattern) {
        if (this._rules.add(pattern)) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      // @returns {TestResult}
      _test(originalPath, cache2, checkUnignored, slices) {
        const path5 = originalPath && checkPath.convert(originalPath);
        checkPath(
          path5,
          originalPath,
          this._strictPathCheck ? throwError : RETURN_FALSE
        );
        return this._t(path5, cache2, checkUnignored, slices);
      }
      checkIgnore(path5) {
        if (!REGEX_TEST_TRAILING_SLASH.test(path5)) {
          return this.test(path5);
        }
        const slices = path5.split(SLASH).filter(Boolean);
        slices.pop();
        if (slices.length) {
          const parent2 = this._t(
            slices.join(SLASH) + SLASH,
            this._testCache,
            true,
            slices
          );
          if (parent2.ignored) {
            return parent2;
          }
        }
        return this._rules.test(path5, false, MODE_CHECK_IGNORE);
      }
      _t(path5, cache2, checkUnignored, slices) {
        if (path5 in cache2) {
          return cache2[path5];
        }
        if (!slices) {
          slices = path5.split(SLASH).filter(Boolean);
        }
        slices.pop();
        if (!slices.length) {
          return cache2[path5] = this._rules.test(path5, checkUnignored, MODE_IGNORE);
        }
        const parent2 = this._t(
          slices.join(SLASH) + SLASH,
          cache2,
          checkUnignored,
          slices
        );
        return cache2[path5] = parent2.ignored ? parent2 : this._rules.test(path5, checkUnignored, MODE_IGNORE);
      }
      ignores(path5) {
        return this._test(path5, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path5) => !this.ignores(path5);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path5) {
        return this._test(path5, this._testCache, true);
      }
    }
    const factory2 = (options) => new Ignore2(options);
    const isPathValid = (path5) => checkPath(path5 && checkPath.convert(path5), path5, RETURN_FALSE);
    const setupWindows = () => {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGEX_TEST_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path5) => REGEX_TEST_WINDOWS_PATH_ABSOLUTE.test(path5) || isNotRelative(path5);
    };
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && process.platform === "win32"
    ) {
      setupWindows();
    }
    module2.exports = factory2;
    factory2.default = factory2;
    module2.exports.isPathValid = isPathValid;
    define2(module2.exports, Symbol.for("setupWindows"), setupWindows);
  })(ignore$1);
  return ignore$1.exports;
}
var ignoreExports = /* @__PURE__ */ requireIgnore();
var ignore = /* @__PURE__ */ getDefaultExportFromCjs(ignoreExports);

// node_modules/html-validate/dist/esm/core-nodejs.js
var import_node_path = __toESM(require("node:path"), 1);
var import_promises = __toESM(require("node:fs/promises"), 1);
var import_node_url = require("node:url");
var import_node_module = require("node:module");
var import_meta = {};
var defaultFS = {
  readFileSync: import_node_fs.default.readFileSync
};
function isSourceHooks(value) {
  if (!value || typeof value === "string") {
    return false;
  }
  return Boolean(value.processAttribute ?? value.processElement);
}
function isConfigData(value) {
  if (!value || typeof value === "string") {
    return false;
  }
  return !(value.processAttribute ?? value.processElement);
}
var HtmlValidate = class {
  configLoader;
  constructor(arg) {
    const [loader, config2] = arg instanceof ConfigLoader ? [arg, void 0] : [void 0, arg];
    this.configLoader = loader ?? new StaticConfigLoader(config2);
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  validateString(str, arg1, arg2, arg3) {
    const filename = typeof arg1 === "string" ? arg1 : "inline";
    const options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : void 0;
    const hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3;
    const source = {
      data: str,
      filename,
      line: 1,
      column: 1,
      offset: 0,
      hooks
    };
    return this.validateSource(source, options);
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  validateStringSync(str, arg1, arg2, arg3) {
    const filename = typeof arg1 === "string" ? arg1 : "inline";
    const options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : void 0;
    const hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3;
    const source = {
      data: str,
      filename,
      line: 1,
      column: 1,
      offset: 0,
      hooks
    };
    return this.validateSourceSync(source, options);
  }
  /**
   * Parse and validate HTML from [[Source]].
   *
   * @public
   * @param input - Source to parse.
   * @returns Report output.
   */
  async validateSource(input, configOverride) {
    const source = normalizeSource(input);
    const config2 = await this.getConfigFor(source.filename, configOverride);
    const resolvers = this.configLoader.getResolvers();
    const transformedSource = await transformSource(resolvers, config2, source);
    const engine = new Engine(config2, Parser);
    return engine.lint(transformedSource);
  }
  /**
   * Parse and validate HTML from [[Source]].
   *
   * @public
   * @param input - Source to parse.
   * @returns Report output.
   */
  validateSourceSync(input, configOverride) {
    const source = normalizeSource(input);
    const config2 = this.getConfigForSync(source.filename, configOverride);
    const resolvers = this.configLoader.getResolvers();
    const transformedSource = transformSourceSync(resolvers, config2, source);
    const engine = new Engine(config2, Parser);
    return engine.lint(transformedSource);
  }
  /**
   * Parse and validate HTML from file.
   *
   * @public
   * @param filename - Filename to read and parse.
   * @returns Report output.
   */
  async validateFile(filename, fs22 = defaultFS) {
    const config2 = await this.getConfigFor(filename);
    const resolvers = this.configLoader.getResolvers();
    const source = await transformFilename(resolvers, config2, filename, fs22);
    const engine = new Engine(config2, Parser);
    return Promise.resolve(engine.lint(source));
  }
  /**
   * Parse and validate HTML from file.
   *
   * @public
   * @param filename - Filename to read and parse.
   * @returns Report output.
   */
  validateFileSync(filename, fs22 = defaultFS) {
    const config2 = this.getConfigForSync(filename);
    const resolvers = this.configLoader.getResolvers();
    const source = transformFilenameSync(resolvers, config2, filename, fs22);
    const engine = new Engine(config2, Parser);
    return engine.lint(source);
  }
  /**
   * Parse and validate HTML from multiple files. Result is merged together to a
   * single report.
   *
   * @param filenames - Filenames to read and parse.
   * @returns Report output.
   */
  async validateMultipleFiles(filenames, fs22 = defaultFS) {
    return Reporter.merge(filenames.map((filename) => this.validateFile(filename, fs22)));
  }
  /**
   * Parse and validate HTML from multiple files. Result is merged together to a
   * single report.
   *
   * @param filenames - Filenames to read and parse.
   * @returns Report output.
   */
  validateMultipleFilesSync(filenames, fs22 = defaultFS) {
    return Reporter.merge(filenames.map((filename) => this.validateFileSync(filename, fs22)));
  }
  /**
   * Returns true if the given filename can be validated.
   *
   * A file is considered to be validatable if the extension is `.html` or if a
   * transformer matches the filename.
   *
   * This is mostly useful for tooling to determine whenever to validate the
   * file or not. CLI tools will run on all the given files anyway.
   */
  async canValidate(filename) {
    if (filename.toLowerCase().endsWith(".html")) {
      return true;
    }
    const config2 = await this.getConfigFor(filename);
    return config2.canTransform(filename);
  }
  /**
   * Returns true if the given filename can be validated.
   *
   * A file is considered to be validatable if the extension is `.html` or if a
   * transformer matches the filename.
   *
   * This is mostly useful for tooling to determine whenever to validate the
   * file or not. CLI tools will run on all the given files anyway.
   */
  canValidateSync(filename) {
    if (filename.toLowerCase().endsWith(".html")) {
      return true;
    }
    const config2 = this.getConfigForSync(filename);
    return config2.canTransform(filename);
  }
  /**
   * Tokenize filename and output all tokens.
   *
   * Using CLI this is enabled with `--dump-tokens`. Mostly useful for
   * debugging.
   *
   * @internal
   * @param filename - Filename to tokenize.
   */
  async dumpTokens(filename, fs22 = defaultFS) {
    const config2 = await this.getConfigFor(filename);
    const resolvers = this.configLoader.getResolvers();
    const source = await transformFilename(resolvers, config2, filename, fs22);
    const engine = new Engine(config2, Parser);
    return engine.dumpTokens(source);
  }
  /**
   * Parse filename and output all events.
   *
   * Using CLI this is enabled with `--dump-events`. Mostly useful for
   * debugging.
   *
   * @internal
   * @param filename - Filename to dump events from.
   */
  async dumpEvents(filename, fs22 = defaultFS) {
    const config2 = await this.getConfigFor(filename);
    const resolvers = this.configLoader.getResolvers();
    const source = await transformFilename(resolvers, config2, filename, fs22);
    const engine = new Engine(config2, Parser);
    return engine.dumpEvents(source);
  }
  /**
   * Parse filename and output DOM tree.
   *
   * Using CLI this is enabled with `--dump-tree`. Mostly useful for
   * debugging.
   *
   * @internal
   * @param filename - Filename to dump DOM tree from.
   */
  async dumpTree(filename, fs22 = defaultFS) {
    const config2 = await this.getConfigFor(filename);
    const resolvers = this.configLoader.getResolvers();
    const source = await transformFilename(resolvers, config2, filename, fs22);
    const engine = new Engine(config2, Parser);
    return engine.dumpTree(source);
  }
  /**
   * Transform filename and output source data.
   *
   * Using CLI this is enabled with `--dump-source`. Mostly useful for
   * debugging.
   *
   * @internal
   * @param filename - Filename to dump source from.
   */
  async dumpSource(filename, fs22 = defaultFS) {
    const config2 = await this.getConfigFor(filename);
    const resolvers = this.configLoader.getResolvers();
    const sources = await transformFilename(resolvers, config2, filename, fs22);
    return sources.reduce((result, source) => {
      const line = String(source.line);
      const column = String(source.column);
      const offset = String(source.offset);
      result.push(`Source ${source.filename}@${line}:${column} (offset: ${offset})`);
      if (source.transformedBy) {
        result.push("Transformed by:");
        result = result.concat(source.transformedBy.reverse().map((name) => ` - ${name}`));
      }
      if (source.hooks && Object.keys(source.hooks).length > 0) {
        result.push("Hooks");
        for (const [key, present] of Object.entries(source.hooks)) {
          if (present) {
            result.push(` - ${key}`);
          }
        }
      }
      result.push("---");
      result = result.concat(source.data.split("\n"));
      result.push("---");
      return result;
    }, []);
  }
  /**
   * Get effective configuration schema.
   */
  getConfigurationSchema() {
    return Promise.resolve(configurationSchema);
  }
  /**
   * Get effective metadata element schema.
   *
   * If a filename is given the configured plugins can extend the
   * schema. Filename must not be an existing file or a filetype normally
   * handled by html-validate but the path will be used when resolving
   * configuration. As a rule-of-thumb, set it to the elements json file.
   */
  async getElementsSchema(filename) {
    const config2 = await this.getConfigFor(filename ?? "inline");
    const metaTable = config2.getMetaTable();
    return metaTable.getJSONSchema();
  }
  /**
   * Get effective metadata element schema.
   *
   * If a filename is given the configured plugins can extend the
   * schema. Filename must not be an existing file or a filetype normally
   * handled by html-validate but the path will be used when resolving
   * configuration. As a rule-of-thumb, set it to the elements json file.
   */
  getElementsSchemaSync(filename) {
    const config2 = this.getConfigForSync(filename ?? "inline");
    const metaTable = config2.getMetaTable();
    return metaTable.getJSONSchema();
  }
  async getContextualDocumentation(message, filenameOrConfig = "inline") {
    const config2 = typeof filenameOrConfig === "string" ? await this.getConfigFor(filenameOrConfig) : await filenameOrConfig;
    const engine = new Engine(config2, Parser);
    return engine.getRuleDocumentation(message);
  }
  getContextualDocumentationSync(message, filenameOrConfig = "inline") {
    const config2 = typeof filenameOrConfig === "string" ? this.getConfigForSync(filenameOrConfig) : filenameOrConfig;
    const engine = new Engine(config2, Parser);
    return engine.getRuleDocumentation(message);
  }
  /**
   * Get contextual documentation for the given rule.
   *
   * Typical usage:
   *
   * ```js
   * const report = await htmlvalidate.validateFile("my-file.html");
   * for (const result of report.results){
   *   const config = await htmlvalidate.getConfigFor(result.filePath);
   *   for (const message of result.messages){
   *     const documentation = await htmlvalidate.getRuleDocumentation(message.ruleId, config, message.context);
   *     // do something with documentation
   *   }
   * }
   * ```
   *
   * @public
   * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentation]] instead.
   * @param ruleId - Rule to get documentation for.
   * @param config - If set it provides more accurate description by using the
   * correct configuration for the file.
   * @param context - If set to `Message.context` some rules can provide
   * contextual details and suggestions.
   */
  async getRuleDocumentation(ruleId, config2 = null, context = null) {
    const c = config2 ?? this.getConfigFor("inline");
    const engine = new Engine(await c, Parser);
    return engine.getRuleDocumentation({ ruleId, context });
  }
  /**
   * Get contextual documentation for the given rule.
   *
   * Typical usage:
   *
   * ```js
   * const report = htmlvalidate.validateFileSync("my-file.html");
   * for (const result of report.results){
   *   const config = htmlvalidate.getConfigForSync(result.filePath);
   *   for (const message of result.messages){
   *     const documentation = htmlvalidate.getRuleDocumentationSync(message.ruleId, config, message.context);
   *     // do something with documentation
   *   }
   * }
   * ```
   *
   * @public
   * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentationSync]] instead.
   * @param ruleId - Rule to get documentation for.
   * @param config - If set it provides more accurate description by using the
   * correct configuration for the file.
   * @param context - If set to `Message.context` some rules can provide
   * contextual details and suggestions.
   */
  getRuleDocumentationSync(ruleId, config2 = null, context = null) {
    const c = config2 ?? this.getConfigForSync("inline");
    const engine = new Engine(c, Parser);
    return engine.getRuleDocumentation({ ruleId, context });
  }
  /**
   * Create a parser configured for given filename.
   *
   * @internal
   * @param source - Source to use.
   */
  async getParserFor(source) {
    const config2 = await this.getConfigFor(source.filename);
    return new Parser(config2);
  }
  /**
   * Get configuration for given filename.
   *
   * See [[FileSystemConfigLoader]] for details.
   *
   * @public
   * @param filename - Filename to get configuration for.
   * @param configOverride - Configuration to apply last.
   */
  getConfigFor(filename, configOverride) {
    const config2 = this.configLoader.getConfigFor(filename, configOverride);
    return Promise.resolve(config2);
  }
  /**
   * Get configuration for given filename.
   *
   * See [[FileSystemConfigLoader]] for details.
   *
   * @public
   * @param filename - Filename to get configuration for.
   * @param configOverride - Configuration to apply last.
   */
  getConfigForSync(filename, configOverride) {
    const config2 = this.configLoader.getConfigFor(filename, configOverride);
    if (isThenable(config2)) {
      throw new UserError("Cannot use asynchronous config loader with synchronous api");
    }
    return config2;
  }
  /**
   * Get current configuration loader.
   *
   * @public
   * @since %version%
   * @returns Current configuration loader.
   */
  /* istanbul ignore next -- not testing setters/getters */
  getConfigLoader() {
    return this.configLoader;
  }
  /**
   * Set configuration loader.
   *
   * @public
   * @since %version%
   * @param loader - New configuration loader to use.
   */
  /* istanbul ignore next -- not testing setters/getters */
  setConfigLoader(loader) {
    this.configLoader = loader;
  }
  /**
   * Flush configuration cache. Clears full cache unless a filename is given.
   *
   * See [[FileSystemConfigLoader]] for details.
   *
   * @public
   * @param filename - If set, only flush cache for given filename.
   */
  flushConfigCache(filename) {
    this.configLoader.flushCache(filename);
  }
};
var legacyRequire = (0, import_node_module.createRequire)(import_meta.url);
var importResolve = (specifier) => {
  return new URL(import_meta.resolve(specifier));
};
var cachedRootDir = null;
function determineRootDirImpl(intial, fs22) {
  let current = intial;
  while (true) {
    const search = import_node_path.default.join(current, "package.json");
    if (fs22.existsSync(search)) {
      return current;
    }
    const child = current;
    current = import_node_path.default.dirname(current);
    if (current === child) {
      break;
    }
  }
  return intial;
}
function determineRootDir() {
  cachedRootDir ??= determineRootDirImpl(process.cwd(), import_node_fs.default);
  return cachedRootDir;
}
function expandRelativePath(value, { cwd }) {
  if (typeof value === "string" && value.startsWith(".")) {
    return import_node_path.default.normalize(import_node_path.default.join(cwd, value));
  } else {
    return value;
  }
}
function importFunction(id) {
  return import(id);
}
async function getModuleName(id, { cache: cache2, rootDir }) {
  const moduleName = id.replace("<rootDir>", rootDir);
  const url = (0, import_node_fs.existsSync)(id) ? (0, import_node_url.pathToFileURL)(id) : importResolve(moduleName);
  if (url.protocol !== "file:") {
    return url;
  }
  if (cache2) {
    return url;
  } else {
    const stat = await import_promises.default.stat(url);
    url.searchParams.append("mtime", String(stat.mtime.getTime()));
    return url;
  }
}
function isImportError(error) {
  return Boolean(error && typeof error === "object" && "code" in error);
}
async function internalImport(id, rootDir, { cache: cache2 }) {
  if (id.endsWith(".json")) {
    const content = await import_promises.default.readFile(id, "utf-8");
    return JSON.parse(content);
  }
  try {
    const url = await getModuleName(id, { cache: cache2, rootDir });
    if (url.protocol !== "file:") {
      return null;
    }
    const moduleName = url.toString();
    const { default: defaultImport } = await importFunction(moduleName);
    if (!defaultImport) {
      throw new UserError(`"${id}" does not have a default export`);
    }
    return defaultImport;
  } catch (err) {
    if (isImportError(err) && err.code === "MODULE_NOT_FOUND" && !err.requireStack) {
      return null;
    }
    throw err;
  }
}
function isTransformer(value) {
  return typeof value === "function";
}
function esmResolver(options = {}) {
  const rootDir = options.rootDir ?? determineRootDir();
  return {
    name: "esm-resolver",
    resolveElements(id, options2) {
      return internalImport(id, rootDir, options2);
    },
    async resolveConfig(id, options2) {
      const configData = await internalImport(id, rootDir, options2);
      if (!configData) {
        return null;
      }
      const cwd = import_node_path.default.dirname(id);
      const expand2 = (value) => expandRelativePath(value, { cwd });
      if (Array.isArray(configData.elements)) {
        configData.elements = configData.elements.map(expand2);
      }
      if (Array.isArray(configData.extends)) {
        configData.extends = configData.extends.map(expand2);
      }
      if (Array.isArray(configData.plugins)) {
        configData.plugins = configData.plugins.map(expand2);
      }
      return configData;
    },
    resolvePlugin(id, options2) {
      return internalImport(id, rootDir, options2);
    },
    async resolveTransformer(id, options2) {
      const mod = await internalImport(id, rootDir, options2);
      if (!mod) {
        return null;
      }
      if (isTransformer(mod)) {
        return mod;
      }
      if (mod.transformer) {
        throw new ConfigError(
          `Module "${id}" is not a valid transformer. This looks like a plugin, did you forget to load the plugin first?`
        );
      }
      throw new ConfigError(`Module "${id}" is not a valid transformer.`);
    }
  };
}
function findConfigurationFiles(fs22, directory) {
  return ["json", "mjs", "cjs", "js"].map((extension) => import_node_path.default.join(directory, `.htmlvalidate.${extension}`)).filter((filePath) => fs22.existsSync(filePath));
}
var defaultResolvers2 = [esmResolver()];
function hasResolver2(value) {
  return Array.isArray(value[0]);
}
var FileSystemConfigLoader = class extends ConfigLoader {
  cache;
  fs;
  constructor(...args) {
    if (hasResolver2(args)) {
      const [resolvers, config2, options = {}] = args;
      super(resolvers, config2);
      this.fs = /* istanbul ignore next */
      options.fs ?? import_node_fs.default;
    } else {
      const [config2, options = {}] = args;
      super(defaultResolvers2, config2);
      this.fs = /* istanbul ignore next */
      options.fs ?? import_node_fs.default;
    }
    this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * Get configuration for given filename.
   *
   * @param filename - Filename to get configuration for.
   * @param configOverride - Configuration to merge final result with.
   */
  getConfigFor(filename, configOverride) {
    const override = this.loadFromObject(configOverride ?? {});
    if (isThenable(override)) {
      return override.then((override2) => {
        return this._resolveAsync(filename, override2);
      });
    } else {
      return this._resolveSync1(filename, override);
    }
  }
  /**
   * Flush configuration cache.
   *
   * @param filename - If given only the cache for that file is flushed.
   */
  flushCache(filename) {
    if (filename) {
      this.cache.delete(filename);
    } else {
      this.cache.clear();
    }
  }
  /**
   * Load raw configuration from directory traversal.
   *
   * This configuration is not merged with global configuration and may return
   * `null` if no configuration files are found.
   */
  fromFilename(filename) {
    if (filename === "inline") {
      return null;
    }
    const cache2 = this.cache.get(filename);
    if (cache2) {
      return cache2;
    }
    let found = false;
    let current = import_node_path.default.resolve(import_node_path.default.dirname(filename));
    let config2 = this.empty();
    while (true) {
      for (const configFile of findConfigurationFiles(this.fs, current)) {
        const local = this.loadFromFile(configFile);
        if (isThenable(local)) {
          return this.fromFilenameAsync(filename);
        }
        found = true;
        const merged = local.merge(this.resolvers, config2);
        if (isThenable(merged)) {
          throw new Error("internal error: async result ended up in sync path");
        }
        config2 = merged;
      }
      if (config2.isRootFound()) {
        break;
      }
      const child = current;
      current = import_node_path.default.dirname(current);
      if (current === child) {
        break;
      }
    }
    if (!found) {
      this.cache.set(filename, null);
      return null;
    }
    this.cache.set(filename, config2);
    return config2;
  }
  /**
   * Async version of [[fromFilename]].
   *
   * @internal
   */
  async fromFilenameAsync(filename) {
    if (filename === "inline") {
      return null;
    }
    const cache2 = this.cache.get(filename);
    if (cache2) {
      return cache2;
    }
    let found = false;
    let current = import_node_path.default.resolve(import_node_path.default.dirname(filename));
    let config2 = this.empty();
    while (true) {
      for (const configFile of findConfigurationFiles(this.fs, current)) {
        const local = await this.loadFromFile(configFile);
        found = true;
        config2 = await local.merge(this.resolvers, config2);
      }
      if (config2.isRootFound()) {
        break;
      }
      const child = current;
      current = import_node_path.default.dirname(current);
      if (current === child) {
        break;
      }
    }
    if (!found) {
      this.cache.set(filename, null);
      return null;
    }
    this.cache.set(filename, config2);
    return config2;
  }
  _merge(globalConfig, override, config2) {
    const merged = config2 ? config2.merge(this.resolvers, override) : globalConfig.merge(this.resolvers, override);
    if (isThenable(merged)) {
      return merged.then((merged2) => {
        return merged2.resolve();
      });
    } else {
      return merged.resolve();
    }
  }
  _resolveSync1(filename, override) {
    if (override.isRootFound()) {
      return override.resolve();
    }
    const globalConfig = this.getGlobalConfig();
    if (isThenable(globalConfig)) {
      return globalConfig.then((globalConfig2) => {
        return this._resolveSync2(filename, override, globalConfig2);
      });
    } else {
      return this._resolveSync2(filename, override, globalConfig);
    }
  }
  _resolveSync2(filename, override, globalConfig) {
    if (globalConfig.isRootFound()) {
      const merged = globalConfig.merge(this.resolvers, override);
      if (isThenable(merged)) {
        return merged.then((merged2) => {
          return merged2.resolve();
        });
      } else {
        return merged.resolve();
      }
    }
    const config2 = this.fromFilename(filename);
    if (isThenable(config2)) {
      return config2.then((config22) => {
        return this._merge(globalConfig, override, config22);
      });
    } else {
      return this._merge(globalConfig, override, config2);
    }
  }
  async _resolveAsync(filename, override) {
    if (override.isRootFound()) {
      return override.resolve();
    }
    const globalConfig = await this.getGlobalConfig();
    if (globalConfig.isRootFound()) {
      const merged = await globalConfig.merge(this.resolvers, override);
      return merged.resolve();
    }
    const config2 = await this.fromFilenameAsync(filename);
    return this._merge(globalConfig, override, config2);
  }
  /**
   * @internal For testing only
   */
  _getInternalCache() {
    return this.cache;
  }
  defaultConfig() {
    return Config.defaultConfig();
  }
};

// node_modules/html-validate/dist/esm/cli.js
var import_posix = __toESM(require("node:path/posix"), 1);
var import_fs2 = __toESM(require("fs"), 1);
var import_node_path3 = __toESM(require("node:path"), 1);

// node_modules/@isaacs/balanced-match/dist/esm/index.js
var balanced = (a, b, str) => {
  const ma = a instanceof RegExp ? maybeMatch(a, str) : a;
  const mb = b instanceof RegExp ? maybeMatch(b, str) : b;
  const r = ma !== null && mb != null && range(ma, mb, str);
  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + ma.length, r[1]),
    post: str.slice(r[1] + mb.length)
  };
};
var maybeMatch = (reg, str) => {
  const m = str.match(reg);
  return m ? m[0] : null;
};
var range = (a, b, str) => {
  let begs, beg, left, right = void 0, result;
  let ai = str.indexOf(a);
  let bi = str.indexOf(b, ai + 1);
  let i = ai;
  if (ai >= 0 && bi > 0) {
    if (a === b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;
    while (i >= 0 && !result) {
      if (i === ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length === 1) {
        const r = begs.pop();
        if (r !== void 0)
          result = [r, bi];
      } else {
        beg = begs.pop();
        if (beg !== void 0 && beg < left) {
          left = beg;
          right = bi;
        }
        bi = str.indexOf(b, i + 1);
      }
      i = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length && right !== void 0) {
      result = [left, right];
    }
  }
  return result;
};

// node_modules/@isaacs/brace-expansion/dist/esm/index.js
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
var escSlashPattern = new RegExp(escSlash, "g");
var escOpenPattern = new RegExp(escOpen, "g");
var escClosePattern = new RegExp(escClose, "g");
var escCommaPattern = new RegExp(escComma, "g");
var escPeriodPattern = new RegExp(escPeriod, "g");
var slashPattern = /\\\\/g;
var openPattern = /\\{/g;
var closePattern = /\\}/g;
var commaPattern = /\\,/g;
var periodPattern = /\\./g;
function numeric(str) {
  return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
}
function unescapeBraces(str) {
  return str.replace(escSlashPattern, "\\").replace(escOpenPattern, "{").replace(escClosePattern, "}").replace(escCommaPattern, ",").replace(escPeriodPattern, ".");
}
function parseCommaParts(str) {
  if (!str) {
    return [""];
  }
  const parts = [];
  const m = balanced("{", "}", str);
  if (!m) {
    return str.split(",");
  }
  const { pre, body, post } = m;
  const p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  const postParts = parseCommaParts(post);
  if (post.length) {
    ;
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expand(str) {
  if (!str) {
    return [];
  }
  if (str.slice(0, 2) === "{}") {
    str = "\\{\\}" + str.slice(2);
  }
  return expand_(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
  return "{" + str + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}
function expand_(str, isTop) {
  const expansions = [];
  const m = balanced("{", "}", str);
  if (!m)
    return [str];
  const pre = m.pre;
  const post = m.post.length ? expand_(m.post, false) : [""];
  if (/\$$/.test(m.pre)) {
    for (let k = 0; k < post.length; k++) {
      const expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  } else {
    const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    const isSequence = isNumericSequence || isAlphaSequence;
    const isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,(?!,).*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand_(str);
      }
      return [str];
    }
    let n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1 && n[0] !== void 0) {
        n = expand_(n[0], false).map(embrace);
        if (n.length === 1) {
          return post.map((p) => m.pre + n[0] + p);
        }
      }
    }
    let N;
    if (isSequence && n[0] !== void 0 && n[1] !== void 0) {
      const x = numeric(n[0]);
      const y = numeric(n[1]);
      const width = Math.max(n[0].length, n[1].length);
      let incr = n.length === 3 && n[2] !== void 0 ? Math.abs(numeric(n[2])) : 1;
      let test = lte;
      const reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      const pad = n.some(isPadded);
      N = [];
      for (let i = x; test(i, y); i += incr) {
        let c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\") {
            c = "";
          }
        } else {
          c = String(i);
          if (pad) {
            const need = width - c.length;
            if (need > 0) {
              const z = new Array(need + 1).join("0");
              if (i < 0) {
                c = "-" + z + c.slice(1);
              } else {
                c = z + c;
              }
            }
          }
        }
        N.push(c);
      }
    } else {
      N = [];
      for (let j = 0; j < n.length; j++) {
        N.push.apply(N, expand_(n[j], false));
      }
    }
    for (let j = 0; j < N.length; j++) {
      for (let k = 0; k < post.length; k++) {
        const expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion) {
          expansions.push(expansion);
        }
      }
    }
  }
  return expansions;
}

// node_modules/glob/node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/glob/node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob2, position) => {
  const pos = position;
  if (glob2.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE: while (i < glob2.length) {
    const c = glob2.charAt(i);
    if ((c === "!" || c === "^") && i === pos + 1) {
      negate = true;
      i++;
      continue;
    }
    if (c === "]" && sawStart && !escaping) {
      endPos = i + 1;
      break;
    }
    sawStart = true;
    if (c === "\\") {
      if (!escaping) {
        escaping = true;
        i++;
        continue;
      }
    }
    if (c === "[" && !escaping) {
      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
        if (glob2.startsWith(cls, i)) {
          if (rangeStart) {
            return ["$.", false, glob2.length - pos, true];
          }
          i += cls.length;
          if (neg)
            negs.push(unip);
          else
            ranges.push(unip);
          uflag = uflag || u;
          continue WHILE;
        }
      }
    }
    escaping = false;
    if (rangeStart) {
      if (c > rangeStart) {
        ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
      } else if (c === rangeStart) {
        ranges.push(braceEscape(c));
      }
      rangeStart = "";
      i++;
      continue;
    }
    if (glob2.startsWith("-]", i + 1)) {
      ranges.push(braceEscape(c + "-"));
      i += 2;
      continue;
    }
    if (glob2.startsWith("-", i + 1)) {
      rangeStart = c;
      i += 2;
      continue;
    }
    ranges.push(braceEscape(c));
    i++;
  }
  if (endPos < i) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob2.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/glob/node_modules/minimatch/dist/esm/unescape.js
var unescape2 = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// node_modules/glob/node_modules/minimatch/dist/esm/ast.js
var types3 = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c) => types3.has(c);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = false;
  constructor(type2, parent2, options = {}) {
    this.type = type2;
    if (type2)
      this.#hasMagic = true;
    this.#parent = parent2;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type2 === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (const p of this.#parts) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    if (this.#toString !== void 0)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p) => String(p)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n;
    while (n = this.#negs.pop()) {
      if (n.type !== "!")
        continue;
      let p = n;
      let pp = p.#parent;
      while (pp) {
        for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
          for (const part of n.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i]);
          }
        }
        p = pp;
        pp = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
        throw new Error("invalid part: " + p);
      }
      this.#parts.push(p);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p = this.#parent;
    for (let i = 0; i < this.#parentIndex; i++) {
      const pp = p.#parts[i];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent2) {
    const c = new _AST(this.type, parent2);
    for (const p of this.#parts) {
      c.copyIn(p);
    }
    return c;
  }
  static #parseAST(str, ast, pos, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i2 = pos;
      let acc2 = "";
      while (i2 < str.length) {
        const c = str.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc2 += c;
          continue;
        }
        if (inBrace) {
          if (i2 === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i2;
          braceNeg = false;
          acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c, ast);
          i2 = _AST.#parseAST(str, ext2, i2, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c;
      }
      ast.push(acc2);
      return i2;
    }
    let i = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i < str.length) {
      const c = str.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc += c;
        continue;
      }
      if (inBrace) {
        if (i === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i;
        braceNeg = false;
        acc += c;
        continue;
      }
      if (isExtglobType(c) && str.charAt(i) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c, part);
        part.push(ext2);
        i = _AST.#parseAST(str, ext2, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i;
      }
      acc += c;
    }
    ast.type = null;
    ast.#hasMagic = void 0;
    ast.#parts = [str.substring(pos - 1)];
    return i;
  }
  static fromGlob(pattern, options = {}) {
    const ast = new _AST(null, void 0, options);
    _AST.#parseAST(pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob2 = this.toString();
    const [re, body, hasMagic2, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic2 || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob2
    });
  }
  get options() {
    return this.#options;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = this.#parts.map((p) => {
        const [re, _, hasMagic2, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic2;
        this.#uflag = this.#uflag || uflag;
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape2(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      this.#parts = [s];
      this.type = null;
      this.#hasMagic = void 0;
      return [s, unescape2(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape2(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob2, hasMagic2, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i = 0; i < glob2.length; i++) {
      const c = glob2.charAt(i);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        if (i === glob2.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob2, i);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i += consumed - 1;
          hasMagic2 = hasMagic2 || magic;
          continue;
        }
      }
      if (c === "*") {
        if (noEmpty && glob2 === "*")
          re += starNoEmpty;
        else
          re += star;
        hasMagic2 = true;
        continue;
      }
      if (c === "?") {
        re += qmark;
        hasMagic2 = true;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape2(glob2), !!hasMagic2, uflag];
  }
};

// node_modules/glob/node_modules/minimatch/dist/esm/escape.js
var escape3 = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/glob/node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path2 = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path2.win32.sep : path2.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
var ext = (a, b = {}) => Object.assign({}, a, b);
var defaults2 = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type2, parent2, options = {}) {
        super(type2, parent2, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults2;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f) => mm.match(f));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i = 0; i < this.set.length; i++) {
        const p = this.set[i];
        if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i = 0; i < globParts.length; i++) {
        for (let j = 0; j < globParts[i].length; j++) {
          if (globParts[i][j] === "**") {
            globParts[i][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i = gs;
        while (parts[i + 1] === "**") {
          i++;
        }
        if (i !== gs) {
          parts.splice(gs, i - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i = 1; i < parts.length - 1; i++) {
          const p = parts[i];
          if (i === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i, 1);
            i--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i = 0; i < globParts.length - 1; i++) {
      for (let j = i + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i] = [];
          globParts[j] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a.length && bi < b.length) {
      if (a[ai] === b[bi]) {
        result.push(which === "b" ? b[bi] : a[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
        result.push(a[ai]);
        ai++;
      } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
        result.push(b[bi]);
        bi++;
      } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a[ai]);
        ai++;
        bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i) => {
        const next = pp[i + 1];
        const prev = pp[i - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i] = twoStar;
          }
        } else if (next === void 0) {
          pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i = ff.length - 2; !filename && i >= 0; i--) {
        filename = ff[i];
      }
    }
    for (let i = 0; i < set.length; i++) {
      const pattern = set[i];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape3;
minimatch.unescape = unescape2;

// node_modules/glob/dist/esm/glob.js
var import_node_url3 = require("node:url");

// node_modules/path-scurry/node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type2, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type2, code, fn) : console.error(`[${code}] ${type2}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var Stack = class _Stack {
  heap;
  length;
  // private constructor
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    _Stack.#constructing = true;
    const s = new _Stack(max, HeapCls);
    _Stack.#constructing = false;
    return s;
  }
  constructor(max, HeapCls) {
    if (!_Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var LRUCache = class _LRUCache {
  // options that cannot be changed without disaster
  #max;
  #maxSize;
  #dispose;
  #onInsert;
  #disposeAfter;
  #fetchMethod;
  #memoMethod;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  #hasOnInsert;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      // methods
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get memoMethod() {
    return this.#memoMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.onInsert} (read-only)
   */
  get onInsert() {
    return this.#onInsert;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== void 0 && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    this.#memoMethod = memoMethod;
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = /* @__PURE__ */ new Map();
    this.#keyList = new Array(max).fill(void 0);
    this.#valList = new Array(max).fill(void 0);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof onInsert === "function") {
      this.#onInsert = onInsert;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = void 0;
      this.#disposed = void 0;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasOnInsert = !!this.#onInsert;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.#delete(this.#keyList[index], "expire");
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === void 0) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      const s = starts[index];
      const t = ttls[index];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string
   * description of an object. Called by the built-in method
   * `Object.prototype.toString`.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      if (fn(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.#delete(this.#keyList[i], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === void 0)
      return void 0;
    const v = this.#valList[i];
    const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === void 0)
      return void 0;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k, v, setOptions = {}) {
    if (v === void 0) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.#delete(k, "set");
      return this;
    }
    let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
    if (index === void 0) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
      if (this.#hasOnInsert) {
        this.#onInsert?.(v, k, "add");
      }
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
      if (this.#hasOnInsert) {
        this.onInsert?.(v, k, v === oldVal ? "update" : "replace");
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = void 0;
      this.#valList[head] = void 0;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index === void 0 || !allowStale && this.#isStale(index)) {
      return;
    }
    const v = this.#valList[index];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index, options, context) {
    const v = index === void 0 ? void 0 : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC();
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index] === p) {
        if (v2 === void 0) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.#delete(k, "fetch");
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          this.#delete(k, "fetch");
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(void 0);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: void 0
    });
    if (index === void 0) {
      this.set(k, bf, { ...fetchOpts.options, status: void 0 });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k, fetchOptions = {}) {
    const v = await this.fetch(k, fetchOptions);
    if (v === void 0)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k, memoOptions = {}) {
    const memoMethod = this.#memoMethod;
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v = this.get(k, options);
    if (!forceRefresh && v !== void 0)
      return v;
    const vv = memoMethod(k, v, {
      options,
      context
    });
    this.set(k, vv, options);
    return vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.#delete(k, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    return this.#delete(k, "delete");
  }
  #delete(k, reason) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        deleted = true;
        if (this.#size === 1) {
          this.#clear(reason);
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = void 0;
          this.#valList[index] = void 0;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return this.#clear("delete");
  }
  #clear(reason) {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, reason);
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, reason]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(void 0);
    this.#keyList.fill(void 0);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
};

// node_modules/path-scurry/dist/esm/index.js
var import_node_path2 = require("node:path");
var import_node_url2 = require("node:url");
var import_fs = require("fs");
var actualFS = __toESM(require("node:fs"), 1);
var import_promises2 = require("node:fs/promises");

// node_modules/minipass/dist/esm/index.js
var import_node_events = require("node:events");
var import_node_stream = __toESM(require("node:stream"), 1);
var import_node_string_decoder = require("node:string_decoder");
var proc = typeof process === "object" && process ? process : {
  stdout: null,
  stderr: null
};
var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof import_node_stream.default || isReadable(s) || isWritable(s));
var isReadable = (s) => !!s && typeof s === "object" && s instanceof import_node_events.EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
s.pipe !== import_node_stream.default.Writable.prototype.pipe;
var isWritable = (s) => !!s && typeof s === "object" && s instanceof import_node_events.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
var EOF = Symbol("EOF");
var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
var EMITTED_END = Symbol("emittedEnd");
var EMITTING_END = Symbol("emittingEnd");
var EMITTED_ERROR = Symbol("emittedError");
var CLOSED = Symbol("closed");
var READ = Symbol("read");
var FLUSH = Symbol("flush");
var FLUSHCHUNK = Symbol("flushChunk");
var ENCODING = Symbol("encoding");
var DECODER = Symbol("decoder");
var FLOWING = Symbol("flowing");
var PAUSED = Symbol("paused");
var RESUME = Symbol("resume");
var BUFFER = Symbol("buffer");
var PIPES = Symbol("pipes");
var BUFFERLENGTH = Symbol("bufferLength");
var BUFFERPUSH = Symbol("bufferPush");
var BUFFERSHIFT = Symbol("bufferShift");
var OBJECTMODE = Symbol("objectMode");
var DESTROYED = Symbol("destroyed");
var ERROR = Symbol("error");
var EMITDATA = Symbol("emitData");
var EMITEND = Symbol("emitEnd");
var EMITEND2 = Symbol("emitEnd2");
var ASYNC = Symbol("async");
var ABORT = Symbol("abort");
var ABORTED = Symbol("aborted");
var SIGNAL = Symbol("signal");
var DATALISTENERS = Symbol("dataListeners");
var DISCARDED = Symbol("discarded");
var defer = (fn) => Promise.resolve().then(fn);
var nodefer = (fn) => fn();
var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
var Pipe = class {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // only here for the prototype
  /* c8 ignore start */
  proxyErrors(_er) {
  }
  /* c8 ignore stop */
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
};
var PipeProxyErrors = class extends Pipe {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
};
var isObjectModeOptions = (o) => !!o.objectMode;
var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
var Minipass = class extends import_node_events.EventEmitter {
  [FLOWING] = false;
  [PAUSED] = false;
  [PIPES] = [];
  [BUFFER] = [];
  [OBJECTMODE];
  [ENCODING];
  [ASYNC];
  [DECODER];
  [EOF] = false;
  [EMITTED_END] = false;
  [EMITTING_END] = false;
  [CLOSED] = false;
  [EMITTED_ERROR] = null;
  [BUFFERLENGTH] = 0;
  [DESTROYED] = false;
  [SIGNAL];
  [ABORTED] = false;
  [DATALISTENERS] = 0;
  [DISCARDED] = false;
  /**
   * true if the stream can be written
   */
  writable = true;
  /**
   * true if the stream can be read
   */
  readable = true;
  /**
   * If `RType` is Buffer, then options do not need to be provided.
   * Otherwise, an options object must be provided to specify either
   * {@link Minipass.SharedOptions.objectMode} or
   * {@link Minipass.SharedOptions.encoding}, as appropriate.
   */
  constructor(...args) {
    const options = args[0] || {};
    super();
    if (options.objectMode && typeof options.encoding === "string") {
      throw new TypeError("Encoding and objectMode may not be used together");
    }
    if (isObjectModeOptions(options)) {
      this[OBJECTMODE] = true;
      this[ENCODING] = null;
    } else if (isEncodingOptions(options)) {
      this[ENCODING] = options.encoding;
      this[OBJECTMODE] = false;
    } else {
      this[OBJECTMODE] = false;
      this[ENCODING] = null;
    }
    this[ASYNC] = !!options.async;
    this[DECODER] = this[ENCODING] ? new import_node_string_decoder.StringDecoder(this[ENCODING]) : null;
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
    }
    const { signal } = options;
    if (signal) {
      this[SIGNAL] = signal;
      if (signal.aborted) {
        this[ABORT]();
      } else {
        signal.addEventListener("abort", () => this[ABORT]());
      }
    }
  }
  /**
   * The amount of data stored in the buffer waiting to be read.
   *
   * For Buffer strings, this will be the total byte length.
   * For string encoding streams, this will be the string character length,
   * according to JavaScript's `string.length` logic.
   * For objectMode streams, this is a count of the items waiting to be
   * emitted.
   */
  get bufferLength() {
    return this[BUFFERLENGTH];
  }
  /**
   * The `BufferEncoding` currently in use, or `null`
   */
  get encoding() {
    return this[ENCODING];
  }
  /**
   * @deprecated - This is a read only property
   */
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * @deprecated - Encoding may only be set at instantiation time
   */
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * True if this is an objectMode stream
   */
  get objectMode() {
    return this[OBJECTMODE];
  }
  /**
   * @deprecated - This is a read-only property
   */
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  /**
   * true if this is an async stream
   */
  get ["async"]() {
    return this[ASYNC];
  }
  /**
   * Set to true to make this stream async.
   *
   * Once set, it cannot be unset, as this would potentially cause incorrect
   * behavior.  Ie, a sync stream can be made async, but an async stream
   * cannot be safely made sync.
   */
  set ["async"](a) {
    this[ASYNC] = this[ASYNC] || !!a;
  }
  // drop everything and get out of the flow completely
  [ABORT]() {
    this[ABORTED] = true;
    this.emit("abort", this[SIGNAL]?.reason);
    this.destroy(this[SIGNAL]?.reason);
  }
  /**
   * True if the stream has been aborted.
   */
  get aborted() {
    return this[ABORTED];
  }
  /**
   * No-op setter. Stream aborted status is set via the AbortSignal provided
   * in the constructor options.
   */
  set aborted(_) {
  }
  write(chunk, encoding, cb) {
    if (this[ABORTED])
      return false;
    if (this[EOF])
      throw new Error("write after end");
    if (this[DESTROYED]) {
      this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
      return true;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (!encoding)
      encoding = "utf8";
    const fn = this[ASYNC] ? defer : nodefer;
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk)) {
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      } else if (isArrayBufferLike(chunk)) {
        chunk = Buffer.from(chunk);
      } else if (typeof chunk !== "string") {
        throw new Error("Non-contiguous data written to non-objectMode stream");
      }
    }
    if (this[OBJECTMODE]) {
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (typeof chunk === "string" && // unless it is a string already ready for us to use
    !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
      chunk = Buffer.from(chunk, encoding);
    }
    if (Buffer.isBuffer(chunk) && this[ENCODING]) {
      chunk = this[DECODER].write(chunk);
    }
    if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
      this[FLUSH](true);
    if (this[FLOWING])
      this.emit("data", chunk);
    else
      this[BUFFERPUSH](chunk);
    if (this[BUFFERLENGTH] !== 0)
      this.emit("readable");
    if (cb)
      fn(cb);
    return this[FLOWING];
  }
  /**
   * Low-level explicit read method.
   *
   * In objectMode, the argument is ignored, and one item is returned if
   * available.
   *
   * `n` is the number of bytes (or in the case of encoding streams,
   * characters) to consume. If `n` is not provided, then the entire buffer
   * is returned, or `null` is returned if no data is available.
   *
   * If `n` is greater that the amount of data in the internal buffer,
   * then `null` is returned.
   */
  read(n) {
    if (this[DESTROYED])
      return null;
    this[DISCARDED] = false;
    if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]();
      return null;
    }
    if (this[OBJECTMODE])
      n = null;
    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
      this[BUFFER] = [
        this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
      ];
    }
    const ret = this[READ](n || null, this[BUFFER][0]);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [READ](n, chunk) {
    if (this[OBJECTMODE])
      this[BUFFERSHIFT]();
    else {
      const c = chunk;
      if (n === c.length || n === null)
        this[BUFFERSHIFT]();
      else if (typeof c === "string") {
        this[BUFFER][0] = c.slice(n);
        chunk = c.slice(0, n);
        this[BUFFERLENGTH] -= n;
      } else {
        this[BUFFER][0] = c.subarray(n);
        chunk = c.subarray(0, n);
        this[BUFFERLENGTH] -= n;
      }
    }
    this.emit("data", chunk);
    if (!this[BUFFER].length && !this[EOF])
      this.emit("drain");
    return chunk;
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = void 0;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (chunk !== void 0)
      this.write(chunk, encoding);
    if (cb)
      this.once("end", cb);
    this[EOF] = true;
    this.writable = false;
    if (this[FLOWING] || !this[PAUSED])
      this[MAYBE_EMIT_END]();
    return this;
  }
  // don't let the internal resume be overwritten
  [RESUME]() {
    if (this[DESTROYED])
      return;
    if (!this[DATALISTENERS] && !this[PIPES].length) {
      this[DISCARDED] = true;
    }
    this[PAUSED] = false;
    this[FLOWING] = true;
    this.emit("resume");
    if (this[BUFFER].length)
      this[FLUSH]();
    else if (this[EOF])
      this[MAYBE_EMIT_END]();
    else
      this.emit("drain");
  }
  /**
   * Resume the stream if it is currently in a paused state
   *
   * If called when there are no pipe destinations or `data` event listeners,
   * this will place the stream in a "discarded" state, where all data will
   * be thrown away. The discarded state is removed if a pipe destination or
   * data handler is added, if pause() is called, or if any synchronous or
   * asynchronous iteration is started.
   */
  resume() {
    return this[RESUME]();
  }
  /**
   * Pause the stream
   */
  pause() {
    this[FLOWING] = false;
    this[PAUSED] = true;
    this[DISCARDED] = false;
  }
  /**
   * true if the stream has been forcibly destroyed
   */
  get destroyed() {
    return this[DESTROYED];
  }
  /**
   * true if the stream is currently in a flowing state, meaning that
   * any writes will be immediately emitted.
   */
  get flowing() {
    return this[FLOWING];
  }
  /**
   * true if the stream is currently in a paused state
   */
  get paused() {
    return this[PAUSED];
  }
  [BUFFERPUSH](chunk) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1;
    else
      this[BUFFERLENGTH] += chunk.length;
    this[BUFFER].push(chunk);
  }
  [BUFFERSHIFT]() {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] -= 1;
    else
      this[BUFFERLENGTH] -= this[BUFFER][0].length;
    return this[BUFFER].shift();
  }
  [FLUSH](noDrain = false) {
    do {
    } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
    if (!noDrain && !this[BUFFER].length && !this[EOF])
      this.emit("drain");
  }
  [FLUSHCHUNK](chunk) {
    this.emit("data", chunk);
    return this[FLOWING];
  }
  /**
   * Pipe all data emitted by this stream into the destination provided.
   *
   * Triggers the flow of data.
   */
  pipe(dest, opts) {
    if (this[DESTROYED])
      return dest;
    this[DISCARDED] = false;
    const ended = this[EMITTED_END];
    opts = opts || {};
    if (dest === proc.stdout || dest === proc.stderr)
      opts.end = false;
    else
      opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;
    if (ended) {
      if (opts.end)
        dest.end();
    } else {
      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
      if (this[ASYNC])
        defer(() => this[RESUME]());
      else
        this[RESUME]();
    }
    return dest;
  }
  /**
   * Fully unhook a piped destination stream.
   *
   * If the destination stream was the only consumer of this stream (ie,
   * there are no other piped destinations or `'data'` event listeners)
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  unpipe(dest) {
    const p = this[PIPES].find((p2) => p2.dest === dest);
    if (p) {
      if (this[PIPES].length === 1) {
        if (this[FLOWING] && this[DATALISTENERS] === 0) {
          this[FLOWING] = false;
        }
        this[PIPES] = [];
      } else
        this[PIPES].splice(this[PIPES].indexOf(p), 1);
      p.unpipe();
    }
  }
  /**
   * Alias for {@link Minipass#on}
   */
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.on`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * - Adding a 'data' event handler will trigger the flow of data
   *
   * - Adding a 'readable' event handler when there is data waiting to be read
   *   will cause 'readable' to be emitted immediately.
   *
   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
   *   already passed will cause the event to be emitted immediately and all
   *   handlers removed.
   *
   * - Adding an 'error' event handler after an error has been emitted will
   *   cause the event to be re-emitted immediately with the error previously
   *   raised.
   */
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data") {
      this[DISCARDED] = false;
      this[DATALISTENERS]++;
      if (!this[PIPES].length && !this[FLOWING]) {
        this[RESUME]();
      }
    } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
      super.emit("readable");
    } else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR]) {
      const h = handler;
      if (this[ASYNC])
        defer(() => h.call(this, this[EMITTED_ERROR]));
      else
        h.call(this, this[EMITTED_ERROR]);
    }
    return ret;
  }
  /**
   * Alias for {@link Minipass#off}
   */
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.off`
   *
   * If a 'data' event handler is removed, and it was the last consumer
   * (ie, there are no pipe destinations or other 'data' event listeners),
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  off(ev, handler) {
    const ret = super.off(ev, handler);
    if (ev === "data") {
      this[DATALISTENERS] = this.listeners("data").length;
      if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * Mostly identical to `EventEmitter.removeAllListeners`
   *
   * If all 'data' event handlers are removed, and they were the last consumer
   * (ie, there are no pipe destinations), then the flow of data will stop
   * until there is another consumer or {@link Minipass#resume} is explicitly
   * called.
   */
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    if (ev === "data" || ev === void 0) {
      this[DATALISTENERS] = 0;
      if (!this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * true if the 'end' event has been emitted
   */
  get emittedEnd() {
    return this[EMITTED_END];
  }
  [MAYBE_EMIT_END]() {
    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
      this[EMITTING_END] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED])
        this.emit("close");
      this[EMITTING_END] = false;
    }
  }
  /**
   * Mostly identical to `EventEmitter.emit`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * If the stream has been destroyed, and the event is something other
   * than 'close' or 'error', then `false` is returned and no handlers
   * are called.
   *
   * If the event is 'end', and has already been emitted, then the event
   * is ignored. If the stream is in a paused or non-flowing state, then
   * the event will be deferred until data flow resumes. If the stream is
   * async, then handlers will be called on the next tick rather than
   * immediately.
   *
   * If the event is 'close', and 'end' has not yet been emitted, then
   * the event will be deferred until after 'end' is emitted.
   *
   * If the event is 'error', and an AbortSignal was provided for the stream,
   * and there are no listeners, then the event is ignored, matching the
   * behavior of node core streams in the presense of an AbortSignal.
   *
   * If the event is 'finish' or 'prefinish', then all listeners will be
   * removed after emitting the event, to prevent double-firing.
   */
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
      return false;
    } else if (ev === "data") {
      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
    } else if (ev === "end") {
      return this[EMITEND]();
    } else if (ev === "close") {
      this[CLOSED] = true;
      if (!this[EMITTED_END] && !this[DESTROYED])
        return false;
      const ret2 = super.emit("close");
      this.removeAllListeners("close");
      return ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR] = data;
      super.emit(ERROR, data);
      const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      this.removeAllListeners(ev);
      return ret2;
    }
    const ret = super.emit(ev, ...args);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITDATA](data) {
    for (const p of this[PIPES]) {
      if (p.dest.write(data) === false)
        this.pause();
    }
    const ret = this[DISCARDED] ? false : super.emit("data", data);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITEND]() {
    if (this[EMITTED_END])
      return false;
    this[EMITTED_END] = true;
    this.readable = false;
    return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
  }
  [EMITEND2]() {
    if (this[DECODER]) {
      const data = this[DECODER].end();
      if (data) {
        for (const p of this[PIPES]) {
          p.dest.write(data);
        }
        if (!this[DISCARDED])
          super.emit("data", data);
      }
    }
    for (const p of this[PIPES]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }
  /**
   * Return a Promise that resolves to an array of all emitted data once
   * the stream ends.
   */
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    if (!this[OBJECTMODE])
      buf.dataLength = 0;
    const p = this.promise();
    this.on("data", (c) => {
      buf.push(c);
      if (!this[OBJECTMODE])
        buf.dataLength += c.length;
    });
    await p;
    return buf;
  }
  /**
   * Return a Promise that resolves to the concatenation of all emitted data
   * once the stream ends.
   *
   * Not allowed on objectMode streams.
   */
  async concat() {
    if (this[OBJECTMODE]) {
      throw new Error("cannot concat in objectMode");
    }
    const buf = await this.collect();
    return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  /**
   * Return a void Promise that resolves once the stream ends.
   */
  async promise() {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve());
    });
  }
  /**
   * Asynchronous `for await of` iteration.
   *
   * This will continue emitting all chunks until the stream terminates.
   */
  [Symbol.asyncIterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = async () => {
      this.pause();
      stopped = true;
      return { value: void 0, done: true };
    };
    const next = () => {
      if (stopped)
        return stop();
      const res = this.read();
      if (res !== null)
        return Promise.resolve({ done: false, value: res });
      if (this[EOF])
        return stop();
      let resolve;
      let reject;
      const onerr = (er) => {
        this.off("data", ondata);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        stop();
        reject(er);
      };
      const ondata = (value) => {
        this.off("error", onerr);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        this.pause();
        resolve({ value, done: !!this[EOF] });
      };
      const onend = () => {
        this.off("error", onerr);
        this.off("data", ondata);
        this.off(DESTROYED, ondestroy);
        stop();
        resolve({ done: true, value: void 0 });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res2, rej) => {
        reject = rej;
        resolve = res2;
        this.once(DESTROYED, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  /**
   * Synchronous `for of` iteration.
   *
   * The iteration will terminate when the internal buffer runs out, even
   * if the stream has not yet terminated.
   */
  [Symbol.iterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = () => {
      this.pause();
      this.off(ERROR, stop);
      this.off(DESTROYED, stop);
      this.off("end", stop);
      stopped = true;
      return { done: true, value: void 0 };
    };
    const next = () => {
      if (stopped)
        return stop();
      const value = this.read();
      return value === null ? stop() : { done: false, value };
    };
    this.once("end", stop);
    this.once(ERROR, stop);
    this.once(DESTROYED, stop);
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  /**
   * Destroy a stream, preventing it from being used for any further purpose.
   *
   * If the stream has a `close()` method, then it will be called on
   * destruction.
   *
   * After destruction, any attempt to write data, read data, or emit most
   * events will be ignored.
   *
   * If an error argument is provided, then it will be emitted in an
   * 'error' event.
   */
  destroy(er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    this[DESTROYED] = true;
    this[DISCARDED] = true;
    this[BUFFER].length = 0;
    this[BUFFERLENGTH] = 0;
    const wc = this;
    if (typeof wc.close === "function" && !this[CLOSED])
      wc.close();
    if (er)
      this.emit("error", er);
    else
      this.emit(DESTROYED);
    return this;
  }
  /**
   * Alias for {@link isStream}
   *
   * Former export location, maintained for backwards compatibility.
   *
   * @deprecated
   */
  static get isStream() {
    return isStream;
  }
};

// node_modules/path-scurry/dist/esm/index.js
var realpathSync = import_fs.realpathSync.native;
var defaultFS2 = {
  lstatSync: import_fs.lstatSync,
  readdir: import_fs.readdir,
  readdirSync: import_fs.readdirSync,
  readlinkSync: import_fs.readlinkSync,
  realpathSync,
  promises: {
    lstat: import_promises2.lstat,
    readdir: import_promises2.readdir,
    readlink: import_promises2.readlink,
    realpath: import_promises2.realpath
  }
};
var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS2 || fsOption === actualFS ? defaultFS2 : {
  ...defaultFS2,
  ...fsOption,
  promises: {
    ...defaultFS2.promises,
    ...fsOption.promises || {}
  }
};
var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
var eitherSep = /[\\\/]/;
var UNKNOWN = 0;
var IFIFO = 1;
var IFCHR = 2;
var IFDIR = 4;
var IFBLK = 6;
var IFREG = 8;
var IFLNK = 10;
var IFSOCK = 12;
var IFMT = 15;
var IFMT_UNKNOWN = ~IFMT;
var READDIR_CALLED = 16;
var LSTAT_CALLED = 32;
var ENOTDIR = 64;
var ENOENT = 128;
var ENOREADLINK = 256;
var ENOREALPATH = 512;
var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
var TYPEMASK = 1023;
var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
var normalizeCache = /* @__PURE__ */ new Map();
var normalize = (s) => {
  const c = normalizeCache.get(s);
  if (c)
    return c;
  const n = s.normalize("NFKD");
  normalizeCache.set(s, n);
  return n;
};
var normalizeNocaseCache = /* @__PURE__ */ new Map();
var normalizeNocase = (s) => {
  const c = normalizeNocaseCache.get(s);
  if (c)
    return c;
  const n = normalize(s.toLowerCase());
  normalizeNocaseCache.set(s, n);
  return n;
};
var ResolveCache = class extends LRUCache {
  constructor() {
    super({ max: 256 });
  }
};
var ChildrenCache = class extends LRUCache {
  constructor(maxSize = 16 * 1024) {
    super({
      maxSize,
      // parent + children
      sizeCalculation: (a) => a.length + 1
    });
  }
};
var setAsCwd = Symbol("PathScurry setAsCwd");
var PathBase = class {
  /**
   * the basename of this path
   *
   * **Important**: *always* test the path name against any test string
   * usingthe {@link isNamed} method, and not by directly comparing this
   * string. Otherwise, unicode path strings that the system sees as identical
   * will not be properly treated as the same path, leading to incorrect
   * behavior and possible security issues.
   */
  name;
  /**
   * the Path entry corresponding to the path root.
   *
   * @internal
   */
  root;
  /**
   * All roots found within the current PathScurry family
   *
   * @internal
   */
  roots;
  /**
   * a reference to the parent path, or undefined in the case of root entries
   *
   * @internal
   */
  parent;
  /**
   * boolean indicating whether paths are compared case-insensitively
   * @internal
   */
  nocase;
  /**
   * boolean indicating that this path is the current working directory
   * of the PathScurry collection that contains it.
   */
  isCWD = false;
  // potential default fs override
  #fs;
  // Stats fields
  #dev;
  get dev() {
    return this.#dev;
  }
  #mode;
  get mode() {
    return this.#mode;
  }
  #nlink;
  get nlink() {
    return this.#nlink;
  }
  #uid;
  get uid() {
    return this.#uid;
  }
  #gid;
  get gid() {
    return this.#gid;
  }
  #rdev;
  get rdev() {
    return this.#rdev;
  }
  #blksize;
  get blksize() {
    return this.#blksize;
  }
  #ino;
  get ino() {
    return this.#ino;
  }
  #size;
  get size() {
    return this.#size;
  }
  #blocks;
  get blocks() {
    return this.#blocks;
  }
  #atimeMs;
  get atimeMs() {
    return this.#atimeMs;
  }
  #mtimeMs;
  get mtimeMs() {
    return this.#mtimeMs;
  }
  #ctimeMs;
  get ctimeMs() {
    return this.#ctimeMs;
  }
  #birthtimeMs;
  get birthtimeMs() {
    return this.#birthtimeMs;
  }
  #atime;
  get atime() {
    return this.#atime;
  }
  #mtime;
  get mtime() {
    return this.#mtime;
  }
  #ctime;
  get ctime() {
    return this.#ctime;
  }
  #birthtime;
  get birthtime() {
    return this.#birthtime;
  }
  #matchName;
  #depth;
  #fullpath;
  #fullpathPosix;
  #relative;
  #relativePosix;
  #type;
  #children;
  #linkTarget;
  #realpath;
  /**
   * This property is for compatibility with the Dirent class as of
   * Node v20, where Dirent['parentPath'] refers to the path of the
   * directory that was passed to readdir. For root entries, it's the path
   * to the entry itself.
   */
  get parentPath() {
    return (this.parent || this).fullpath();
  }
  /**
   * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
   * this property refers to the *parent* path, not the path object itself.
   *
   * @deprecated
   */
  get path() {
    return this.parentPath;
  }
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type2 = UNKNOWN, root, roots, nocase, children, opts) {
    this.name = name;
    this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
    this.#type = type2 & TYPEMASK;
    this.nocase = nocase;
    this.roots = roots;
    this.root = root || this;
    this.#children = children;
    this.#fullpath = opts.fullpath;
    this.#relative = opts.relative;
    this.#relativePosix = opts.relativePosix;
    this.parent = opts.parent;
    if (this.parent) {
      this.#fs = this.parent.#fs;
    } else {
      this.#fs = fsFromOption(opts.fs);
    }
  }
  /**
   * Returns the depth of the Path object from its root.
   *
   * For example, a path at `/foo/bar` would have a depth of 2.
   */
  depth() {
    if (this.#depth !== void 0)
      return this.#depth;
    if (!this.parent)
      return this.#depth = 0;
    return this.#depth = this.parent.depth() + 1;
  }
  /**
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Get the Path object referenced by the string path, resolved from this Path
   */
  resolve(path5) {
    if (!path5) {
      return this;
    }
    const rootPath = this.getRootString(path5);
    const dir = path5.substring(rootPath.length);
    const dirParts = dir.split(this.splitSep);
    const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
    return result;
  }
  #resolveParts(dirParts) {
    let p = this;
    for (const part of dirParts) {
      p = p.child(part);
    }
    return p;
  }
  /**
   * Returns the cached children Path objects, if still available.  If they
   * have fallen out of the cache, then returns an empty array, and resets the
   * READDIR_CALLED bit, so that future calls to readdir() will require an fs
   * lookup.
   *
   * @internal
   */
  children() {
    const cached = this.#children.get(this);
    if (cached) {
      return cached;
    }
    const children = Object.assign([], { provisional: 0 });
    this.#children.set(this, children);
    this.#type &= ~READDIR_CALLED;
    return children;
  }
  /**
   * Resolves a path portion and returns or creates the child Path.
   *
   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
   * `'..'`.
   *
   * This should not be called directly.  If `pathPart` contains any path
   * separators, it will lead to unsafe undefined behavior.
   *
   * Use `Path.resolve()` instead.
   *
   * @internal
   */
  child(pathPart, opts) {
    if (pathPart === "" || pathPart === ".") {
      return this;
    }
    if (pathPart === "..") {
      return this.parent || this;
    }
    const children = this.children();
    const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
    for (const p of children) {
      if (p.#matchName === name) {
        return p;
      }
    }
    const s = this.parent ? this.sep : "";
    const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
    const pchild = this.newChild(pathPart, UNKNOWN, {
      ...opts,
      parent: this,
      fullpath
    });
    if (!this.canReaddir()) {
      pchild.#type |= ENOENT;
    }
    children.push(pchild);
    return pchild;
  }
  /**
   * The relative path from the cwd. If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpath()
   */
  relative() {
    if (this.isCWD)
      return "";
    if (this.#relative !== void 0) {
      return this.#relative;
    }
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relative = this.name;
    }
    const pv = p.relative();
    return pv + (!pv || !p.parent ? "" : this.sep) + name;
  }
  /**
   * The relative path from the cwd, using / as the path separator.
   * If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpathPosix()
   * On posix systems, this is identical to relative().
   */
  relativePosix() {
    if (this.sep === "/")
      return this.relative();
    if (this.isCWD)
      return "";
    if (this.#relativePosix !== void 0)
      return this.#relativePosix;
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relativePosix = this.fullpathPosix();
    }
    const pv = p.relativePosix();
    return pv + (!pv || !p.parent ? "" : "/") + name;
  }
  /**
   * The fully resolved path string for this Path entry
   */
  fullpath() {
    if (this.#fullpath !== void 0) {
      return this.#fullpath;
    }
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#fullpath = this.name;
    }
    const pv = p.fullpath();
    const fp = pv + (!p.parent ? "" : this.sep) + name;
    return this.#fullpath = fp;
  }
  /**
   * On platforms other than windows, this is identical to fullpath.
   *
   * On windows, this is overridden to return the forward-slash form of the
   * full UNC path.
   */
  fullpathPosix() {
    if (this.#fullpathPosix !== void 0)
      return this.#fullpathPosix;
    if (this.sep === "/")
      return this.#fullpathPosix = this.fullpath();
    if (!this.parent) {
      const p2 = this.fullpath().replace(/\\/g, "/");
      if (/^[a-z]:\//i.test(p2)) {
        return this.#fullpathPosix = `//?/${p2}`;
      } else {
        return this.#fullpathPosix = p2;
      }
    }
    const p = this.parent;
    const pfpp = p.fullpathPosix();
    const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
    return this.#fullpathPosix = fpp;
  }
  /**
   * Is the Path of an unknown type?
   *
   * Note that we might know *something* about it if there has been a previous
   * filesystem operation, for example that it does not exist, or is not a
   * link, or whether it has child entries.
   */
  isUnknown() {
    return (this.#type & IFMT) === UNKNOWN;
  }
  isType(type2) {
    return this[`is${type2}`]();
  }
  getType() {
    return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
      /* c8 ignore start */
      this.isSocket() ? "Socket" : "Unknown"
    );
  }
  /**
   * Is the Path a regular file?
   */
  isFile() {
    return (this.#type & IFMT) === IFREG;
  }
  /**
   * Is the Path a directory?
   */
  isDirectory() {
    return (this.#type & IFMT) === IFDIR;
  }
  /**
   * Is the path a character device?
   */
  isCharacterDevice() {
    return (this.#type & IFMT) === IFCHR;
  }
  /**
   * Is the path a block device?
   */
  isBlockDevice() {
    return (this.#type & IFMT) === IFBLK;
  }
  /**
   * Is the path a FIFO pipe?
   */
  isFIFO() {
    return (this.#type & IFMT) === IFIFO;
  }
  /**
   * Is the path a socket?
   */
  isSocket() {
    return (this.#type & IFMT) === IFSOCK;
  }
  /**
   * Is the path a symbolic link?
   */
  isSymbolicLink() {
    return (this.#type & IFLNK) === IFLNK;
  }
  /**
   * Return the entry if it has been subject of a successful lstat, or
   * undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* simply
   * mean that we haven't called lstat on it.
   */
  lstatCached() {
    return this.#type & LSTAT_CALLED ? this : void 0;
  }
  /**
   * Return the cached link target if the entry has been the subject of a
   * successful readlink, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readlink() has been called at some point.
   */
  readlinkCached() {
    return this.#linkTarget;
  }
  /**
   * Returns the cached realpath target if the entry has been the subject
   * of a successful realpath, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * realpath() has been called at some point.
   */
  realpathCached() {
    return this.#realpath;
  }
  /**
   * Returns the cached child Path entries array if the entry has been the
   * subject of a successful readdir(), or [] otherwise.
   *
   * Does not read the filesystem, so an empty array *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readdir() has been called recently enough to still be valid.
   */
  readdirCached() {
    const children = this.children();
    return children.slice(0, children.provisional);
  }
  /**
   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
   * any indication that readlink will definitely fail.
   *
   * Returns false if the path is known to not be a symlink, if a previous
   * readlink failed, or if the entry does not exist.
   */
  canReadlink() {
    if (this.#linkTarget)
      return true;
    if (!this.parent)
      return false;
    const ifmt = this.#type & IFMT;
    return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
  }
  /**
   * Return true if readdir has previously been successfully called on this
   * path, indicating that cachedReaddir() is likely valid.
   */
  calledReaddir() {
    return !!(this.#type & READDIR_CALLED);
  }
  /**
   * Returns true if the path is known to not exist. That is, a previous lstat
   * or readdir failed to verify its existence when that would have been
   * expected, or a parent entry was marked either enoent or enotdir.
   */
  isENOENT() {
    return !!(this.#type & ENOENT);
  }
  /**
   * Return true if the path is a match for the given path name.  This handles
   * case sensitivity and unicode normalization.
   *
   * Note: even on case-sensitive systems, it is **not** safe to test the
   * equality of the `.name` property to determine whether a given pathname
   * matches, due to unicode normalization mismatches.
   *
   * Always use this method instead of testing the `path.name` property
   * directly.
   */
  isNamed(n) {
    return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
  }
  /**
   * Return the Path object corresponding to the target of a symbolic link.
   *
   * If the Path is not a symbolic link, or if the readlink call fails for any
   * reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   */
  async readlink() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read = await this.#fs.promises.readlink(this.fullpath());
      const linkTarget = (await this.parent.realpath())?.resolve(read);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return void 0;
    }
  }
  /**
   * Synchronous {@link PathBase.readlink}
   */
  readlinkSync() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read = this.#fs.readlinkSync(this.fullpath());
      const linkTarget = this.parent.realpathSync()?.resolve(read);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return void 0;
    }
  }
  #readdirSuccess(children) {
    this.#type |= READDIR_CALLED;
    for (let p = children.provisional; p < children.length; p++) {
      const c = children[p];
      if (c)
        c.#markENOENT();
    }
  }
  #markENOENT() {
    if (this.#type & ENOENT)
      return;
    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
    this.#markChildrenENOENT();
  }
  #markChildrenENOENT() {
    const children = this.children();
    children.provisional = 0;
    for (const p of children) {
      p.#markENOENT();
    }
  }
  #markENOREALPATH() {
    this.#type |= ENOREALPATH;
    this.#markENOTDIR();
  }
  // save the information when we know the entry is not a dir
  #markENOTDIR() {
    if (this.#type & ENOTDIR)
      return;
    let t = this.#type;
    if ((t & IFMT) === IFDIR)
      t &= IFMT_UNKNOWN;
    this.#type = t | ENOTDIR;
    this.#markChildrenENOENT();
  }
  #readdirFail(code = "") {
    if (code === "ENOTDIR" || code === "EPERM") {
      this.#markENOTDIR();
    } else if (code === "ENOENT") {
      this.#markENOENT();
    } else {
      this.children().provisional = 0;
    }
  }
  #lstatFail(code = "") {
    if (code === "ENOTDIR") {
      const p = this.parent;
      p.#markENOTDIR();
    } else if (code === "ENOENT") {
      this.#markENOENT();
    }
  }
  #readlinkFail(code = "") {
    let ter = this.#type;
    ter |= ENOREADLINK;
    if (code === "ENOENT")
      ter |= ENOENT;
    if (code === "EINVAL" || code === "UNKNOWN") {
      ter &= IFMT_UNKNOWN;
    }
    this.#type = ter;
    if (code === "ENOTDIR" && this.parent) {
      this.parent.#markENOTDIR();
    }
  }
  #readdirAddChild(e, c) {
    return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
  }
  #readdirAddNewChild(e, c) {
    const type2 = entToType(e);
    const child = this.newChild(e.name, type2, { parent: this });
    const ifmt = child.#type & IFMT;
    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
      child.#type |= ENOTDIR;
    }
    c.unshift(child);
    c.provisional++;
    return child;
  }
  #readdirMaybePromoteChild(e, c) {
    for (let p = c.provisional; p < c.length; p++) {
      const pchild = c[p];
      const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
      if (name !== pchild.#matchName) {
        continue;
      }
      return this.#readdirPromoteChild(e, pchild, p, c);
    }
  }
  #readdirPromoteChild(e, p, index, c) {
    const v = p.name;
    p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
    if (v !== e.name)
      p.name = e.name;
    if (index !== c.provisional) {
      if (index === c.length - 1)
        c.pop();
      else
        c.splice(index, 1);
      c.unshift(p);
    }
    c.provisional++;
    return p;
  }
  /**
   * Call lstat() on this Path, and update all known information that can be
   * determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  /**
   * synchronous {@link PathBase.lstat}
   */
  lstatSync() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(this.#fs.lstatSync(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  #applyStat(st) {
    const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
    this.#atime = atime;
    this.#atimeMs = atimeMs;
    this.#birthtime = birthtime;
    this.#birthtimeMs = birthtimeMs;
    this.#blksize = blksize;
    this.#blocks = blocks;
    this.#ctime = ctime;
    this.#ctimeMs = ctimeMs;
    this.#dev = dev;
    this.#gid = gid;
    this.#ino = ino;
    this.#mode = mode;
    this.#mtime = mtime;
    this.#mtimeMs = mtimeMs;
    this.#nlink = nlink;
    this.#rdev = rdev;
    this.#size = size;
    this.#uid = uid;
    const ifmt = entToType(st);
    this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
      this.#type |= ENOTDIR;
    }
  }
  #onReaddirCB = [];
  #readdirCBInFlight = false;
  #callOnReaddirCB(children) {
    this.#readdirCBInFlight = false;
    const cbs = this.#onReaddirCB.slice();
    this.#onReaddirCB.length = 0;
    cbs.forEach((cb) => cb(null, children));
  }
  /**
   * Standard node-style callback interface to get list of directory entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   *
   * @param cb The callback called with (er, entries).  Note that the `er`
   * param is somewhat extraneous, as all readdir() errors are handled and
   * simply result in an empty set of entries being returned.
   * @param allowZalgo Boolean indicating that immediately known results should
   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
   * zalgo at your peril, the dark pony lord is devious and unforgiving.
   */
  readdirCB(cb, allowZalgo = false) {
    if (!this.canReaddir()) {
      if (allowZalgo)
        cb(null, []);
      else
        queueMicrotask(() => cb(null, []));
      return;
    }
    const children = this.children();
    if (this.calledReaddir()) {
      const c = children.slice(0, children.provisional);
      if (allowZalgo)
        cb(null, c);
      else
        queueMicrotask(() => cb(null, c));
      return;
    }
    this.#onReaddirCB.push(cb);
    if (this.#readdirCBInFlight) {
      return;
    }
    this.#readdirCBInFlight = true;
    const fullpath = this.fullpath();
    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
      if (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      } else {
        for (const e of entries) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      }
      this.#callOnReaddirCB(children.slice(0, children.provisional));
      return;
    });
  }
  #asyncReaddirInFlight;
  /**
   * Return an array of known child entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async readdir() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    if (this.#asyncReaddirInFlight) {
      await this.#asyncReaddirInFlight;
    } else {
      let resolve = () => {
      };
      this.#asyncReaddirInFlight = new Promise((res) => resolve = res);
      try {
        for (const e of await this.#fs.promises.readdir(fullpath, {
          withFileTypes: true
        })) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      }
      this.#asyncReaddirInFlight = void 0;
      resolve();
    }
    return children.slice(0, children.provisional);
  }
  /**
   * synchronous {@link PathBase.readdir}
   */
  readdirSync() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    try {
      for (const e of this.#fs.readdirSync(fullpath, {
        withFileTypes: true
      })) {
        this.#readdirAddChild(e, children);
      }
      this.#readdirSuccess(children);
    } catch (er) {
      this.#readdirFail(er.code);
      children.provisional = 0;
    }
    return children.slice(0, children.provisional);
  }
  canReaddir() {
    if (this.#type & ENOCHILD)
      return false;
    const ifmt = IFMT & this.#type;
    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
      return false;
    }
    return true;
  }
  shouldWalk(dirs, walkFilter) {
    return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
  }
  /**
   * Return the Path object corresponding to path as resolved
   * by realpath(3).
   *
   * If the realpath call fails for any reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   * On success, returns a Path object.
   */
  async realpath() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return void 0;
    try {
      const rp = await this.#fs.promises.realpath(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  /**
   * Synchronous {@link realpath}
   */
  realpathSync() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return void 0;
    try {
      const rp = this.#fs.realpathSync(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  /**
   * Internal method to mark this Path object as the scurry cwd,
   * called by {@link PathScurry#chdir}
   *
   * @internal
   */
  [setAsCwd](oldCwd) {
    if (oldCwd === this)
      return;
    oldCwd.isCWD = false;
    this.isCWD = true;
    const changed = /* @__PURE__ */ new Set([]);
    let rp = [];
    let p = this;
    while (p && p.parent) {
      changed.add(p);
      p.#relative = rp.join(this.sep);
      p.#relativePosix = rp.join("/");
      p = p.parent;
      rp.push("..");
    }
    p = oldCwd;
    while (p && p.parent && !changed.has(p)) {
      p.#relative = void 0;
      p.#relativePosix = void 0;
      p = p.parent;
    }
  }
};
var PathWin32 = class _PathWin32 extends PathBase {
  /**
   * Separator for generating path strings.
   */
  sep = "\\";
  /**
   * Separator for parsing path strings.
   */
  splitSep = eitherSep;
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type2 = UNKNOWN, root, roots, nocase, children, opts) {
    super(name, type2, root, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  newChild(name, type2 = UNKNOWN, opts = {}) {
    return new _PathWin32(name, type2, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
  /**
   * @internal
   */
  getRootString(path5) {
    return import_node_path2.win32.parse(path5).root;
  }
  /**
   * @internal
   */
  getRoot(rootPath) {
    rootPath = uncToDrive(rootPath.toUpperCase());
    if (rootPath === this.root.name) {
      return this.root;
    }
    for (const [compare, root] of Object.entries(this.roots)) {
      if (this.sameRoot(rootPath, compare)) {
        return this.roots[rootPath] = root;
      }
    }
    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
  }
  /**
   * @internal
   */
  sameRoot(rootPath, compare = this.root.name) {
    rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    return rootPath === compare;
  }
};
var PathPosix = class _PathPosix extends PathBase {
  /**
   * separator for parsing path strings
   */
  splitSep = "/";
  /**
   * separator for generating path strings
   */
  sep = "/";
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type2 = UNKNOWN, root, roots, nocase, children, opts) {
    super(name, type2, root, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  getRootString(path5) {
    return path5.startsWith("/") ? "/" : "";
  }
  /**
   * @internal
   */
  getRoot(_rootPath) {
    return this.root;
  }
  /**
   * @internal
   */
  newChild(name, type2 = UNKNOWN, opts = {}) {
    return new _PathPosix(name, type2, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
};
var PathScurryBase = class {
  /**
   * The root Path entry for the current working directory of this Scurry
   */
  root;
  /**
   * The string path for the root of this Scurry's current working directory
   */
  rootPath;
  /**
   * A collection of all roots encountered, referenced by rootPath
   */
  roots;
  /**
   * The Path entry corresponding to this PathScurry's current working directory.
   */
  cwd;
  #resolveCache;
  #resolvePosixCache;
  #children;
  /**
   * Perform path comparisons case-insensitively.
   *
   * Defaults true on Darwin and Windows systems, false elsewhere.
   */
  nocase;
  #fs;
  /**
   * This class should not be instantiated directly.
   *
   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
   *
   * @internal
   */
  constructor(cwd = process.cwd(), pathImpl, sep2, { nocase, childrenCacheSize = 16 * 1024, fs: fs4 = defaultFS2 } = {}) {
    this.#fs = fsFromOption(fs4);
    if (cwd instanceof URL || cwd.startsWith("file://")) {
      cwd = (0, import_node_url2.fileURLToPath)(cwd);
    }
    const cwdPath = pathImpl.resolve(cwd);
    this.roots = /* @__PURE__ */ Object.create(null);
    this.rootPath = this.parseRootPath(cwdPath);
    this.#resolveCache = new ResolveCache();
    this.#resolvePosixCache = new ResolveCache();
    this.#children = new ChildrenCache(childrenCacheSize);
    const split = cwdPath.substring(this.rootPath.length).split(sep2);
    if (split.length === 1 && !split[0]) {
      split.pop();
    }
    if (nocase === void 0) {
      throw new TypeError("must provide nocase setting to PathScurryBase ctor");
    }
    this.nocase = nocase;
    this.root = this.newRoot(this.#fs);
    this.roots[this.rootPath] = this.root;
    let prev = this.root;
    let len = split.length - 1;
    const joinSep = pathImpl.sep;
    let abs = this.rootPath;
    let sawFirst = false;
    for (const part of split) {
      const l = len--;
      prev = prev.child(part, {
        relative: new Array(l).fill("..").join(joinSep),
        relativePosix: new Array(l).fill("..").join("/"),
        fullpath: abs += (sawFirst ? "" : joinSep) + part
      });
      sawFirst = true;
    }
    this.cwd = prev;
  }
  /**
   * Get the depth of a provided path, string, or the cwd
   */
  depth(path5 = this.cwd) {
    if (typeof path5 === "string") {
      path5 = this.cwd.resolve(path5);
    }
    return path5.depth();
  }
  /**
   * Return the cache of child entries.  Exposed so subclasses can create
   * child Path objects in a platform-specific way.
   *
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Resolve one or more path strings to a resolved string
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolve(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      const p = paths[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = this.#resolveCache.get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result = this.cwd.resolve(r).fullpath();
    this.#resolveCache.set(r, result);
    return result;
  }
  /**
   * Resolve one or more path strings to a resolved string, returning
   * the posix path.  Identical to .resolve() on posix systems, but on
   * windows will return a forward-slash separated UNC path.
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolvePosix(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      const p = paths[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = this.#resolvePosixCache.get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result = this.cwd.resolve(r).fullpathPosix();
    this.#resolvePosixCache.set(r, result);
    return result;
  }
  /**
   * find the relative path from the cwd to the supplied path string or entry
   */
  relative(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relative();
  }
  /**
   * find the relative path from the cwd to the supplied path string or
   * entry, using / as the path delimiter, even on Windows.
   */
  relativePosix(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relativePosix();
  }
  /**
   * Return the basename for the provided string or Path object
   */
  basename(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.name;
  }
  /**
   * Return the dirname for the provided string or Path object
   */
  dirname(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return (entry.parent || entry).fullpath();
  }
  async readdir(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else {
      const p = await entry.readdir();
      return withFileTypes ? p : p.map((e) => e.name);
    }
  }
  readdirSync(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else if (withFileTypes) {
      return entry.readdirSync();
    } else {
      return entry.readdirSync().map((e) => e.name);
    }
  }
  /**
   * Call lstat() on the string or Path object, and update all known
   * information that can be determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstat();
  }
  /**
   * synchronous {@link PathScurryBase.lstat}
   */
  lstatSync(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstatSync();
  }
  async readlink(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.readlink();
    return withFileTypes ? e : e?.fullpath();
  }
  readlinkSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.readlinkSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async realpath(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.realpath();
    return withFileTypes ? e : e?.fullpath();
  }
  realpathSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.realpathSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async walk(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = [];
    if (!filter2 || filter2(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const walk2 = (dir, cb) => {
      dirs.add(dir);
      dir.readdirCB((er, entries) => {
        if (er) {
          return cb(er);
        }
        let len = entries.length;
        if (!len)
          return cb();
        const next = () => {
          if (--len === 0) {
            cb();
          }
        };
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          if (follow && e.isSymbolicLink()) {
            e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk2(r, next) : next());
          } else {
            if (e.shouldWalk(dirs, walkFilter)) {
              walk2(e, next);
            } else {
              next();
            }
          }
        }
      }, true);
    };
    const start = entry;
    return new Promise((res, rej) => {
      walk2(start, (er) => {
        if (er)
          return rej(er);
        res(results);
      });
    });
  }
  walkSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = [];
    if (!filter2 || filter2(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        if (!filter2 || filter2(e)) {
          results.push(withFileTypes ? e : e.fullpath());
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
    return results;
  }
  /**
   * Support for `for await`
   *
   * Alias for {@link PathScurryBase.iterate}
   *
   * Note: As of Node 19, this is very slow, compared to other methods of
   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
   */
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
  iterate(entry = this.cwd, options = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      options = entry;
      entry = this.cwd;
    }
    return this.stream(entry, options)[Symbol.asyncIterator]();
  }
  /**
   * Iterating over a PathScurry performs a synchronous walk.
   *
   * Alias for {@link PathScurryBase.iterateSync}
   */
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  *iterateSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    if (!filter2 || filter2(entry)) {
      yield withFileTypes ? entry : entry.fullpath();
    }
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        if (!filter2 || filter2(e)) {
          yield withFileTypes ? e : e.fullpath();
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
  }
  stream(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    if (!filter2 || filter2(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const queue = [entry];
    let processing = 0;
    const process2 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const onReaddir = (er, entries, didRealpaths = false) => {
          if (er)
            return results.emit("error", er);
          if (follow && !didRealpaths) {
            const promises = [];
            for (const e of entries) {
              if (e.isSymbolicLink()) {
                promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
              }
            }
            if (promises.length) {
              Promise.all(promises).then(() => onReaddir(null, entries, true));
              return;
            }
          }
          for (const e of entries) {
            if (e && (!filter2 || filter2(e))) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing--;
          for (const e of entries) {
            const r = e.realpathCached() || e;
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
          if (paused && !results.flowing) {
            results.once("drain", process2);
          } else if (!sync2) {
            process2();
          }
        };
        let sync2 = true;
        dir.readdirCB(onReaddir, true);
        sync2 = false;
      }
    };
    process2();
    return results;
  }
  streamSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    const dirs = /* @__PURE__ */ new Set();
    if (!filter2 || filter2(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const queue = [entry];
    let processing = 0;
    const process2 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            if (!results.write(withFileTypes ? e : e.fullpath())) {
              paused = true;
            }
          }
        }
        processing--;
        for (const e of entries) {
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            queue.push(r);
          }
        }
      }
      if (paused && !results.flowing)
        results.once("drain", process2);
    };
    process2();
    return results;
  }
  chdir(path5 = this.cwd) {
    const oldCwd = this.cwd;
    this.cwd = typeof path5 === "string" ? this.cwd.resolve(path5) : path5;
    this.cwd[setAsCwd](oldCwd);
  }
};
var PathScurryWin32 = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "\\";
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd, import_node_path2.win32, "\\", { ...opts, nocase });
    this.nocase = nocase;
    for (let p = this.cwd; p; p = p.parent) {
      p.nocase = this.nocase;
    }
  }
  /**
   * @internal
   */
  parseRootPath(dir) {
    return import_node_path2.win32.parse(dir).root.toUpperCase();
  }
  /**
   * @internal
   */
  newRoot(fs4) {
    return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs4 });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
  }
};
var PathScurryPosix = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "/";
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = false } = opts;
    super(cwd, import_node_path2.posix, "/", { ...opts, nocase });
    this.nocase = nocase;
  }
  /**
   * @internal
   */
  parseRootPath(_dir) {
    return "/";
  }
  /**
   * @internal
   */
  newRoot(fs4) {
    return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs4 });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/");
  }
};
var PathScurryDarwin = class extends PathScurryPosix {
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd, { ...opts, nocase });
  }
};
var Path = process.platform === "win32" ? PathWin32 : PathPosix;
var PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

// node_modules/glob/dist/esm/pattern.js
var isPatternList = (pl) => pl.length >= 1;
var isGlobList = (gl) => gl.length >= 1;
var Pattern = class _Pattern {
  #patternList;
  #globList;
  #index;
  length;
  #platform;
  #rest;
  #globString;
  #isDrive;
  #isUNC;
  #isAbsolute;
  #followGlobstar = true;
  constructor(patternList, globList, index, platform) {
    if (!isPatternList(patternList)) {
      throw new TypeError("empty pattern list");
    }
    if (!isGlobList(globList)) {
      throw new TypeError("empty glob list");
    }
    if (globList.length !== patternList.length) {
      throw new TypeError("mismatched pattern list and glob list lengths");
    }
    this.length = patternList.length;
    if (index < 0 || index >= this.length) {
      throw new TypeError("index out of range");
    }
    this.#patternList = patternList;
    this.#globList = globList;
    this.#index = index;
    this.#platform = platform;
    if (this.#index === 0) {
      if (this.isUNC()) {
        const [p0, p1, p2, p3, ...prest] = this.#patternList;
        const [g0, g1, g2, g3, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = [p0, p1, p2, p3, ""].join("/");
        const g = [g0, g1, g2, g3, ""].join("/");
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      } else if (this.isDrive() || this.isAbsolute()) {
        const [p1, ...prest] = this.#patternList;
        const [g1, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = p1 + "/";
        const g = g1 + "/";
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      }
    }
  }
  /**
   * The first entry in the parsed list of patterns
   */
  pattern() {
    return this.#patternList[this.#index];
  }
  /**
   * true of if pattern() returns a string
   */
  isString() {
    return typeof this.#patternList[this.#index] === "string";
  }
  /**
   * true of if pattern() returns GLOBSTAR
   */
  isGlobstar() {
    return this.#patternList[this.#index] === GLOBSTAR;
  }
  /**
   * true if pattern() returns a regexp
   */
  isRegExp() {
    return this.#patternList[this.#index] instanceof RegExp;
  }
  /**
   * The /-joined set of glob parts that make up this pattern
   */
  globString() {
    return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
  }
  /**
   * true if there are more pattern parts after this one
   */
  hasMore() {
    return this.length > this.#index + 1;
  }
  /**
   * The rest of the pattern after this part, or null if this is the end
   */
  rest() {
    if (this.#rest !== void 0)
      return this.#rest;
    if (!this.hasMore())
      return this.#rest = null;
    this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
    this.#rest.#isAbsolute = this.#isAbsolute;
    this.#rest.#isUNC = this.#isUNC;
    this.#rest.#isDrive = this.#isDrive;
    return this.#rest;
  }
  /**
   * true if the pattern represents a //unc/path/ on windows
   */
  isUNC() {
    const pl = this.#patternList;
    return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
  }
  // pattern like C:/...
  // split = ['C:', ...]
  // XXX: would be nice to handle patterns like `c:*` to test the cwd
  // in c: for *, but I don't know of a way to even figure out what that
  // cwd is without actually chdir'ing into it?
  /**
   * True if the pattern starts with a drive letter on Windows
   */
  isDrive() {
    const pl = this.#patternList;
    return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
  }
  // pattern = '/' or '/...' or '/x/...'
  // split = ['', ''] or ['', ...] or ['', 'x', ...]
  // Drive and UNC both considered absolute on windows
  /**
   * True if the pattern is rooted on an absolute path
   */
  isAbsolute() {
    const pl = this.#patternList;
    return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
  }
  /**
   * consume the root of the pattern, and return it
   */
  root() {
    const p = this.#patternList[0];
    return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
  }
  /**
   * Check to see if the current globstar pattern is allowed to follow
   * a symbolic link.
   */
  checkFollowGlobstar() {
    return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
  }
  /**
   * Mark that the current globstar pattern is following a symbolic link
   */
  markFollowGlobstar() {
    if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
      return false;
    this.#followGlobstar = false;
    return true;
  }
};

// node_modules/glob/dist/esm/ignore.js
var defaultPlatform2 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Ignore = class {
  relative;
  relativeChildren;
  absolute;
  absoluteChildren;
  platform;
  mmopts;
  constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform2 }) {
    this.relative = [];
    this.absolute = [];
    this.relativeChildren = [];
    this.absoluteChildren = [];
    this.platform = platform;
    this.mmopts = {
      dot: true,
      nobrace,
      nocase,
      noext,
      noglobstar,
      optimizationLevel: 2,
      platform,
      nocomment: true,
      nonegate: true
    };
    for (const ign of ignored)
      this.add(ign);
  }
  add(ign) {
    const mm = new Minimatch(ign, this.mmopts);
    for (let i = 0; i < mm.set.length; i++) {
      const parsed = mm.set[i];
      const globParts = mm.globParts[i];
      if (!parsed || !globParts) {
        throw new Error("invalid pattern object");
      }
      while (parsed[0] === "." && globParts[0] === ".") {
        parsed.shift();
        globParts.shift();
      }
      const p = new Pattern(parsed, globParts, 0, this.platform);
      const m = new Minimatch(p.globString(), this.mmopts);
      const children = globParts[globParts.length - 1] === "**";
      const absolute = p.isAbsolute();
      if (absolute)
        this.absolute.push(m);
      else
        this.relative.push(m);
      if (children) {
        if (absolute)
          this.absoluteChildren.push(m);
        else
          this.relativeChildren.push(m);
      }
    }
  }
  ignored(p) {
    const fullpath = p.fullpath();
    const fullpaths = `${fullpath}/`;
    const relative = p.relative() || ".";
    const relatives = `${relative}/`;
    for (const m of this.relative) {
      if (m.match(relative) || m.match(relatives))
        return true;
    }
    for (const m of this.absolute) {
      if (m.match(fullpath) || m.match(fullpaths))
        return true;
    }
    return false;
  }
  childrenIgnored(p) {
    const fullpath = p.fullpath() + "/";
    const relative = (p.relative() || ".") + "/";
    for (const m of this.relativeChildren) {
      if (m.match(relative))
        return true;
    }
    for (const m of this.absoluteChildren) {
      if (m.match(fullpath))
        return true;
    }
    return false;
  }
};

// node_modules/glob/dist/esm/processor.js
var HasWalkedCache = class _HasWalkedCache {
  store;
  constructor(store = /* @__PURE__ */ new Map()) {
    this.store = store;
  }
  copy() {
    return new _HasWalkedCache(new Map(this.store));
  }
  hasWalked(target, pattern) {
    return this.store.get(target.fullpath())?.has(pattern.globString());
  }
  storeWalked(target, pattern) {
    const fullpath = target.fullpath();
    const cached = this.store.get(fullpath);
    if (cached)
      cached.add(pattern.globString());
    else
      this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
  }
};
var MatchRecord = class {
  store = /* @__PURE__ */ new Map();
  add(target, absolute, ifDir) {
    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
    const current = this.store.get(target);
    this.store.set(target, current === void 0 ? n : n & current);
  }
  // match, absolute, ifdir
  entries() {
    return [...this.store.entries()].map(([path5, n]) => [
      path5,
      !!(n & 2),
      !!(n & 1)
    ]);
  }
};
var SubWalks = class {
  store = /* @__PURE__ */ new Map();
  add(target, pattern) {
    if (!target.canReaddir()) {
      return;
    }
    const subs = this.store.get(target);
    if (subs) {
      if (!subs.find((p) => p.globString() === pattern.globString())) {
        subs.push(pattern);
      }
    } else
      this.store.set(target, [pattern]);
  }
  get(target) {
    const subs = this.store.get(target);
    if (!subs) {
      throw new Error("attempting to walk unknown path");
    }
    return subs;
  }
  entries() {
    return this.keys().map((k) => [k, this.store.get(k)]);
  }
  keys() {
    return [...this.store.keys()].filter((t) => t.canReaddir());
  }
};
var Processor = class _Processor {
  hasWalkedCache;
  matches = new MatchRecord();
  subwalks = new SubWalks();
  patterns;
  follow;
  dot;
  opts;
  constructor(opts, hasWalkedCache) {
    this.opts = opts;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
  }
  processPatterns(target, patterns) {
    this.patterns = patterns;
    const processingSet = patterns.map((p) => [target, p]);
    for (let [t, pattern] of processingSet) {
      this.hasWalkedCache.storeWalked(t, pattern);
      const root = pattern.root();
      const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
      if (root) {
        t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
        const rest2 = pattern.rest();
        if (!rest2) {
          this.matches.add(t, true, false);
          continue;
        } else {
          pattern = rest2;
        }
      }
      if (t.isENOENT())
        continue;
      let p;
      let rest;
      let changed = false;
      while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
        const c = t.resolve(p);
        t = c;
        pattern = rest;
        changed = true;
      }
      p = pattern.pattern();
      rest = pattern.rest();
      if (changed) {
        if (this.hasWalkedCache.hasWalked(t, pattern))
          continue;
        this.hasWalkedCache.storeWalked(t, pattern);
      }
      if (typeof p === "string") {
        const ifDir = p === ".." || p === "" || p === ".";
        this.matches.add(t.resolve(p), absolute, ifDir);
        continue;
      } else if (p === GLOBSTAR) {
        if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
          this.subwalks.add(t, pattern);
        }
        const rp = rest?.pattern();
        const rrest = rest?.rest();
        if (!rest || (rp === "" || rp === ".") && !rrest) {
          this.matches.add(t, absolute, rp === "" || rp === ".");
        } else {
          if (rp === "..") {
            const tp = t.parent || t;
            if (!rrest)
              this.matches.add(tp, absolute, true);
            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
              this.subwalks.add(tp, rrest);
            }
          }
        }
      } else if (p instanceof RegExp) {
        this.subwalks.add(t, pattern);
      }
    }
    return this;
  }
  subwalkTargets() {
    return this.subwalks.keys();
  }
  child() {
    return new _Processor(this.opts, this.hasWalkedCache);
  }
  // return a new Processor containing the subwalks for each
  // child entry, and a set of matches, and
  // a hasWalkedCache that's a copy of this one
  // then we're going to call
  filterEntries(parent2, entries) {
    const patterns = this.subwalks.get(parent2);
    const results = this.child();
    for (const e of entries) {
      for (const pattern of patterns) {
        const absolute = pattern.isAbsolute();
        const p = pattern.pattern();
        const rest = pattern.rest();
        if (p === GLOBSTAR) {
          results.testGlobstar(e, pattern, rest, absolute);
        } else if (p instanceof RegExp) {
          results.testRegExp(e, p, rest, absolute);
        } else {
          results.testString(e, p, rest, absolute);
        }
      }
    }
    return results;
  }
  testGlobstar(e, pattern, rest, absolute) {
    if (this.dot || !e.name.startsWith(".")) {
      if (!pattern.hasMore()) {
        this.matches.add(e, absolute, false);
      }
      if (e.canReaddir()) {
        if (this.follow || !e.isSymbolicLink()) {
          this.subwalks.add(e, pattern);
        } else if (e.isSymbolicLink()) {
          if (rest && pattern.checkFollowGlobstar()) {
            this.subwalks.add(e, rest);
          } else if (pattern.markFollowGlobstar()) {
            this.subwalks.add(e, pattern);
          }
        }
      }
    }
    if (rest) {
      const rp = rest.pattern();
      if (typeof rp === "string" && // dots and empty were handled already
      rp !== ".." && rp !== "" && rp !== ".") {
        this.testString(e, rp, rest.rest(), absolute);
      } else if (rp === "..") {
        const ep = e.parent || e;
        this.subwalks.add(ep, rest);
      } else if (rp instanceof RegExp) {
        this.testRegExp(e, rp, rest.rest(), absolute);
      }
    }
  }
  testRegExp(e, p, rest, absolute) {
    if (!p.test(e.name))
      return;
    if (!rest) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest);
    }
  }
  testString(e, p, rest, absolute) {
    if (!e.isNamed(p))
      return;
    if (!rest) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest);
    }
  }
};

// node_modules/glob/dist/esm/walker.js
var makeIgnore = (ignore2, opts) => typeof ignore2 === "string" ? new Ignore([ignore2], opts) : Array.isArray(ignore2) ? new Ignore(ignore2, opts) : ignore2;
var GlobUtil = class {
  path;
  patterns;
  opts;
  seen = /* @__PURE__ */ new Set();
  paused = false;
  aborted = false;
  #onResume = [];
  #ignore;
  #sep;
  signal;
  maxDepth;
  includeChildMatches;
  constructor(patterns, path5, opts) {
    this.patterns = patterns;
    this.path = path5;
    this.opts = opts;
    this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
    this.includeChildMatches = opts.includeChildMatches !== false;
    if (opts.ignore || !this.includeChildMatches) {
      this.#ignore = makeIgnore(opts.ignore ?? [], opts);
      if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
        const m = "cannot ignore child matches, ignore lacks add() method.";
        throw new Error(m);
      }
    }
    this.maxDepth = opts.maxDepth || Infinity;
    if (opts.signal) {
      this.signal = opts.signal;
      this.signal.addEventListener("abort", () => {
        this.#onResume.length = 0;
      });
    }
  }
  #ignored(path5) {
    return this.seen.has(path5) || !!this.#ignore?.ignored?.(path5);
  }
  #childrenIgnored(path5) {
    return !!this.#ignore?.childrenIgnored?.(path5);
  }
  // backpressure mechanism
  pause() {
    this.paused = true;
  }
  resume() {
    if (this.signal?.aborted)
      return;
    this.paused = false;
    let fn = void 0;
    while (!this.paused && (fn = this.#onResume.shift())) {
      fn();
    }
  }
  onResume(fn) {
    if (this.signal?.aborted)
      return;
    if (!this.paused) {
      fn();
    } else {
      this.#onResume.push(fn);
    }
  }
  // do the requisite realpath/stat checking, and return the path
  // to add or undefined to filter it out.
  async matchCheck(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || await e.realpath();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    const s = needStat ? await e.lstat() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = await s.realpath();
      if (target && (target.isUnknown() || this.opts.stat)) {
        await target.lstat();
      }
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchCheckTest(e, ifDir) {
    return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
  }
  matchCheckSync(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || e.realpathSync();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    const s = needStat ? e.lstatSync() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = s.realpathSync();
      if (target && (target?.isUnknown() || this.opts.stat)) {
        target.lstatSync();
      }
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchFinish(e, absolute) {
    if (this.#ignored(e))
      return;
    if (!this.includeChildMatches && this.#ignore?.add) {
      const ign = `${e.relativePosix()}/**`;
      this.#ignore.add(ign);
    }
    const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
    this.seen.add(e);
    const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
    if (this.opts.withFileTypes) {
      this.matchEmit(e);
    } else if (abs) {
      const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
      this.matchEmit(abs2 + mark);
    } else {
      const rel = this.opts.posix ? e.relativePosix() : e.relative();
      const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
      this.matchEmit(!rel ? "." + mark : pre + rel + mark);
    }
  }
  async match(e, absolute, ifDir) {
    const p = await this.matchCheck(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  matchSync(e, absolute, ifDir) {
    const p = this.matchCheckSync(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  walkCB(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next());
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const childrenCached = t.readdirCached();
      if (t.calledReaddir())
        this.walkCB3(t, childrenCached, processor, next);
      else {
        t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
      }
    }
    next();
  }
  walkCB3(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next());
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2(target2, patterns, processor.child(), next);
    }
    next();
  }
  walkCBSync(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2Sync(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const children = t.readdirSync();
      this.walkCB3Sync(t, children, processor, next);
    }
    next();
  }
  walkCB3Sync(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2Sync(target2, patterns, processor.child(), next);
    }
    next();
  }
};
var GlobWalker = class extends GlobUtil {
  matches = /* @__PURE__ */ new Set();
  constructor(patterns, path5, opts) {
    super(patterns, path5, opts);
  }
  matchEmit(e) {
    this.matches.add(e);
  }
  async walk() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      await this.path.lstat();
    }
    await new Promise((res, rej) => {
      this.walkCB(this.path, this.patterns, () => {
        if (this.signal?.aborted) {
          rej(this.signal.reason);
        } else {
          res(this.matches);
        }
      });
    });
    return this.matches;
  }
  walkSync() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => {
      if (this.signal?.aborted)
        throw this.signal.reason;
    });
    return this.matches;
  }
};
var GlobStream = class extends GlobUtil {
  results;
  constructor(patterns, path5, opts) {
    super(patterns, path5, opts);
    this.results = new Minipass({
      signal: this.signal,
      objectMode: true
    });
    this.results.on("drain", () => this.resume());
    this.results.on("resume", () => this.resume());
  }
  matchEmit(e) {
    this.results.write(e);
    if (!this.results.flowing)
      this.pause();
  }
  stream() {
    const target = this.path;
    if (target.isUnknown()) {
      target.lstat().then(() => {
        this.walkCB(target, this.patterns, () => this.results.end());
      });
    } else {
      this.walkCB(target, this.patterns, () => this.results.end());
    }
    return this.results;
  }
  streamSync() {
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => this.results.end());
    return this.results;
  }
};

// node_modules/glob/dist/esm/glob.js
var defaultPlatform3 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Glob = class {
  absolute;
  cwd;
  root;
  dot;
  dotRelative;
  follow;
  ignore;
  magicalBraces;
  mark;
  matchBase;
  maxDepth;
  nobrace;
  nocase;
  nodir;
  noext;
  noglobstar;
  pattern;
  platform;
  realpath;
  scurry;
  stat;
  signal;
  windowsPathsNoEscape;
  withFileTypes;
  includeChildMatches;
  /**
   * The options provided to the constructor.
   */
  opts;
  /**
   * An array of parsed immutable {@link Pattern} objects.
   */
  patterns;
  /**
   * All options are stored as properties on the `Glob` object.
   *
   * See {@link GlobOptions} for full options descriptions.
   *
   * Note that a previous `Glob` object can be passed as the
   * `GlobOptions` to another `Glob` instantiation to re-use settings
   * and caches with a new pattern.
   *
   * Traversal functions can be called multiple times to run the walk
   * again.
   */
  constructor(pattern, opts) {
    if (!opts)
      throw new TypeError("glob options required");
    this.withFileTypes = !!opts.withFileTypes;
    this.signal = opts.signal;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.dotRelative = !!opts.dotRelative;
    this.nodir = !!opts.nodir;
    this.mark = !!opts.mark;
    if (!opts.cwd) {
      this.cwd = "";
    } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
      opts.cwd = (0, import_node_url3.fileURLToPath)(opts.cwd);
    }
    this.cwd = opts.cwd || "";
    this.root = opts.root;
    this.magicalBraces = !!opts.magicalBraces;
    this.nobrace = !!opts.nobrace;
    this.noext = !!opts.noext;
    this.realpath = !!opts.realpath;
    this.absolute = opts.absolute;
    this.includeChildMatches = opts.includeChildMatches !== false;
    this.noglobstar = !!opts.noglobstar;
    this.matchBase = !!opts.matchBase;
    this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
    this.stat = !!opts.stat;
    this.ignore = opts.ignore;
    if (this.withFileTypes && this.absolute !== void 0) {
      throw new Error("cannot set absolute and withFileTypes:true");
    }
    if (typeof pattern === "string") {
      pattern = [pattern];
    }
    this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      pattern = pattern.map((p) => p.replace(/\\/g, "/"));
    }
    if (this.matchBase) {
      if (opts.noglobstar) {
        throw new TypeError("base matching requires globstar");
      }
      pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
    }
    this.pattern = pattern;
    this.platform = opts.platform || defaultPlatform3;
    this.opts = { ...opts, platform: this.platform };
    if (opts.scurry) {
      this.scurry = opts.scurry;
      if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
        throw new Error("nocase option contradicts provided scurry option");
      }
    } else {
      const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
      this.scurry = new Scurry(this.cwd, {
        nocase: opts.nocase,
        fs: opts.fs
      });
    }
    this.nocase = this.scurry.nocase;
    const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
    const mmo = {
      // default nocase based on platform
      ...opts,
      dot: this.dot,
      matchBase: this.matchBase,
      nobrace: this.nobrace,
      nocase: this.nocase,
      nocaseMagicOnly,
      nocomment: true,
      noext: this.noext,
      nonegate: true,
      optimizationLevel: 2,
      platform: this.platform,
      windowsPathsNoEscape: this.windowsPathsNoEscape,
      debug: !!this.opts.debug
    };
    const mms = this.pattern.map((p) => new Minimatch(p, mmo));
    const [matchSet, globParts] = mms.reduce((set, m) => {
      set[0].push(...m.set);
      set[1].push(...m.globParts);
      return set;
    }, [[], []]);
    this.patterns = matchSet.map((set, i) => {
      const g = globParts[i];
      if (!g)
        throw new Error("invalid pattern object");
      return new Pattern(set, g, 0, this.platform);
    });
  }
  async walk() {
    return [
      ...await new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walk()
    ];
  }
  walkSync() {
    return [
      ...new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walkSync()
    ];
  }
  stream() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).stream();
  }
  streamSync() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).streamSync();
  }
  /**
   * Default sync iteration function. Returns a Generator that
   * iterates over the results.
   */
  iterateSync() {
    return this.streamSync()[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  /**
   * Default async iteration function. Returns an AsyncGenerator that
   * iterates over the results.
   */
  iterate() {
    return this.stream()[Symbol.asyncIterator]();
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
};

// node_modules/glob/dist/esm/has-magic.js
var hasMagic = (pattern, options = {}) => {
  if (!Array.isArray(pattern)) {
    pattern = [pattern];
  }
  for (const p of pattern) {
    if (new Minimatch(p, options).hasMagic())
      return true;
  }
  return false;
};

// node_modules/glob/dist/esm/index.js
function globStreamSync(pattern, options = {}) {
  return new Glob(pattern, options).streamSync();
}
function globStream(pattern, options = {}) {
  return new Glob(pattern, options).stream();
}
function globSync(pattern, options = {}) {
  return new Glob(pattern, options).walkSync();
}
async function glob_(pattern, options = {}) {
  return new Glob(pattern, options).walk();
}
function globIterateSync(pattern, options = {}) {
  return new Glob(pattern, options).iterateSync();
}
function globIterate(pattern, options = {}) {
  return new Glob(pattern, options).iterate();
}
var streamSync = globStreamSync;
var stream = Object.assign(globStream, { sync: globStreamSync });
var iterateSync = globIterateSync;
var iterate = Object.assign(globIterate, {
  sync: globIterateSync
});
var sync = Object.assign(globSync, {
  stream: globStreamSync,
  iterate: globIterateSync
});
var glob = Object.assign(glob_, {
  glob: glob_,
  globSync,
  sync,
  globStream,
  stream,
  globStreamSync,
  streamSync,
  globIterate,
  iterate,
  globIterateSync,
  iterateSync,
  Glob,
  hasMagic,
  escape: escape3,
  unescape: unescape2
});
glob.glob = glob;

// node_modules/html-validate/dist/esm/cli.js
var import_prompts = __toESM(require_prompts3(), 1);
var DEFAULT_EXTENSIONS = ["html"];
function isDirectory(filename) {
  const st = import_fs2.default.statSync(filename);
  return st.isDirectory();
}
function join(stem, filename) {
  if (import_node_path3.default.isAbsolute(filename)) {
    return import_node_path3.default.normalize(filename);
  } else {
    return import_node_path3.default.normalize(import_node_path3.default.join(stem, filename));
  }
}
function directoryPattern(extensions) {
  switch (extensions.length) {
    case 0:
      return "**/*";
    case 1:
      return `**/*.${extensions[0]}`;
    default:
      return `**/*.{${extensions.join(",")}}`;
  }
}
function expandFiles(patterns, options) {
  const cwd = options.cwd ?? process.cwd();
  const extensions = options.extensions ?? DEFAULT_EXTENSIONS;
  const files = patterns.reduce((result, pattern) => {
    if (pattern === "-") {
      result.push("/dev/stdin");
      return result;
    }
    for (const filename of globSync(pattern, { cwd })) {
      const fullpath = join(cwd, filename);
      if (isDirectory(fullpath)) {
        const dir = expandFiles([directoryPattern(extensions)], { ...options, cwd: fullpath });
        result = result.concat(dir.map((cur) => join(filename, cur)));
        continue;
      }
      result.push(fullpath);
    }
    return result.sort((a, b) => {
      const pa = a.split("/").length;
      const pb = b.split("/").length;
      if (pa !== pb) {
        return pa - pb;
      } else {
        return a > b ? 1 : -1;
      }
    });
  }, []);
  return Array.from(new Set(files));
}
function wrap(formatter2, dst) {
  return (results) => {
    const output = formatter2(results);
    if (dst) {
      const dir = import_node_path3.default.dirname(dst);
      if (!import_fs2.default.existsSync(dir)) {
        import_fs2.default.mkdirSync(dir, { recursive: true });
      }
      import_fs2.default.writeFileSync(dst, output, "utf-8");
      return "";
    } else {
      return output;
    }
  };
}
function loadFormatter(name) {
  const fn = getFormatter(name);
  if (fn) {
    return fn;
  }
  try {
    return legacyRequire(name);
  } catch (error) {
    throw new UserError(`No formatter named "${name}"`, ensureError(error));
  }
}
function getFormatter2(formatters) {
  const fn = formatters.split(",").map((cur) => {
    const [name, dst] = cur.split("=", 2);
    const fn2 = loadFormatter(name);
    return wrap(fn2, dst);
  });
  return (report) => {
    return fn.map((formatter2) => formatter2(report.results)).filter(Boolean).join("\n");
  };
}
var IsIgnored = class {
  /** Cache for parsed .htmlvalidateignore files */
  cacheIgnore;
  constructor() {
    this.cacheIgnore = /* @__PURE__ */ new Map();
  }
  /**
   * Searches ".htmlvalidateignore" files from filesystem and returns `true` if
   * one of them contains a pattern matching given filename.
   */
  isIgnored(filename) {
    return this.match(filename);
  }
  /**
   * Clear cache
   */
  clearCache() {
    this.cacheIgnore.clear();
  }
  match(target) {
    let current = import_node_path3.default.dirname(target);
    while (true) {
      const relative = import_node_path3.default.relative(current, target);
      const filename = import_node_path3.default.join(current, ".htmlvalidateignore");
      const ig = this.parseFile(filename);
      if (ig?.ignores(relative)) {
        return true;
      }
      const child = current;
      current = import_node_path3.default.dirname(current);
      if (current === child) {
        break;
      }
    }
    return false;
  }
  parseFile(filename) {
    if (this.cacheIgnore.has(filename)) {
      return this.cacheIgnore.get(filename);
    }
    if (!import_fs2.default.existsSync(filename)) {
      this.cacheIgnore.set(filename, void 0);
      return void 0;
    }
    const content = import_fs2.default.readFileSync(filename, "utf-8");
    const ig = ignore().add(content);
    this.cacheIgnore.set(filename, ig);
    return ig;
  }
};
var frameworkConfig = {
  [
    "AngularJS"
    /* angularjs */
  ]: {
    transform: {
      "^.*\\.js$": "html-validate-angular/js",
      "^.*\\.html$": "html-validate-angular/html"
    }
  },
  [
    "Vue.js"
    /* vuejs */
  ]: {
    plugins: ["html-validate-vue"],
    extends: ["html-validate-vue:recommended"],
    transform: {
      "^.*\\.vue$": "html-validate-vue"
    }
  },
  [
    "Markdown"
    /* markdown */
  ]: {
    transform: {
      "^.*\\.md$": "html-validate-markdown"
    }
  }
};
function addFrameworks(src, frameworks) {
  let config2 = src;
  for (const framework of frameworks) {
    config2 = deepmerge(config2, frameworkConfig[framework]);
  }
  return config2;
}
function writeConfig(dst, config2) {
  return new Promise((resolve, reject) => {
    import_fs2.default.writeFile(dst, JSON.stringify(config2, null, 2), (err) => {
      if (err) reject(err);
      resolve();
    });
  });
}
async function init$1(cwd) {
  const filename = `${cwd}/.htmlvalidate.json`;
  const exists = import_fs2.default.existsSync(filename);
  const initialConfig = {
    elements: ["html5"],
    extends: ["html-validate:recommended"]
  };
  if (exists) {
    const result = await (0, import_prompts.default)({
      name: "overwrite",
      type: "confirm",
      message: "A .htmlvalidate.json file already exists, do you want to overwrite it?"
    });
    if (!result.overwrite) {
      return Promise.reject();
    }
  }
  const questions = [
    {
      name: "frameworks",
      type: "multiselect",
      choices: [
        {
          title: "AngularJS",
          value: "AngularJS"
          /* angularjs */
        },
        {
          title: "Vue.js",
          value: "Vue.js"
          /* vuejs */
        },
        {
          title: "Markdown",
          value: "Markdown"
          /* markdown */
        }
      ],
      message: "Support additional frameworks?"
    }
  ];
  const answers = await (0, import_prompts.default)(questions);
  let config2 = initialConfig;
  config2 = addFrameworks(config2, answers.frameworks);
  await writeConfig(filename, config2);
  return {
    filename
  };
}
function parseSeverity2(ruleId, severity) {
  switch (severity) {
    case "off":
    case "0":
      return "off";
    case "warn":
    case "1":
      return "warn";
    case "error":
    case "2":
      return "error";
    default:
      throw new Error(`Invalid severity "${severity}" for rule "${ruleId}"`);
  }
}
function parseItem(value) {
  const [ruleId, severity = "error"] = value.split(":", 2);
  return { ruleId, severity: parseSeverity2(ruleId, severity) };
}
function getRuleConfig(values) {
  if (typeof values === "string") {
    return getRuleConfig([values]);
  }
  return values.reduce((parsedRules, value) => {
    const { ruleId, severity } = parseItem(value.trim());
    return { [ruleId]: severity, ...parsedRules };
  }, {});
}
var resolver = esmResolver();
function defaultConfig2(preset) {
  const presets2 = preset.split(",").map((it) => `html-validate:${it}`);
  return {
    extends: presets2
  };
}
async function getBaseConfig(preset, filename) {
  if (filename) {
    const configData = await resolver.resolveConfig(import_posix.default.resolve(filename), { cache: false });
    if (!configData) {
      throw new UserError(`Failed to read configuration from "${filename}"`);
    }
    return configData;
  } else {
    return defaultConfig2(preset ?? "recommended");
  }
}
var CLI = class {
  options;
  config;
  loader;
  ignored;
  /**
   * Create new CLI helper.
   *
   * Can be used to create tooling with similar properties to bundled CLI
   * script.
   */
  constructor(options) {
    this.options = options ?? {};
    this.config = null;
    this.loader = null;
    this.ignored = new IsIgnored();
  }
  /**
   * Returns list of files matching patterns and are not ignored. Filenames will
   * have absolute paths.
   *
   * @public
   */
  async expandFiles(patterns, options = {}) {
    const files = expandFiles(patterns, options).filter((filename) => !this.isIgnored(filename));
    return Promise.resolve(files);
  }
  getFormatter(formatters) {
    return Promise.resolve(getFormatter2(formatters));
  }
  /**
   * Initialize project with a new configuration.
   *
   * A new `.htmlvalidate.json` file will be placed in the path provided by
   * `cwd`.
   */
  init(cwd) {
    return init$1(cwd);
  }
  /**
   * Clear cache.
   *
   * Previously fetched [[HtmlValidate]] instances must either be fetched again
   * or call [[HtmlValidate.flushConfigCache]].
   */
  /* istanbul ignore next: each method is tested separately */
  clearCache() {
    if (this.loader) {
      this.loader.flushCache();
    }
    this.ignored.clearCache();
    return Promise.resolve();
  }
  /**
   * Get HtmlValidate instance with configuration based on options passed to the
   * constructor.
   *
   * @internal
   */
  async getLoader() {
    if (!this.loader) {
      const config2 = await this.getConfig();
      this.loader = new FileSystemConfigLoader([resolver], config2);
    }
    return this.loader;
  }
  /**
   * Get HtmlValidate instance with configuration based on options passed to the
   * constructor.
   *
   * @public
   */
  async getValidator() {
    const loader = await this.getLoader();
    return new HtmlValidate(loader);
  }
  /**
   * @internal
   */
  async getConfig() {
    this.config ??= await this.resolveConfig();
    return this.config;
  }
  /**
   * Searches ".htmlvalidateignore" files from filesystem and returns `true` if
   * one of them contains a pattern matching given filename.
   */
  isIgnored(filename) {
    return this.ignored.isIgnored(filename);
  }
  async resolveConfig() {
    const { options } = this;
    const havePreset = Boolean(options.preset);
    const haveConfig = Boolean(options.configFile);
    const config2 = await getBaseConfig(options.preset, options.configFile);
    if (options.rules) {
      if (havePreset || haveConfig) {
        config2.rules = { ...config2.rules, ...getRuleConfig(options.rules) };
      } else {
        config2.extends = [];
        config2.rules = getRuleConfig(options.rules);
      }
    }
    return config2;
  }
};

// node_modules/html-validate/dist/esm/index.js
var import_ajv2 = __toESM(require_ajv(), 1);
var import_semver2 = __toESM(require_semver2(), 1);
var import_prompts2 = __toESM(require_prompts3(), 1);

// server/src/server.ts
var import_satisfies = __toESM(require_satisfies());

// server/src/code-actions.ts
var import_vscode_languageserver = __toESM(require_main4());
async function ruleDocumentationAction(htmlvalidate, diagnostic) {
  if (diagnostic.source !== "html-validate" || !diagnostic.code) {
    return null;
  }
  const ruleId = diagnostic.code;
  const documentation = await htmlvalidate.getRuleDocumentation(ruleId);
  if (!documentation) {
    return null;
  }
  const title2 = `Show documentation for ${ruleId}`;
  const command = import_vscode_languageserver.Command.create(title2, "html-validate.rule-documentation" /* RULE_DOCUMENTATION */, documentation.url);
  return import_vscode_languageserver.CodeAction.create(title2, command, import_vscode_languageserver.CodeActionKind.QuickFix);
}
async function onCodeAction(params) {
  const { context } = params;
  const resource = params.textDocument.uri;
  const uri = URI.parse(resource);
  const htmlvalidate = await this.getDocumentValidator(uri.path);
  if (!htmlvalidate) {
    return [];
  }
  const actions = [];
  for (const diagnostic of context.diagnostics) {
    try {
      const action = await ruleDocumentationAction(htmlvalidate, diagnostic);
      if (action) {
        actions.push(action);
      }
    } catch (error) {
      this.trace(String(error));
    }
  }
  return actions;
}

// server/src/hover.ts
function containsPosition(range2, position) {
  if (position.line < range2.start.line || position.line > range2.end.line) {
    return false;
  }
  if (position.line === range2.start.line && position.character < range2.start.character) {
    return false;
  }
  if (position.line === range2.end.line && position.character > range2.end.character) {
    return false;
  }
  return true;
}
async function onHover(params) {
  const resource = params.textDocument.uri;
  const diagnostics = this.getDocumentDiagnostics(resource);
  if (diagnostics.length === 0) {
    return null;
  }
  const diagnostic = diagnostics.find((cur) => {
    return containsPosition(cur.range, params.position);
  });
  if (!diagnostic) {
    return null;
  }
  const htmlvalidate = await this.getDocumentValidator(resource);
  if (!htmlvalidate) {
    return null;
  }
  const ruleId = diagnostic.code;
  const documentation = diagnostic.documentation;
  if (!documentation) {
    const contents2 = [`HTML-Validate`, diagnostic.message].join("\n\n");
    return { contents: contents2 };
  }
  const contents = [
    `HTML-Validate`,
    documentation.description,
    documentation.url ? `[${ruleId}](${documentation.url})` : ruleId
  ].join("\n\n");
  return { contents };
}

// server/src/server.ts
var HtmlValidateVersion = ">= 5.3";
var MinVersionErrorRequest = new import_node.RequestType(
  "html-validate/min-version-error"
);
var ConfigErrorRequest = new import_node.RequestType(
  "html-validate/config-error"
);
var connection = (0, import_node.createConnection)(import_node.ProposedFeatures.all);
var documents = new import_node.TextDocuments(TextDocument);
var documentEnabled = /* @__PURE__ */ new Map();
var documentSettings = /* @__PURE__ */ new Map();
var documentValidator = /* @__PURE__ */ new Map();
var documentDiagnostics = /* @__PURE__ */ new Map();
var apiContext = {
  getDocumentDiagnostics,
  getDocumentValidator,
  trace
};
function getDocumentSettings(resource) {
  let result = documentSettings.get(resource);
  if (!result) {
    result = connection.workspace.getConfiguration({
      scopeUri: resource,
      section: "html-validate"
    });
    documentSettings.set(resource, result);
  }
  return result;
}
function getDocumentValidator(resource) {
  let result = documentValidator.get(resource);
  if (!result) {
    result = getHtmlValidate(resource);
    documentEnabled.set(resource, true);
    documentValidator.set(resource, result);
  }
  return result;
}
function getDocumentDiagnostics(resource) {
  const result = documentDiagnostics.get(resource);
  if (!result) {
    return [];
  }
  return result;
}
function trace(message, verbose) {
  connection.tracer.log(message, verbose);
}
function convertSeverity(severity) {
  switch (severity) {
    case 1:
      return import_node.DiagnosticSeverity.Warning;
    case 2:
      return import_node.DiagnosticSeverity.Error;
    default:
      return import_node.DiagnosticSeverity.Error;
  }
}
async function convertDiagnostic(textDocument, config2, htmlvalidate, message) {
  const documentation = await htmlvalidate.getRuleDocumentation(
    message.ruleId,
    config2,
    message.context
  );
  return {
    severity: convertSeverity(message.severity),
    range: {
      start: textDocument.positionAt(message.offset),
      end: textDocument.positionAt(message.offset + message.size)
    },
    message: message.message,
    code: message.ruleId,
    source: "html-validate",
    documentation
  };
}
function isValidVersion(version2) {
  if (!version2) {
    return false;
  }
  return (0, import_satisfies.default)(version2, HtmlValidateVersion);
}
function findUp(name, cwd) {
  let directory = import_path.default.resolve(cwd);
  const { root } = import_path.default.parse(directory);
  const stopAt = import_path.default.resolve(directory, root);
  while (directory !== stopAt) {
    const filePath = import_path.default.resolve(directory, name);
    if (import_node_fs2.default.existsSync(filePath) && import_node_fs2.default.statSync(filePath).isFile()) {
      return filePath;
    }
    directory = import_path.default.dirname(directory);
  }
  return void 0;
}
async function findProjectLibrary(cwd) {
  connection.tracer.log(`Searching package.json from directory "${cwd}"`);
  let current = cwd;
  while (current !== "/") {
    const pkg = findUp("package.json", current);
    if (!pkg) {
      break;
    }
    const nodePath = import_path.default.dirname(pkg);
    try {
      return await import_node.Files.resolve("html-validate", nodePath, nodePath, trace);
    } catch {
    }
    current = import_path.default.dirname(nodePath);
  }
  return null;
}
async function findGlobalLibrary() {
  try {
    const globalYarn = import_node.Files.resolveGlobalYarnPath(trace);
    return await import_node.Files.resolve("html-validate", globalYarn, void 0, trace);
  } catch {
    try {
      const globalNpm = import_node.Files.resolveGlobalNodePath(trace);
      return await import_node.Files.resolve("html-validate", globalNpm, void 0, trace);
    } catch {
      return null;
    }
  }
}
async function findLibrary(cwd) {
  const local = await findProjectLibrary(cwd);
  if (local) {
    return local;
  }
  const global = await findGlobalLibrary();
  if (global) {
    return global;
  }
  return null;
}
function getBundledModule() {
  return { CLI, version };
}
async function getHtmlValidate(resource) {
  const dir = import_path.default.dirname(resource);
  const modulePath = await findLibrary(dir);
  if (!modulePath) {
    connection.tracer.log(`failed to locate html-validate, using bundled version`);
    connection.tracer.log(`html-validate is at version "${version}"`);
    const { CLI: CLI3 } = getBundledModule();
    const cli2 = new CLI3();
    return cli2.getValidator();
  }
  connection.tracer.log(`html-validate found at "${modulePath}"`);
  const r = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
  const module2 = r(modulePath);
  connection.tracer.log(`html-validate is at version "${module2.version}"`);
  if (!isValidVersion(module2.version)) {
    connection.sendRequest(MinVersionErrorRequest, {
      min: HtmlValidateVersion,
      cur: module2.version || "unknown"
    }).then(void 0, () => {
    });
    return null;
  }
  const { CLI: CLI2 } = module2;
  const cli = new CLI2();
  return cli.getValidator();
}
async function validateTextDocument(textDocument) {
  const resource = textDocument.uri;
  const settings = await getDocumentSettings(resource);
  const uri = URI.parse(resource);
  documentDiagnostics.set(resource, []);
  if (!settings.enable) {
    return;
  }
  const enabled = documentEnabled.get(resource);
  if (enabled === false) {
    connection.tracer.log(
      `Validation disabled for ${textDocument.uri} until configuration issue is resolved.`
    );
    return;
  }
  if (!settings.validate.includes(textDocument.languageId)) {
    connection.tracer.log(
      `skipping html-validate for "${uri.fsPath}" (language: "${textDocument.languageId}")`
    );
    return;
  }
  let htmlvalidate;
  try {
    const result = await getDocumentValidator(uri.path);
    if (!result) {
      return;
    }
    htmlvalidate = result;
  } catch (err) {
    connection.tracer.log(`failed to load html-validate for "${uri.fsPath}"`);
    connection.tracer.log(String(err));
    return;
  }
  const canValidate = await htmlvalidate.canValidate(uri.fsPath);
  if (!canValidate) {
    connection.tracer.log(
      `skipping html-validate for "${uri.fsPath}" as no transformation has been configured`
    );
    return;
  }
  try {
    const text = textDocument.getText();
    const report = await htmlvalidate.validateString(text, uri.fsPath);
    if (report.results.length === 0) {
      void connection.sendDiagnostics({ uri: resource, diagnostics: [] });
      return;
    }
    const config2 = await htmlvalidate.getConfigFor(uri.fsPath);
    const messages = report.results[0].messages;
    const diagnostics = await Promise.all(
      messages.map((entry) => {
        return convertDiagnostic(textDocument, config2, htmlvalidate, entry);
      })
    );
    documentDiagnostics.set(resource, diagnostics);
    void connection.sendDiagnostics({ uri: resource, diagnostics });
  } catch (err) {
    connection.tracer.log(String(err));
    documentEnabled.set(resource, false);
    connection.sendRequest(ConfigErrorRequest, {
      error: err instanceof Error ? err.message : String(err)
    }).then(void 0, () => {
    });
  }
}
connection.onInitialize(() => {
  return {
    capabilities: {
      textDocumentSync: import_node.TextDocumentSyncKind.Full,
      codeActionProvider: true,
      hoverProvider: true
    }
  };
});
connection.onInitialized(() => {
  void connection.client.register(import_node.DidChangeConfigurationNotification.type, void 0);
  connection.workspace.onDidChangeWorkspaceFolders(() => {
    documentEnabled.clear();
    documentSettings.clear();
    documentValidator.clear();
    documentDiagnostics.clear();
  });
});
connection.onDidChangeConfiguration(() => {
  documentEnabled.clear();
  documentSettings.clear();
  documentValidator.clear();
  documentDiagnostics.clear();
  for (const textDocument of documents.all()) {
    void validateTextDocument(textDocument);
  }
});
documents.onDidClose((e) => {
  documentEnabled.delete(e.document.uri);
  documentSettings.delete(e.document.uri);
  documentValidator.delete(e.document.uri);
  documentDiagnostics.delete(e.document.uri);
  void connection.sendDiagnostics({ uri: e.document.uri, diagnostics: [] });
});
documents.onDidChangeContent((change) => {
  void validateTextDocument(change.document);
});
connection.onDidChangeWatchedFiles((_change) => {
  documentEnabled.clear();
  documentValidator.clear();
  documentDiagnostics.clear();
  for (const textDocument of documents.all()) {
    void validateTextDocument(textDocument);
  }
});
connection.onCodeAction((params) => onCodeAction.call(apiContext, params));
connection.onHover((params) => onHover.call(apiContext, params));
documents.listen(connection);
connection.listen();
